@c -*- coding: utf-8; mode: texinfo; documentlanguage: de -*-

@ignore
    Translation of GIT committish: 32114617e6b96617749a3c4efb4fa2203a8c3d50

    When revising a translation, copy the HEAD committish of the
    version that you are working on.  For details, see the Contributors'
    Guide, node Updating translation committishes..
@end ignore

@c \version "2.12.0"

@node Die Ausgabe verändern
@chapter Die Ausgabe verändern
@translationof Tweaking output

In diesem Kapitel wird erklärt, wie man die Notenausgabe verändern
kann. In LilyPond kann man sehr viel konfigurieren, fast jedes 
Notenfragment kann geändert werden.


@menu
* Grundlagen für die Optimierung::
* Die Referenz der Programminterna::
* Erscheinung von Objekten::
* Positionierung von Objekten::
* Kollision von Objekten::
* Weitere Optimierungen::
@end menu


@node Grundlagen für die Optimierung
@section Grundlagen für die Optimierung
@translationof Tweaking basics

@menu
* Grundlagen zur Optimierung::
* Objekte und Schnittstellen::
* Regeln zur Benennung von Objekten und Eigenschaften::
* Optimierungsmethoden::
@end menu

@node Grundlagen zur Optimierung
@subsection Grundlagen zur Optimierung
@translationof Introduction to tweaks

@qq{Optimierung} (engl. tweaking) ist ein LilyPond-Begriff für die
verschiedenen Methoden, die Aktionen zu beeinflussen, die während
der Kompilation einer Notationsdatei vorgenommen werden sowie auf
das Notenbild einzuwirken. Einige dieser Opitmierungen sind sehr 
einfach, andere dagegen recht komplex. Aber insgesamt erlaubt das
System an Optimierungen so gut wie alle möglichen Erscheindungsformen
für die Notenausgabe.

In diesem Abschnitt werden die grundlegenden Konzepte vorgestellt,
um die Optimierung zu verstehen. Später soll eine Anzahl von fertigen
Befehlen bereitgestellt werden, die einfach in die Quelldatei
kopiert werden können um den selben Effekt wie im Beispiel
zu erhalten. Gleichzeitig zeigen diese Beispiele, wie die Befehle
konstruiert werden, so dass Sie in der Lage sein werden, eigene
Befehle auf dieser Grundlage zu entwickeln.

Bevor Sie mit diesem Kapitel beginnen, könnte Sie ein Blick in den
Abschnitt @ref{Kontexte und Engraver} interessieren, dann
Kontexte und Engraver sowie die Eigenschaften, die mit ihnen 
verknüpft sind, sind die Voraussetzung, um die Funktionsweise
von Optimierungen verstehen zu können.


@node Objekte und Schnittstellen
@subsection Objekte und Schnittstellen
@translationof Objects and interfaces

@cindex Objekte
@cindex Grobs
@cindex Spanners
@cindex Interfaces
@cindex Strecker
@cindex Schnittstellen
@cindex graphische Objekte (Grob)
@cindex Objekteigenschaften
@cindex Layout-Objekt
@cindex Objekt, Layout-
@cindex Eigenschaften von Objekten

Optimierung bedeutet, die internen Operationen und Strukturen
des LilyPond-Programmes zu verändern, darum sollen hier
zunächst die wichtigesten Begriffe erklärt werden, die zur
Beschreibung dieser Operationen und Strukturen benutzt werden.

Der Begriff @qq{Objekt} ist ein allgemeiner Begriff, mit dem
die Vielzahl an internen Strukturen bezeichnet wird, die LilyPond
während der Bearbeitung des Quelltextes erstellt. Wenn etwa
ein Befehl wie @code{\new Staff} auftritt, wird ein neues Objekt
vom Typ @code{Staff} erstellt. Dieses Objekt @code{Staff} enthält
dann alle Eigenschaften, die mit diesem speziellen Notensystem
verknüpft sind, wie beispielsweise seine Bezeichnung, Tonart und
spezifische Angaben über die Engraver, die innerhalb dieses Systems
eingesetzt werden. Für alle anderen Kontexte gibt es genauso
Objekte, die deren Eigenschaften beinhalten, beispielsweise für
@code{Voice}-Objekte, @code{Score}-Objekte, @code{Lyrics}-Objekte,
aber auch für Objekte, die Notationselemente wie die Taktlinien,
Notenköpfe, Bögen und Dynamikbezeichnung enthalten. Jedes
Objekt hat eine eigene Gruppe an Eigenschaftswerten.

Bestimmte Objekttypen tragen besondere Bezeichnungen. Objekte, die
Notationselemente der gesetzten Ausgabe repräsentieren, also
Notenköpfe, Hälse, Bögen, Fingersatz, Schlüssel usw., werden
@qq{Layout-Objekte}, oft auch @qq{Graphische Objekte} genannt.
Daraus resultiert die künstliche Abkürzung @qq{Grob}.
Diese sind auch Objekte im allgemeinen Sinn und haben genauso
Eigenschaften, die mit ihnen verknüpft sind, wie etwa Größe, Position,
Farbe usw.

Einige Layout-Objekte sind etwas spezieller. Phrasierungsbögen,
Crescendo-Klammern, Oktavierungszeichen und viele andere
Grobs sind nicht an einer Stelle plaziert -- sie haben vielmehr
einen Anfangspunkt, einen Endpunkt und eventuell noch andere
Eigenschaften, die ihre Form bestimmen. Objekte mit solch
einer erweiterten Gestalt werden als @qq{Strecker} (engl. Spanners)
bezeichnet.

Es bleibt uns noch übrig zu erklären, was @qq{Schnittstellen}
(engl. interface) sind. Wenn auch viele Objekte sehr unterschiedlich
sind, haben sie doch oft gemeinsame Eigenschaften, die auf 
die gleiche Weise verarbeitet werden.  Alle Grobs beispielsweise
haben eine Farbe, eine Größe, eine Position usw. und alle
diese Eigenschaften werden von LilyPond auf die gleiche Weise
verarbeitet, während der Quelltext in Notensatz umgesetzt wird.
Um die internen Operationen zu vereinfachen, sind alle diese
gemeinsamen Prozesse und Eigenschaften in einem Objekt
mit der Bezeichnung @code{grob-interface} (Schnittstelle eines
graphischen Objektes) zusammengefasst. Es gibt viele andere
Gruppen gemeinsamer Eigenschaften, die jede eine Bezeichnung
besitzen, welche auf @code{-interface} endet. Insgesamt 
gibt es über 100 dieser Schnittstellen. Wir werden später sehen,
was es damit auf sich hat.

Dies waren die Hauptbegriffe, die in diesem Kapitel zur Anwendung
kommen sollen.


@node Regeln zur Benennung von Objekten und Eigenschaften
@subsection Regeln zur Benennung von Objekten und Eigenschaften
@translationof Naming conventions of objects and properties

@cindex Benennungskonventionen für Objekte
@cindex Benennungskonventionen für Eigenschaften
@cindex Objekte, Benennungskonventionen
@cindex Eigenschaften, Benennungskonventionen
@cindex Regeln zur Benennung von Objekten/Eigenschaften

Es wurden schon früher einige Regeln zur Benennung von
Objekten vorgestellt, siehe
@ref{Kontexte und Engraver}. Hier eine Referenzliste der
häufigsten Objekt- und Eigenschaftsbezeichnungen mit 
den Regeln für ihre Bezeichnung und 
illustrierenden echten Bezeichnungen. Es wurde @qq{A}
für einen beliebigen Großbuchstaben und @qq{aaa} für eine
beliebige Anzahl an Kleinbuchstaben eingesetzt. Andere 
Zeichen werden explizit angegeben.

@multitable @columnfractions .33 .33 .33
@headitem Objekt-/Eigenschaftstyp
  @tab Naming convention
  @tab Beispiele
@item Kontexte
  @tab Aaaa oder AaaaAaaaAaaa
  @tab Staff, GrandStaff
@item Layout-Objekte
  @tab Aaaa oder AaaaAaaaAaaa
  @tab Slur, NoteHead
@item Engraver
  @tab Aaaa_aaa_engraver
  @tab Clef_engraver, Note_heads_engraver
@item Schnittstellen
  @tab aaa-aaa-interface
  @tab grob-interface, break-aligned-interface
@item Kontext-Eigenschaften
  @tab aaa oder aaaAaaaAaaa
  @tab alignAboveContext, skipBars
@item Layout-Objekt-Eigenschaften
  @tab aaa oder aaa-aaa-aaa
  @tab direction, beam-thickness
@end multitable

Es wird bald ersichtlich werden, dass die Eigenschaften von
unterschiedlichen Objekttypen mit unterschiedlichen Befehlen
geändert werden. Deshalb ist es nützlich, aus der
Schreibweise zu erkennen, um was
für ein Objekt es sich handelt, um den entsprechenden
Befehl einsetzen zu können.


@node Optimierungsmethoden
@subsection Optimierungsmethoden
@translationof Tweaking methods

@cindex override-Befehl
@funindex \override
@funindex override

@strong{Der \override-Befehl}

Wir haben uns schon mit den Befehlen @code{\set}
und @code{\with} bekannt gemacht, mit welchen
Eigenschaften von @strong{Kontexten} verändert
und @strong{Engraver} entfernt oder hinzugefügt 
werden können. Siehe dazu 
@ref{Kontexteigenschaften verändern} und @ref{Engraver hinzufügen und entfernen}. Jetzt wollen wir uns weitere
wichtige Befehle anschauen.

Der Befehl, um die Eigenschaften von @strong{Layout-Objekten}
zu ändern, ist @code{\override}. Weil dieser Befehl interne
Eigenschaften tief in der Programmstruktur von LilyPond 
verändern muss, ist seine Syntax nicht so einfach wie die der
bisherigen Befehle. Man muss genau wissen, welche Eigenschaft
welches Objektes in welchem Kontext geändert werder soll,
und welches der neu zu setzende Wert dann ist. Schauen wir
uns an, wie das vor sich geht.

Die allgemeine Syntax dieses Befehles ist:

@example
\override @var{Kontext}.@var{LayoutObjekt} #'@var{layout-eigenschaft} =
#@var{Wert}
@end example

@noindent
Damit wir die Eigenschaft mit der Bezeichnung @var{layout-property}
das Layout-Objektes mit der Bezeichnung@var{LayoutObject},
welches ein Mitglied des @var{Kontext}-Kontextes ist, auf den
Wert @var{value}.

Der @var{Kontext} kann (und wird auch normalerweise) ausgelassen
werden, wenn der benötigte Kontext eindeutig impliziert ist und einer
der untersten Kontexte ist, also etwa @code{Voice}, @code{ChordNames}
oder @code{Lyrics}. Auch in diesem Text wird der Kontext oft ausgelassen
werden. Später soll gezeigt werden, in welchen Fällen er ausdrücklich
definiert werden muss.

Spätere Abschnitte behandeln umfassend Eigenschaften und ihre
Werte, aber um ihre Funktion und ihr Format zu demonstrieren,
werden wir hier nur einige einfache Eigenschaften und Werte einsetzen,
die einfach zu verstehen sind.

Für den Moment könne Sie die @code{#'}-Zeichen ignorieren, die vor jeder
Layout-Eigenschaft, und die @code{#}-Zeichen, die vor jedem Wert
stehen. Sie müssen immer in genau dieser Form geschrieben werden.
Das ist der am häufigsten gebrauchte Befehl für die Optimierung,
und der größte Teil dieses Abschnittes wird dazu benutzt, seine Benutzung
zu erläutern. Hier ein einfaches Beispiel, um die Farbe des Notenkopfes
zu ändern:

@cindex color-Eigenschaft, Beispiel
@cindex Farb-Eigenschaft, Beispiel
@cindex NoteHead, Beispiel für override
@cindex Notenkopf, Beispiel für Veränderung

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
c d
\override NoteHead #'color = #red
e f g
\override NoteHead #'color = #green
a b c
@end lilypond


@strong{Der \revert-Befehl}

@cindex revert-Befehl
@funindex \revert
@funindex revert

Wenn eine Eigenschaft einmal überschrieben wurde, wird ihr
neuer Wert so lange bewahrt, bis er noch einmal überschrieben
wird oder ein @code{\revert}-Befehl vorkommt. Der
@code{\revert}-Befehl hat die folgende Syntax und setzt den
Wert der Eigenschaft zurück auf den Standardwert, nicht
jedoch auf den vorigen Wert, wenn mehrere 
@code{\override}-Befehle benutzt wurden.

@example
\revert @var{Kontext}.@var{LayoutObjekt} #'@var{layout-eigenschaft}
@end example

Wiederum, genauso wie der @var{Kontext} bei dem @code{\override}-Befehl,
wird @var{Kontext} oft nicht benötigt. Er wird in vielen der folgenden
Beispiele ausgelassen. Im nächsten Beispiel wird die Farbe des Notenkopfes
wieder auf den Standardwert für die letzten zwei Noten gesetzt.

@cindex color-Eigenschaft, Beispiel
@cindex Farb-Eigenschaft, Beispiel
@cindex NoteHead, Beispiel für override
@cindex Notenkopf, Beispiel für Veränderung

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
c d
\override NoteHead #'color = #red
e f g
\override NoteHead #'color = #green
a
\revert NoteHead #'color
b c
@end lilypond

@strong{\once-Präfix}

@funindex \once
@funindex once

Sowohl der @code{\override}-Befehl als auch der @code{\set}-Befehl können mit
dem Präfix @code{\once} (@emph{einmal}) versehen werden. Dadurch wird
der folgende @code{\override}- oder @code{\set}-Befehl nur für den aktuellen
Musik-Moment wirksam, bevor sich wieder der Standard einstellt. Am gleichen
Beispiel demonstriert, kann damit die Farbe eines einzelnen Notenkopfes
geändert werden:

@cindex color-Eigenschaft, Beispiel
@cindex Farb-Eigenschaft, Beispiel
@cindex NoteHead, Beispiel für override
@cindex Notenkopf, Beispiel für Veränderung

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
c d
\once \override NoteHead #'color = #red
e f g
\once \override NoteHead #'color = #green
a b c
@end lilypond


@strong{Der \overrideProperty-Befehl}

@cindex overrideProperty-Befehl

@funindex \overrideProperty
@funindex overrideProperty

Es gibt eine andere Form des @code{override}-Befehls,
@code{\overrideProperty} (überschreibe Eigenschaft), 
welcher ab und zu benötigt wird. Es wird hier nur der
Vollständigkeit halber erwähnt, sein Einsatz wird demonstriert
in @ruser{Schwierige Korrekturen}.
@c Maybe explain in a later iteration  -td


@strong{Der \tweak-Befehl}

@cindex tweak-Befehl
@funindex \tweak
@funindex tweak

Der letzte Optimierungsbefehl in LilyPond ist @code{\tweak}
(engl. optimieren). Er wird eingesetzt um Eigenschaften
von Objekten zu verändern, die zum selben Musik-Moment
auftreten, wie etwa die Noten eines Akkordes. Ein
@code{\override} würde alle Noten des Akkords beeinflussen,
während mit @code{\tweak} nur das nächste Objekt der
Eingabe geändert wird.

Hier ein Beispiel. Angenommen, die Größe des mittleren 
Notenkopfes (ein E) in einem C-Dur-Akkord soll geändert 
werden. Schauen wir zuerst, was wir mit 
@code{\once \override} erhalten:

@cindex Schriftgröße, Beispiel
@cindex NoteHead, Beispiel für override
@cindex Notenkopf, Beispiel für Veränderung

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
  <c e g>4
  \once \override NoteHead #'font-size = #-3
  <c e g>
  <c e g>
@end lilypond

Wie man sehen kann, beeinflusst @code{override} @emph{alle} 
Notenköpfe des Akkordes. Das liegt daran, dass alle die Noten
eines Akkordes zum selben Musik-Moment auftreten und
die Funktion von @code{\once} ist es, die Optimierung auf
an allen Objekten auszuführen, die zum selben Musik-Moment
auftreten wie der @code{\override}-Befehl.

Der @code{\tweak}-Befehl funktioniert anders. Er bezieht sich
auf das direkt folgende Element in der Eingabe-Datei. Es wirkt
aber auch nur mit Objekten, die direkt von der Eingabe kreirt
werden, insbesondere Notenköpfe und Artikulationszeichen.
Objekte wie etwa Hälse oder Versetzungszeichen werden erst
später erstellt und lassen sich nicht auf diese Weise ändern.
Zusätzlich @emph{müssen} sich etwa Notenköpfe innerhalb
eines Akkordes befinden, d. h. sie müssen von einfachen spitzen
Klammern umschlossen sein. Um also eine einzelne Note
mit @code{\tweak} zu verändern, muss der Befehl innerhalb
der spitzen Klammern zusammen mit der Note eingegeben werden.

Um also zu unserem Beispiel zurückzukommen, könnte man die
mittlere Note eines Akkordes auf diese Weise ändern:

@cindex font-size-Eigenschaft, Beispiel
@cindex Schriftgröße, Beispiel
@cindex @code{\tweak}-Beispiel

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
  <c e g>4
  <c \tweak #'font-size #-3 e g>4
@end lilypond

Beachten Sie, dass die Syntax des @code{\tweak}-Befehls sich
von der des @code{\override}-Befehls unterscheidet. Weder
Kontext noch Layout-Objekt konnen angegeben werden, denn 
das würde zu einem Fehler führen. Beide Angaben sind 
durch das folgende Element impliziert. Hier sollte auch
kein Gleichheitzeichen vorhanden sein.  Die verallgemeinerte
Syntax des @code{\tweak}-Befehls ist also einfach

@example
\tweak #'@var{layout-eigenschaft} #@var{Wert}
@end example

Ein @code{\tweak}-Befehl kann auch benutzt werden, um nur 
eine von mehreren Artikulationen zu ändern, wie im nächsten
Beispiel zu sehen ist.

@cindex Farb-Eigenschaft, Beispiel
@cindex @code{\tweak}-Beispiel

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
a ^Black
  -\tweak #'color #red ^Red
  -\tweak #'color #green _Green
@end lilypond

@noindent
Beachten Sie, dass dem @code{\tweak}-Befehl ein Artikulationsmodifikartor
vorangestellt werden muss, ganz als ob er selbst ein Artikulationszeichen
wäre.

@cindex Triolen, geschachtelt
@cindex N-tolen, geschachtelt
@cindex Klammer, Triole
@cindex Triolenklammer
@cindex N-tolenklammer
@cindex Komplizierte Rhythmen, Schachtelung von
@funindex TupletBracket

Der @code{\tweak}-Befehl muss auch benutzt werden, wenn das
Aussehen einer vor mehreren geschachtelten Triolenklammern
geändert werden soll, die zum selben Zeitpunkt beginnen.
Im folgenden Beispiel beginnen die lange Klammer und die
erste Triolenklammer zum selben Zeitpunkt, sodass ein
@code{\override}-Befehl sich auf beide beziehen würde.
In dem Beispiel wird @code{\tweak} benutzt, um zwischen
ihnen zu unterscheiden. Der erste @code{\tweak}Befehl
gibt an, dass die lange Klammer über den Noten gesetzt
werden soll, und der zweite, dass die Zahl der rhythmischen
Aufteilung für die erste der kurzen Klammern in rot
gesetzt wird.

@cindex Farb-Eigenschaft, Beispiel
@cindex @code{\tweak}-Beispiel
@cindex Richtungs-Eigenschaft, Beispiel
@cindex color-Eigenschaft, Beispiel
@cindex direction-Eigenschaft, Beispiel

@lilypond[quote,ragged-right,verbatim,fragment,relative=2]
\tweak #'direction #up
\times 4/3 {
  \tweak #'color #red
  \times 2/3 { c8[ c8 c8] }
  \times 2/3 { c8[ c8 c8] }
  \times 2/3 { c8[ c8 c8] }
}
@end lilypond

Wenn geschachtelte N-tolen nicht zum gleichen Zeitpunkt 
beginnen, kann ihr Aussehen auf die übliche Art mit dem
@code{\override}-Befehl geändert werden:

@cindex text-Eigenschaft, Beispiel
@cindex tuplet-number-Funktion, Beispiel
@cindex transparent-Eigenschaft, Beispiel
@cindex TupletNumber, Beispiel zur Veränderung
@cindex Triolennummer, Beispiel zur Veränderung
@cindex Triolen-Nummer-Funktion, Beispiel

@c NOTE Tuplet brackets collide if notes are high on staff
@c See issue 509
@lilypond[quote,ragged-right,verbatim,fragment,relative=1]
\times 2/3 { c8[ c c]}
\once \override TupletNumber
  #'text = #tuplet-number::calc-fraction-text
\times 2/3 {
  c[ c]
  c[ c]
  \once \override TupletNumber #'transparent = ##t
  \times 2/3 { c8[ c c] }
\times 2/3 { c8[ c c]}
}
@end lilypond


@seealso
Notationsreferenz:
@ruser{Der tweak-Befehl}.


@node Die Referenz der Programminterna
@section Die Referenz der Programminterna
@translationof The Internals Reference manual

@menu
* Eigenschaften von Layoutobjekten::
* Eigenschaften, die Schnittstellen besitzen können::
* Typen von Eigenschaften::
@end menu

@node Eigenschaften von Layoutobjekten
@subsection Eigenschaften von Layoutobjekten
@translationof Properties of layout objects

@cindex Eigenschaften von Layout-Objekten
@cindex Eigenschaften von Grobs
@cindex Grobs, Eigenschaften von
@cindex Layout-Objekte, Eigenschaften von
@cindex Property (Layout-Objekte, Grobs)
@cindex Regerenz der Interna

Angenommen, in Ihrer Partitur tritt ein Legatobogen
auf, der Ihrer Meinung nach zu dünn ausgefallen ist.
Sie würden ihn gerne etwas schwerer gezeichnet 
sehen. Wie gehen Sie vor? Von den Anmerkungen in
früheren Abschnitten wissen Sie schon, dass LilyPond
sehr flexibel ist und eine derartige Modifikation
möglich sein sollte, und Sie erraten vielleicht,
dass ein @code{\override}-Befehl angebracht ist.
Aber gibt es eine Eigenschaft für die Dicke eines
Legatobogens (engl. slur), und wenn es sie gibt,
auf welche Weise lässt sie sich verändern? Hier 
kommt die Referenz der Interna zur Geltung. Dort
finden sich alle Informationen, um den beschriebenen
und alle anderen @code{\override}-Befehle zu
konstruieren.

Bevor Sie jetzt in die Referenz der Interna wechseln, ist
eine Warnung angebracht. Es handelt sich um ein
@strong{Referenz}dokument, was heißt, dass es sehr
wenig oder gar keine Erklärungen enthält: seine Aufgabe
ist es, Information klar und genau darzustellen. Das
bedeutet, dass es auf den ersten Blick entmutigend
wirkt. Die Einführung und Erklärung in diesem Abschnitt
wird Ihnen aber schnell ermöglichen, genau die Information
aus der Referenz zu entnehmen, die Sie benötigen.
@c For German users
Beachten Sie, dass die Referenz der Interna nur auf Englisch
existiert. Um die Eigenschaftsbezeichnung eines bestimmten
Objektes zu finden, können Sie das Glossar (siehe
@rglosnamed{Top,Musikglossar})
 verwenden, in dem
die englischen Begriffe in viele andere Sprachen übersetzt sind.

@cindex Override-Beispiel
@cindex Referenz der Interna, Benutzung
@cindex IR (Referenz der Interna), Benutzung
@cindex @code{\addlyrics}-Beispiel

Das Vorgehen soll an einem konkreten Beispiel einer echten
Komposition demonstriert werden. Hier das Beispiel:

@lilypond[quote,verbatim,relative=2]
{
  \time 6/8
  {
    r4 b8 b[( g]) g |
    g[( e]) e d[( f]) a |
    a g
  }
  \addlyrics {
    The man who feels love's sweet e -- mo -- tion
  }
}
@end lilypond

Angenommen also, wir wollen die Legatobögen etwas
dicker setzten. Ist das möglich? Die Legatobögen sind mit
Sicherheit ein Layout-Objekt, die Frage muss also lauten:
@qq{Gibt es eine Eigenschaft von Legatobögen, die die
Dicke bestimmt?} Um diese Frage zu beantworten, müssen
wir in der Referenz der Interna ( kurz IR) nachschauen.

Die IR für die LilyPond-Version, die Sie benutzen, findet sich
auf der LilyPond-Webseite unter der Adresse 
@uref{http://lilypond.org}. Gehen Sie zur Dokumentationsseite
und klicken Sie auf den Link zur Referenz der Interna.
@c Addition for German users
Die Sprache ändert sich ab hier nach englisch. Für diese Übung
sollten Sie die HTML-Version benutzen, nicht die
@qq{auf einer großen Seite} oder die PDF-Version.
Damit Sie die nächsten Absätze verstehen können, müssen Sie
genauso vorgehen, während Sie weiterlesen.

Unter der Überschrift @strong{Top} befinden sich fünf Links.
Wählen Sie den Link zum @emph{Backend}, wo sich die Information
über Layout-Objekte befindet. Hier, unter der Überschrift
@strong{Backend}, wählen Sie den Link @emph{All layout objects}.
Die Seite, die sich öffnet, enthält ein Liste aller Layout-Objekte,
die in Ihrerer LilyPond-Version benutzt werden, in alphabetischer
Ordnung. Wählen Sie den Link @emph{Slur} und die Eigenschaften
der Legatobögen (engl. slur) werden aufgelistet.

Eine alternative Methode, auf diese Seite zu gelangen, ist von
der Notationsreferenz aus. Auf einer der Seiten zu Legatobögen
findet sich ein Link zur Referenz der Interna. Dieser Link führt
Sie direkt auf diese Seite. Wenn Sie aber eine Ahnung haben, 
wie die Bezeichnung des Layout-Objektes lauten könnte, das sie
ändern wollen, ist es oft schneller, direkt zur IR zu gehen und 
dort nachzuschlagen.

Aus der Slur-Seite in der IR könne wir entnehmen, dass
Legatobögen (Slur-Objekte) durch den Slur_engraver erstellt
werden. Dann werden die Standardeinstellungen aufgelistet.
Beachten Sie, dass diese @strong{nicht} in alphabetischer Reihenfolge
geordnet sind. Schauen Sie sich die Liste an, ob sie eine Eigenschaft
enthält, mit der die Dicke von Legatobögen kontrolliert werden kann.
Sie sollten folgendes finden:

@example
@code{thickness} (number)
     @code{1.2}
     Line thickness, generally measured in @code{line-thickness}
@end example

Das sieht ganz danach aus, als ob damit die Dicke geändert
werden kann. Es bedeutet, dass der Wert von
@code{thickness} einfach eine Zahl (@emph{number}) ist,
dass der Standardwert 1.2 ist, und dass die Einheit
für die Dicke eine andere Eigenschaft mit der
Bezeichnung @code{line-thickness} ist.

Wie schon früher gesagt, gibt es wenig bis gar keine Erklärungen
in der IR, aber wir haben schon genug Informationen, um
zu versuchen, die Dicke eines Legatobogens zu ändern. Die
Bezeichnung des Layout-Objekts ist offensichtlich
@code{Slur} und die Bezeichnung der Eigenschaft, die geändert
werden soll
@code{thickness}. Der neue Wert sollte etwas mehr als 1.2 sein,
denn der Bogen soll ja dicker werden.

Den benötigten @code{\override}-Befehl können wir jetzt einfach
konstruieren, indem wir die Werte für die Bezeichnungen in den
Modellbefehl einfügen und den Kontext auslassen. Setzen wir
einmal einen sehr großen Wert für die Dicke um zu sehen, ob der
Befehl auch funktioniert. Also:

@example
\override Slur #'thickness = #5.0
@end example

Vergessen Sie nicht das Rautenzeichen und Apostroph
(@code{#'}) vor der Eigenschaftsbezeichnung und das
Rautenzeichen vor dem neuen Wert!

Die nächste Frage ist nun: @qq{Wohin soll dieser Befehl geschrieben
werden?} Solange wir uns noch im Lernstadium befinden, ist
die beste Antwort: @qq{Innerhalb der Noten, vor den ersten
Legatobogen und nahe bei ihm.} Also etwa so:

@cindex Legatobogen, Beispiel für Veränderung
@cindex thickness-Eigenschaft, Beispiel
@cindex Dicke-Eigenschaft, Beispiel

@lilypond[quote,verbatim,relative=2]
{
  \time 6/8
  {
    % Increase thickness of all following slurs from 1.2 to 5.0
    \override Slur #'thickness = #5.0
    r4 b8 b[( g]) g |
    g[( e]) e d[( f]) a |
    a g
  }
  \addlyrics {
    The man who feels love's sweet e -- mo -- tion
  }
}
@end lilypond

@noindent
und wirklich wird der Legatobogen dicker.

Das ist also die grundlegende Herangehensweise, 
@code{\override}-Befehl zu formulieren. Es gibt einige
zusätzliche Komplikationen, denen wir uns später widmen
werden, aber Sie haben jetzt das Handwerkszeug, um Ihre
eigenen Befehle zu konstruieren -- wenn Sie auch noch etwas
Übung benötigen. Die sollen Sie durch die folgenden Übungen
erhalten.


@subheading Den Kontext finden

@cindex Kontext, Finden und identifizieren

Manchmal muss dennoch der Kontext spezifiziert werden.
Welcher aber ist der richtige Kontext? Wir könnten raten,
dass Legatobögen sich im @code{Voice}-Kontext befinden,
denn sie sind immer einzelnen Melodielinien zugewiesen.
Aber wir können uns dessen nicht sicher sein. Um unsere
Annahme zu überprüfen, gehen wir wieder zu der Seite im
IR, die die Legatobögen beschreibt und die Überschrift
@emph{Slur} hat. Dort steht: @qq{Slur objects are created 
by: Slur engraver}. Legatobögen werden also in dem Kontext
erstellt, in dem sich der @code{Slur_engraver} befindet. 
Folgen Sie dem Link zu der @code{Slur_engraver}-Seite.
Unten auf der Seite steht, dass der @code{Slur_engraver}
sich in fünf Stimmen-Kontexten befindet, unter anderem
auch im normalen @code{Voice}-Kontext. Unsere Annahme
war also richtig. Und weil @code{Voice} einer der Kontexte
der untersten Ebene ist, welcher eindeutig schon dadurch
definiert ist, dass wir Noten eingeben, kann er an dieser Stelle
auch weggelassen werden.


@subheading Nur einmal mit \override verändern

@cindex Override nur einmal
@cindex once override
@funindex \once
@funindex once

Im Beispiel oben wurden @emph{alle} Legatobögen dicker
gesetzt. Vielleicht wollen Sie aber nur den ersten Bogen
dicker haben. Das können Sie mit dem @code{\once}-Befehl
erreichen. Er wird direkt vor den @code{\override}-Befehl
gesetzt und bewirkt, dass nur der Bogen geändert wird, der
@strong{unmittelbar an der nächsten Note beginnt.} Wenn
die nächste Note keinen Bogenbeginn hat, dann passiert
gar nichts -- der Befehl wird nicht gespeichert, sondern einfach
vergessen. Der Befehl, mit @code{\once} zusammen benutzt,
muss also wie folgt positioniert werden:

@cindex Legatobogen, Beispiel zur Veränderung
@cindex thickness-Eigenschaft, Beispiel

@lilypond[quote,verbatim,relative=2]
{
  \time 6/8
  {
    r4 b8
    % Increase thickness of immediately following slur only
    \once \override Slur #'thickness = #5.0
    b[( g]) g |
    g[( e]) e d[( f]) a |
    a g
  }
  \addlyrics {
    The man who feels love's sweet e -- mo -- tion
  }
}
@end lilypond

@noindent
Jetzt bezieht er sich nur noch auf den ersten Legatobogen.

Der @code{\once}-Befehl kann übrigens auch vor einem @code{\set}-Befehl
eingesetzt werden.


@subheading Rückgängig machen

@cindex Revert
@cindex Rückgängig machen
@cindex Wiederherstellen von Standardeinstellungen
@cindex Standardeinstellungen, Wiederherstellen
@funindex \revert
@funindex revert

Eine weitere Möglichkeit: nur die beiden ersten Legatobögen sollen
dicker gesetzt werden. Gut, wir könnten jetzt zwei Befehle benutzen,
jeden mit dem @code{\once}-Präfix und direkt vor die entsprechende
Note gestellt, an welcher der Bogen beginnt:

@cindex Legatobogen, Beispiel zur Veränderung
@cindex thickness-Eigenschaft, Beispiel

@lilypond[quote,verbatim,relative=2]
{
  \time 6/8
  {
    r4 b8
    % Increase thickness of immediately following slur only
    \once \override Slur #'thickness = #5.0
    b[( g]) g |
    % Increase thickness of immediately following slur only
    \once \override Slur #'thickness = #5.0
    g[( e]) e d[( f]) a |
    a g
  }
  \addlyrics {
    The man who feels love's sweet e -- mo -- tion
  }
}
@end lilypond

@noindent
Wir könnten aber auch den @code{\once}-Befehl weglassen und anstelle 
dessen später den @code{\revert}-Befehl einsetzen, um die
@code{thickness}-Eigenschaft wieder auf ihren Standardwert zurückzusetzen:

@cindex Legatobogen, Beispiel zur Veränderung
@cindex thickness-Eigenschaft, Beispiel

@lilypond[quote,verbatim,relative=2]
{
  \time 6/8
  {
    r4 b8
    % Increase thickness of all following slurs from 1.2 to 5.0
    \override Slur #'thickness = #5.0
    b[( g]) g |
    g[( e])
    % Revert thickness of all following slurs to default of 1.2
    \revert Slur #'thickness
    e d[( f]) a |
    a g
  }
  \addlyrics {
    The man who feels love's sweet e -- mo -- tion
  }
}
@end lilypond

@noindent
Der @code{\revert}-Befehl kann benutzt werden, um eine beliebige
Eigenschaft, die mit @code{\override} geändert worden ist, wieder in 
ihre Standardeinstellungen zurückzuversetzen. In unserem Beispiel können
Sie die Methode benutzen, die Ihnen lieber ist, beide haben das gleiche
Resultat.

Damit endet die Einleitung in die Referenz der Interna (IR) und die
grundlegenden Optimierungsmethoden. Einige Beispiele folgen in späteren
Abschnitten dieses Kapitel, einerseits um Sie mit weiteren Möglichkeiten
der IR bekanntzumachen, andererseits um Ihnen mehr Übungsmöglichkeiten
zu geben, die relevante Information dort zu finden. Die Beispiele werden
Schritt für Schritt immer weniger Erklärungen beinhalten.


@node Eigenschaften, die Schnittstellen besitzen können
@subsection Eigenschaften, die Schnittstellen besitzen können
@translationof Properties found in interfaces

@cindex Interface-Eigenschaften
@cindex Eigenschaften von Interfaces
@cindex Schnittstellen, Eigenschaften von
@cindex Eigenschaften von Schnittstellen

Der Text unseres Beispiels soll jetzt kursiv gesetzt werden. Was für
ein @code{\override}-Befehl wird dazu benötigt? Schauen wir
uns zunächst das Inhaltsverzeichnis in der IR an: @qq{All layout objects},
wie auch schon zuvor. Welches Objekt könnte die Darstellung des
Textes (engl. lyrics) beeinflussen? Es gibt den Eintrag @code{LyricText},
das hört sich schon sehr gut an. Ein Klick hierauf zeigt alle Eigenschaften
an, die verändert werden können. Dazu gehört 
@code{font-series} und @code{font-size}, aber nichts, womit man kursiven
Text erreichen könnte. Das liegt daran, dass die Schnitteigenschaft allen
Schrift-Objekten gemeinsam ist. Sie findet sich also nicht in jedem einzlenen
Layout-Objekt aufgelistet, sondern ist mit anderen ähnlichen Eigenschaften
zusammen in einem @strong{Interface} -- einer Schnittstelle -- verortet;
in diesem Fall das
@code{font-interface}.

Jetzt müssen wir also lernen, wie wir Eigenschaften von Schnittstellen finden
und wie wir herausfinden, welche Objekte diese Schnittstelleneigenschaften
benutzen.

Schauen Sie sich noch einmal die Seite in der IR an, die @code{LyricText}
beschreibt. Unten auf der Seite ist eine klickbare Liste (in der HTML-Version
der IR) an Eigenschaften, die von @code{LyricText} unterstützt
werden. Diese Liste enthält sieben Einträge, darunter auch
@code{font-interface}. Ein Klick hierauf bringt uns zu den Eigenschaften,
die mit dieser Schnittstelle verbunden sind, also auch @code{LyricText}.

Jetzt sehen wir alle die Eigenschaften, die der Benutzer verändern kann,
um die Schriftartendarstellung zu beeinflussen. Dazu gehört nun auch
@code{font-shape(symbol)}, wobei @code{symbol} auf die Werte
@code{upright} (gerade), @code{italics} (kursiv) oder @code{caps}
(Kapitälchen) gesetzt werden kann.

Sie werden gemerkt haben, dass @code{font-series} und @code{font-size}
hier auch aufgelistet sind. Es stellt sich die Frage, warum diese
allgemeinen Schriftarteigenschaften @code{font-series} und
@code{font-size} sowohl unter der Überschrift
@code{LyricText} als unter dem @code{font-interface} aufgelistet 
sind, aber @code{font-shape} befindet sich nur im 
@code{font-interface}? Die Antwort ist: Die globalen Einstellungen 
von @code{font-series} und @code{font-size} werden geändert, wenn
ein @code{LyricText}-Objekt erstellt wird, aber @code{font-shape} 
wird davon nicht beeinflusst. Die zusätzlichen Einträge unter der
Überschrift @code{LyricText} beinhalten dann die Werte der
Standardeinstellungen dieser zwei Eigenschaften, wenn es sich
um ein @code{LyricText}-Objekt handelt. Andere Objekte,
die auch das @code{font-interface} unterstützen, setzen diese
Eigenschaften anders, wenn sie erstellt werden.

Versuchen wir nun einen @code{\override}-Befehl zu konstruieren,
der den Gesantext kursiv setzt. Das Objekt hat die Bezeichnung
@code{LyricText}, die Eigenschaft ist @code{font-shape} 
und der Wert @code{italic}. Wie vorher schon lassen wir den
Kontext aus.

Am Rande sei angemerkt, dass die Werte der @code{font-shape}-Eigenschaft
mit einem Apostroph (@code{'}) gekennzeichnet werden
müssen, weil es sich um Symbole handelt. Aus dem gleichen
Grund mussten auch für @code{thickness} weiter oben im
Text ein Apostroph gesetzt werden. Symbole sind besondere
Bezeichnungen, die LilyPond intern bekannt sind. Einige
sind Bezeichnungen von Eigenschaften, wie eben @code{thickness}
oder @code{font-shape}. Andere sind besondere Werte,
die an Eigenschaften übergeben werden können, wie
@code{italic}. Im Unterschied hierzu gibt es auch beliebige
Zeichenketten, die immer mit Anführungszeichen, also
als @code{"Zeichenkette"} auftreten. Für weitere
Einzelheiten zu Zeichenketten und Werten, siehe 
@ref{Scheme-Übung}.

Gut, der @code{\override}-Befehl, mit dem der Gesangstext
kursiv gesetzt wird, lautet:

@example
\override LyricText #'font-shape = #'italic
@end example

@noindent
und er muss direkt vor den Text gesetzt werden, auf den er sich
bezieht, etwa so:

@cindex font-shape-Eigenschaft, Beispiel
@cindex LyricText, Beispiel zur Veränderung
@cindex kursiv, Beispiel
@cindex @code{\addlyrics}, Beispiel

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 6/8
  {
    r4 b8 b[( g]) g |
    g[( e]) e d[( f]) a |
    a g
  }
  \addlyrics {
    \override LyricText #'font-shape = #'italic
    The man who feels love's sweet e -- mo -- tion
  }
}
@end lilypond

@noindent
Jetzt wird der Text kursiv gesetzt.


@subheading Den Kontext im Liedtextmodus bestimmen


@cindex Kontext im Gesangstextmodus angeben
@cindex Gesangstextmodus, Kontext angeben

Bei Gesangstexten funktioniert der @code{\override}-Befehl
nicht mehr, wenn Sie den Kontext im oben dargestellten
Format angeben.  Eine Silbe wird im Gesangtextmodus
(lyricmode) entweder von einem Leerzeichen, einer
neuen Zeile oder einer Zahl beendet.  Alle anderen
Zeichen werden als Teil der Silbe integriert.  Aus diesem 
Grund muss auch vor der schließenden Klammer
@code{@}} ein Leerzeichen gesetzt oder eine neue
Zeile begonnen werden.  Genauso müssen Leerzeichen
vor und nach einem Punkt benutzt werden, um die
Kontext-Bezeichnung von der Objekt-Bezeichnung zu 
trennen, denn sonst würden beide Bezeichnungen als
ein Begriff interpretiert und von LilyPond nicht verstanden 
werden.  Der Befehl muss also lauten:

@example
\override Lyrics . LyricText #'font-shape = #'italic
@end example

@warning{Innerhalb von Gesangstext muss immer ein
Leerzeichen zwischen der letzten Silbe und der schließenden
Klammer gesetzt werden.}

@warning{Innerhalb von @code{\override}-Befehlen in
Gesangstexten müssen Leerzeichen um Punkte zwischen
Kontext- und Objektbezeichnungen gesetzt werden.}


@node Typen von Eigenschaften
@subsection Typen von Eigenschaften
@translationof Types of properties

@cindex Eigenschaftsarten

Bis jetzt hatten wir es mit zwei Arten von Eigenschaften zu
tun: @code{number} (Zahl) und @code{symbol}.  Damit
ein Befehl funktioniert, muss der Wert einer Eigenschaft
vom richtigen Typ sein und die Regeln befolgen, die
für diesen Typ gelten.  Der Eigenschaftstyp ist in der
IR in Klammern hinter der Eigenschaftsbezeichnung
angegeben.  Hier eine Liste der Typen, die Sie vielleicht
benötigen werden, mit den Regeln, die für den jeweiligen
Typ gelten und einigen Beispielen. Sie müssen immer
ein Rautenzeichen (@code{#}) vor den Typeintrag setzen,
wenn sie in einem @code{\override}-Befehl benutzt werden.

@multitable @columnfractions .2 .45 .35
@headitem Eigenschaftstyp
  @tab Regeln
  @tab Beispiele
@item Boolesch
  @tab Entweder wahr oder falsch, dargestellt als #t oder #f
  @tab @code{#t}, @code{#f}
@item Dimension (in Notenlinienabständen)
  @tab Eine positive Dezimalzahl (in Notenlinienabstand-Einheiten)
  @tab @code{2.5}, @code{0.34}
@item Richtung
  @tab Eine gültige Richtungskonstante oder das numerische Äquivalent
  @tab @code{LEFT}, @code{CENTER}, @code{UP},
       @code{1}, @code{-1}
@item Integer
  @tab Eine positive ganze Zahl
  @tab @code{3}, @code{1}
@item Liste
  @tab Eine eingeklammerte Anzahl von Einträgen, mit Klammern getrennt
  und angeführt von einem Apostroph
  @tab @code{'(left-edge staff-bar)}, @code{'(1)},
       @code{'(1.0 0.25 0.5)}
@item Textbeschriftung (markup)
  @tab Beliebige gültige Beschriftung
  @tab @code{\markup @{ \italic "cresc." @}}
@item Moment
  @tab Ein Bruch einer ganzen Note, mit der make-moment-Funktion
  konstruiert
  @tab @code{(ly:make-moment 1 4)},
       @code{(ly:make-moment 3 8)}
@item Zahl
  @tab Eine beliebige positive oder negative Dezimalzahl
  @tab @code{3.5}, @code{-2.45}
@item Paar (Zahlenpaar)
  @tab Zwei Zahlen getrennt von @qq{Leerzeichen . Leerzeichen}, eingeklammert
  und angeführt von einem Apostroph
  @tab @code{'(2 . 3.5)}, @code{'(0.1 . -3.2)}
@item Symbol
  @tab Eine beliebige Anzahl von Symbolen, die für die Eigenschaft 
  gültig sind, angeführt von einem Apostroph
  @tab @code{'italic}, @code{'inside}
@item Unbekannt
  @tab Eine Prozedur oder @code{#f} (um keine Aktion hervorzurufen)
  @tab @code{bend::print}, @code{ly:text-interface::print},
       @code{#f}
@item Vektor
  @tab Eine Liste mit drei Einträgen, eingeklammert und mit
  Apostroph-Raute ( @code{'#}) angeführt.
  @tab @code{'#(#t #t #f)}
@end multitable


@seealso
Handbuch zum Lernen: @ref{Scheme-Übung}.


@node Erscheinung von Objekten
@section Erscheinung von Objekten
@translationof Appearance of objects

In diesem Abschnitt wollen wir zeigen, wie die Kenntnisse der
vorigen Abschnitte in der Praxis angewandt werden können,
um das Aussehen des Musiksatzes zu beeinflussen.

@menu
* Sichtbarkeit und Farbe von Objekten::
* Größe von Objekten::
* Länge und Dicke von Objekten::
@end menu


@node Sichtbarkeit und Farbe von Objekten
@subsection Sichtbarkeit und Farbe von Objekten
@translationof Visibility and color of objects

In Unterrichtsmaterial für den Musikunterricht wird oft
eine Partitur dargestellt, in der bestimmte Notationselemente
fehlen, so dass der Schüler die Aufgabe bekommt, die 
nachzutragen.  Ein einfaches Beispiel ist etwa, die
Taktlinien zu entfernen, damit der Schüler sie selber zeichnen
kann.  Aber die Tatklinien werden normalerweise automatisch
eingefügt.  Wie verhindern wir, dass sie ausgegeben werden?

Bevor wir uns hieran machen, sei daran erinnert, dass
Objekteigenschaften in sogenannten @emph{Schnittstellen}
-- engl. interface -- gruppiert sind, siehe auch
@ref{Eigenschaften, die Schnittstellen besitzen können}.  Das dient ganz einfach
dazu, die Eigenschaften zusammenzufassen, die üblicherweise
zusammen benötigt werden -- wenn eine davon für ein Objekt
gilt, dann auch die anderen.  Manche Objekte brauchen die
Eigenschaften von der einen Schnittstelle, andere von einer 
anderen.  Die Schnittstellen, die die Eigenschaften von einem
bestimmten Grob beinhalten, sind in der IR unten auf der
Seite aufgelistet, die dieses Grob beschreibt.  Die Eigenschaften
können betrachtet werden, indem die Seite der entsprechenden
Schnittstelle geöffnet wird.

Zu Information, wie man Eigenschaften von Grobs findet, siehe
@ref{Eigenschaften von Layoutobjekten}.  Wir benutzen also jetzt
die selbe Methode um in der IR das Layout-Objekt zu finden,
dass für die Tatklinien zuständig ist. Über die Überschriften
@emph{Backend} und @emph{All layout objects} kommen
wir zu einem Layout-Objekt mit der Bezeichnung
@code{BarLine} (engl. TaktLinie).  Seine Eigenschaften 
beinhalten zwei, die über die Sichtbarkeit entscheiden:
@code{break-visibility} und @code{stencil}.  
@code{BarLine} unterstützt auch einige Schnittstellen,
unter anderem @code{grob-interface}, wo wir eine
@code{transparent} und eine @code{color}-Eigenschaft
finden.  Alle können die Sichtbarkeit von Taktlinien (und
natürlich auch die Sichtbarkeit von vielen anderen Objekten)
beeinflussen.  Schauen wir uns diese Eigenschaften eine
nach der anderen an.

@subheading stencil (Matrize)

@cindex Stencil-Eigenschaft
@cindex Matrizen-Eigenschaft

Diese Eigenschaft kontrolliert die Erscheinung der Taktlinien,
indem sie das Symbol bestimmt, das ausgegeben werden soll.
Wie bei vielen anderen Eigenschaften auch, kann sie so
eingestellt werden, dass sie nichts ausgibt, indem ihr Wert
auf @code{#f} (falsch) gesetzt wird.  Ein Versuch also,
wie vorher, indem wir den impliziten Kontext (@code{Voice})
auslassen:

@cindex Taktlinie, Beispiel zur Veränderung
@cindex stencil-Eigenschaft, Beispiel

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override BarLine #'stencil = ##f
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

Die Taktlinien werden aber immer noch angezeigt.  Was ist da
falsch gelaufen?  Gehen Sie zurück zur IR und schauen Sie auf 
die Seite, die die Eigenschafter für @code{BarLine} angibt.
Oben auf der Seite steht: @qq{Barline objects are created
by: Bar_engraver}.  Schauen Sie sich die
@code{Bar_engraver}-Seite an.  Unten auf der Seite steht
eine Liste der Kontexte, in denen der Takt-Engraver
funktioniert.  Alle Kontexte sind @code{Staff}-Typen (also
Notensystem-Typen).  Der Grund, warum der
@code{\override}-Befehl nicht funktioniert hat, liegt
also darin, dass das Taktlinie-Objekt (@code{BarLine}) sich nicht
im @code{Voice}-Kontextbefindet.  Wenn der Kontext
falsch angegeben wird, bewirkt der Befehl einfach gar
nichts.  Keine Fehlermeldung wird ausgegeben und auch
nichts in die Log-Datei geschrieben.  Versuchen wir also,
den richtigen Kontext mitanzugeben:

@cindex Taktlinie, Beispiel zur Veränderung
@cindex stencil-Eigenschaft, Beispiel

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.BarLine #'stencil = ##f
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
Jetzt sind die Taktlinien wirklich verschwunden.

Es sollte jedoch beachtet werden, dass das Setzen der
@code{stencil}-Eigenschaft auf @code{#f} zu Fehlerhinweisen führen
kann, wenn die Dimensionen des Objekts für die richtige Behandlung
benötigt werden.  Zum Beispiel werden Fehler ausgegeben, wenn
die @code{stencil}-Eigenschaft des @code{NoteHead}-Objekts auf
@code{#f} gesetzt wird. Wenn dieser Fall auftritt, kann anstatt
dessen die @code{point-stencil}-Funktion benutzt werden, welche
den Stencil auf ein Objekt mit der Größe Null setzt:

@lilypond[quote,verbatim,relative=2]
{
  c c
  \once \override NoteHead #'stencil = #point-stencil
  c c
}
@end lilypond


@subheading break-visibility (unsichtbar machen)

@cindex break-visibility-Eigenschaft
@cindex Unsichtbar machen (break-visibility)

Aus der Beschreibung der Eigenschaften für @code{BarLine}
in der IR geht hervor, dass die @code{break-visibility}-Eigenschaft
einen Vektor mit drei Booleschen Werten benötigt. Diese
kontrollieren jeweils, ob die Taktlinien am Ende einer Zeile,
in der Mitte einer Zeile und am Anfang einer Zeile ausgegeben
werden.  Wenn also alle Taktlinien unsichtbar sein sollen, wie in
unserem Beispiel, brauchen wir den Wert @code{'#(#f #f #f)}.
Versuchen wir es also, und berücksichtigen wir auch den
@code{Staff}-Kontext.  Beachten Sie auch, dass Sie @code{#'#}
vor der öffnenden Klammer schreiben müssen: 
@code{'#} wird benötigt als Teil des Wertes, um einen Vektor zu
signalisieren, und das erste @code{#} wird benötigt, um
den Wert in einem @code{\override}-Befehl anzuführen.

@cindex Taktlinie, Beispiel zur Veränderung
@cindex break-visibility-Eigenschaft, Beispiel

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.BarLine #'break-visibility = #'#(#f #f #f)
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
Auch auf diesem Weg gelingt es, die Taktlinien unsichtbar zu machen.


@subheading transparent (durchsichtig)

@cindex transparent-Eigenschaft
@cindex Durchsichtig machen (transparent)

Aus den Eigenschaftsdefinitionen auf der @code{grob-interface}-Seite
in der IR geht hervor, dass die @code{transparent}-Eigenschaft
boolesch ist.  Mit @code{#t} (wahr) wird also ein Grob durchsichtig
gemacht.  Im unserem Beispiel soll jetzt die Taktart durchsichtig
gemacht werden, anstatt die Taktlinien durchsichtig zu machen.
Wir brauchen also wieder die Grob-Bezeichnung für die Taktart.
Auf der @qq{All layout objects}-Seite in der IR müssen wir die
Eigenschaften des @code{TimeSignature}-Layout-Objekts suchen
Das Objekt wird vom @code{Time_signature_engraver} erstellt,
der sich auch im @code{Staff}-Kontext befindet und genauso das
@code{grob-interface} unterstützt, wie Sie sich
überzeugen können.  Der Befehl, um die Taktangabe unsichtbar zu
machen, ist also:

@cindex Taktart, Beispiel zur Veränderung
@cindex transparent-Eigenschaft, Beispiel

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.TimeSignature #'transparent = ##t
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
Die Taktangabe ist verschwunden, aber mit diesem Befehl wird ein
freier Platz gelassen, wo sich die Taktangabe eigentlich befinden
würde.  Das braucht man vielleicht für eine Schulaufgabe, in der
die richtige Taktangabe eingefügt werden soll, aber in anderen
Fällen ist diese Lücke nicht schön.  Um auch die Lücke zu entfernen,
muss die Matrize (stencil) der Taktangabe auf @code{#f} (falsch)
gesetzt werden:

@cindex Taktart, Beispiel zur Veränderung
@cindex stencil-Eigenschaft, Beispiel

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.TimeSignature #'stencil = ##f
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
Und der Unterschied wird deutlich: hiermit wird das gesamte Objekt
entfernt, während man mit @code{transparent} ein Objekt
unsichtbar machen kann, es aber an seinem Platz gelassen wird.


@subheading color (Farbe)

@cindex color-Eigenschaft
@cindex Farb-Eigenschaft

Abschließend wollen wir die Taktlinien unsichtbar machen, indem
wir sie weiß einfärben.  (Es gibt hier eine Schwierigkeit: die weiße
Taktlinie übermalt manchmal die Taktlinienen, wo sie sie kreuzt, 
manchmal aber auch nicht.  Sie können in den Beispielen unten
sehen, dass das nicht vorhersagbar ist.  Die Einzelheiten dazu, warum
das passiert und wie sie es kontrollieren können, werden dargestellt
in @ruser{Objekte weiß malen}.  Im Moment wollen wir lernen, wie
man mit Farbe arbeitet, akzeptieren Sie bitte an dieser Stelle die
Beschränkung.)

Das @code{grob-interface} bestimmt, dass der Wert der Farb-Eigenschaft
eine Liste ist, aber es gibt keine Erklärung, was für eine Liste das
sein soll.  Die Liste, die benötigt wird, ist eine Liste mit Werten in
internen Einheiten, aber damit Sie nicht wissen müssen, wie diese
aussehen, gibt es mehrere Wege, Farben anzugeben.  Der erste
Weg ist es, @qq{normale} Farben zu benutzen, wie sie in der
Tabelle in @ruser{Liste der Farben} aufgelistet sind.  Beachten Sie,
dass die Bezeichnungen auf English sind.  Um die Taktlinien auf
weiß zu setzen, können Sie schreiben:

@cindex Taktlinie, Beispiel zur Veränderung
@cindex color-Eigenschaft, Beispiel

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.BarLine #'color = #white
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
und die Taktlinien verschwinden in der Tat.  Beachten Sie,
dass @emph{white} nicht mit einem Apostroph angeführt
wird -- es ist kein Symbol, sondern eine @emph{Funktion}.
Wenn sie aufgerufen wird, stellt sie eine Liste mit internen
Werten zu Verfügung, mit welcher die Farbe auf weiß
gestellt wird.  Die anderen Farben in der Liste sind auch
Funktionen.  Um sich zu überzeugen, dass der Befehl auch
wirklich funktioniert, können Sie die Farbe auf eine der
anderen Funktionen dieser Liste abändern.

@cindex Farben, X11
@cindex X11-Farben
@funindex x11-color

Die zweite Art die Farbe zu ändern geschieht, indem die Liste
der X11-Farbbezeichnungen einzusetzen, siehe die zweite Liste
in @ruser{Liste der Farben}.  Diesen Farben muss jedoch eine
andere Funktion vorangestellt werden, die die X11-Farbbezeichnungen
in interne Werte konvertiert: 
@code{x11-color}.  Das geschieht wie folgt:

@cindex Taktlinie, Beispiel zur Veränderung
@cindex color-Eigenschaft, Beispiel

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.BarLine #'color = #(x11-color 'white)
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
In diesem Fall hat die Funktion @code{x11-color} ein Symbol
als Argument, darum muss dem Symbol ein Apostroph vorangestellt
und beide zusammen in Klammern gesetzt werden.

@cindex RGB-Farben
@cindex Farben, RGB
@funindex rgb-color

Es gibt noch eine dritte Funktion, die RGB-Werte in die
internen Werte übersetzt -- die @code{rgb-color}-Funktion.  Sie
braucht drei Argumente, um die Stärke von Rot, Grün und
Blau darzustellen. Die Werte befinden sich zwischen 
0 und 1.  Um also die Farbe Rot darzustellen, muss der
Wert der Funktion lauten: @code{(rgb-color 1 0 0)}, weiß
würde sein: @code{(rgb-color 1 1 1)}.

@cindex Taktlinie, Beispiel zur Veränderung
@cindex color-Eigenschaft, Beispiel

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.BarLine #'color = #(rgb-color 1 1 1)
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

Schließlich gibt es noch eine Grauskala, die zu den X11-Farben
gehört.  Sie reicht von schwarz (@code{'grey0'}) bis
weiß (@code{'grey100}), in Einserschritten.  Wir wollen das
illustrieren, indem alle Layout-Objekte im Beispiel
verschiede Grauschattierungen erhalten:

@cindex StaffSymbol, Beispiel zur Veränderung
@cindex TimeSignature, Beispiel zur Veränderung
@cindex Schlüssel, Beispiel zur Veränderung
@cindex Notenhals, Beispiel zur Veränderung
@cindex Taktlinie, Beispiel zur Veränderung
@cindex Farbeigenschaft, Beispiel
@cindex x11-Farben, Beispiel
@cindex Taktlinien, Beispiel zur Veränderung
@cindex Taktart, Beispiel zur Veränderung
@cindex Clef, Beispiel zur Veränderung
@cindex Stem, Beispiel zur Veränderung
@cindex NoteHead, Beispiel zur Veränderung
@cindex Notenkopf, Beispiel zur Veränderung

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.StaffSymbol   #'color = #(x11-color 'grey30)
  \override Staff.TimeSignature #'color = #(x11-color 'grey60)
  \override Staff.Clef          #'color = #(x11-color 'grey60)
  \override Voice.NoteHead      #'color = #(x11-color 'grey85)
  \override Voice.Stem          #'color = #(x11-color 'grey85)
  \override Staff.BarLine       #'color = #(x11-color 'grey10)
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
Beachten Sie die Kontexte, die mit jedem einzelnen Layout-Objekt
verbunden sind.  Es ist wichtig, den richtigen Kontext einzusetzen,
damit die Befehle funktionieren.  Denken Sie daran, dass der 
Kontext sich daran orientiert, wo sich der entsprechende
Engraver befindet.  Den Standardkontext für Engraver finden
Sie, indem Sie beim Layout-Objekt beginnen, zum Engraver
gehen, der es produziert und auf der Seite des Engravers in der
IR finden Sie Information, in welchem Kontext sich der
Engraver normalerweise befindet.


@node Größe von Objekten
@subsection Größe von Objekten
@translationof Size of objects

@cindex Veränderung von Objektgrößen
@cindex Objektgrößen, verändern
@cindex Größen von Objekten verändern

Als Startpunkt wollen wir wieder ein früheres Beispiel
wählen, siehe @ref{Musikalische Ausdrücke ineinander verschachteln}. Hier wurde
ein neues Notensystem erstellt, wie man es für ein @rglos{ossia}
braucht.

@cindex alignAboveContext-Eigenschaft, Beispiel
@cindex über dem System anordnen, Beispiel
@cindex @code{\with}-Beispiel

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\new Staff ="main" {
       \relative g' {
         r4 g8 g c4 c8 d |
         e4 r8
         <<
           { f c c }
           \new Staff \with {
             alignAboveContext = #"main" }
           { f8 f c }
         >>
         r4 |
       }
     }
@end lilypond

Ossia-Systeme werden normalerweise ohne Schlüssel und Taktangabe
geschrieben, und sie werden etwas kleiner als das Hauptsystem gesetzt.
Wie man Schlüssel und Taktangabe entfernt, wissen wir schon:
wir setzen den Stencil von beiden auf @code{#f}:

@cindex alignAboveContext-Eigenschaft, Beispiel
@cindex über dem System anordnen, Beispiel
@cindex @code{\with}-Beispiel
@cindex stencil-Eigenschaft, Beispiel
@cindex Schlüssel, Beispiel zur Veränderung
@cindex Taktart, Beispiel zur Veränderung

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\new Staff ="main" {
  \relative g' {
    r4 g8 g c4 c8 d |
    e4 r8
    <<
      { f c c }
      \new Staff \with {
        alignAboveContext = #"main"
      }
      {
        \override Staff.Clef #'stencil = ##f
        \override Staff.TimeSignature #'stencil = ##f
        { f8 f c }
      }
    >>
    r4 |
  }
}
@end lilypond

@noindent
wobei ein zusätzliches Klammerpaar nach der @code{\with}-Konstruktion
erforderlich ist um sicherzugehen, dass die Modifikation und 
die Noten sich auch auf das Ossia-System beziehen.

Was für einen Unterschied macht es, ob man den @code{Staff}-Kontext
mit @code{\with} verändert, oder ob man die Stencils mit 
@code{\override} beeinflusst?  Der größte Unterschied liegt
darin, dass Änderungen, die mit @code{\with} eingeführt werden,
während der Erstellung des Kontextes miterzeugt werden und
als @strong{Standardeinstellungen} für diesen Kontext während seiner
gesamten Dauer gelten, während @code{\set}- oder @code{\override}-Befehle
dynamisch in die Noten eingebettet werden -- sie führen die
Änderungen synchron mit einem bestimmten Zeitpunkt in 
der Musik aus.  Wenn die Änderungen mit  @code{\unset}
oder @code{\revert} rückgängig gemacht werden, werden
wieder die Standardwerte eingesetzt, die also die sind, die
mit einer @code{\with}-Konstruktion definiert wurden, oder
wenn hier keine definiert worden sind, die normalen
Standardwerte.

Manche Kontexteigenschaften können nur ein einer
@code{\with}-Konstruktion verändert werden.  Das sind
Eigenschaften, die nicht sinnvoll mitten im System geändert
werden können.  @code{alignAboveContext} (Orientierung
über dem Kontext) und die Parallele,
@code{alignBelowContext} (Orientierung unter dem Kontext)
sind zwei derartige Eigenschaften -- wenn das Notensystem
einmal erstellt wurde, ist die Orientierung schon bestimmt
und es wäre nicht sinnvoll, sie später zu ändern.

Die Standardwerte für Layout-Objekt-Eigenschaften können
auch in der @code{\with}-Konstruktion gesetzt werden.
Benutzen Sie einfach den normalen @code{\override}-Befehl
ohne den Kontext, denn der Kontext ist eindeutig definiert
durch die Stelle, an welcher sich @code{\with} befindet.
Wenn an dieser Stelle ein Kontext angegeben wird, produziert LilyPond
eine Fehlermeldung.

Das obige Beispiel könnte also auch so aussehen:

@cindex alignAboveContext-Eigenschaft, Beispiel
@cindex über dem System anordnen, Beispiel
@cindex @code{\with}-Beispiel
@cindex stencil-Eigenschaft, Beispiel
@cindex Schlüssel, Beispiel zur Veränderung
@cindex Taktart, Beispiel zur Veränderung

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\new Staff ="main" {
  \relative g' {
    r4 g8 g c4 c8 d |
    e4 r8
    <<
      { f c c }
      \new Staff \with {
        alignAboveContext = #"main"
        % Don't print clefs in this staff
        \override Clef #'stencil = ##f
        % Don't print time signatures in this staff
        \override TimeSignature #'stencil = ##f
      }
        { f8 f c }
    >>
    r4 |
  }
}
@end lilypond

Nun können wir daran gehen, auch wirklich die
Größe der Objekte zu ändern.

Manche Layout-Objekte werden aus Glyphen erstellt,
die sich in einer Schriftartdatei befinden.  Dazu gehören
die Notenköpfe, Versetzungszeichen, Text, Schlüssel,
Taktbezeichnung, Dynamik und Gesangstext.  Ihre
Größe wird verändert, indem die
@code{font-size}- (Schriftgröße)-Eigenschaft geändert wird, wie
wir bald sehen werden.  Andere Layout-Objekte, wie
Bögen -- oder allgemein Strecker-Objekte -- werden
individuell gezeichnet, es gibt dazu also keine 
@code{font-size}, die mit ihnen verknüpft wäre.
Weitere Eigenschaften wie die Länge von Hälsen und
Taktlinien, Dicke von Balken und anderen Linien und 
der Abstand der Notenlinien voneinander müssen auf
spezielle Weise verändert werden.

In unserem Ossia-Beispiel wollen wir zuerst die
Schriftgröße verändern.  Das ist auf zwei Arten möglich. 
Entweder wir ändern die Schriftgröße für jede Objektart
mit einem eigenen Befehl, etwa:

@example
\override NoteHead #'font-size = #-2
@end example

@noindent
oder wir ändern die Größe aller Schriftobjekte, indem wir
den Wert einer besonderen Eigenschaft, @code{fontSize},
mit dem @code{\set}-Befehl bestimmen oder sie in 
eine @code{\with}-Konstruktion (ohne @code{\set} einschließen.

@example
\set fontSize = #-2
@end example

Beide Beispiele reduzieren die Schriftgröße um zwei Schritte
im Vergleich zum vorigen Wert, wobei jeder Schritt die
Schriftgröße um etwa 12% verändert.

Setzen wir das also in unserem Ossia-Beispiel ein:

@cindex alignAboveContext-Eigenschaft, Beispiel
@cindex über dem System anordnen, Beispiel
@cindex @code{\with}-Beispiel
@cindex stencil-Eigenschaft, Beispiel
@cindex Schlüssel, Beispiel zur Veränderung
@cindex Taktart, Beispiel zur Veränderung

@lilypond[quote,verbatim,fragment,ragged-right,relative=2]
\new Staff ="main" {
  \relative g' {
    r4 g8 g c4 c8 d |
    e4 r8
    <<
      { f c c }
      \new Staff \with {
        alignAboveContext = #"main"
        \override Clef #'stencil = ##f
        \override TimeSignature #'stencil = ##f
        % Reduce all font sizes by ~24%
        fontSize = #-2
      }
        { f8 f c }
    >>
    r4 |
  }
}
@end lilypond

Das sieht aber immer noch nicht richtig aus.  Die Notenköpfe
und Fähnchen sind kleiner, aber die Hälse im Vergleich
dazu zu lang und die Notenlinien zu weit auseinander.
Sie müssen auch proportional zur Schriftart verkleinert
werden.  Der nächste Abschnitt behandelt diese Anpassung.


@node Länge und Dicke von Objekten
@subsection Länge und Dicke von Objekten
@translationof Length and thickness of objects

@cindex Entfernungen
@cindex Dicke
@cindex Länge
@funindex magstep
@cindex Größe, verändern
@cindex Notenhalslänge, verändern
@cindex Hälse, Länge verändern
@cindex Notenlinien, Länge verändern

Abstände und Längen werden in LilyPond üblicherweise
in Notenlinienabständen (engl. staff-spaces) gemessen. 
Das ist der Abstand zwischen zwei Notenlinien im System.
Die meisten Dicken (engl. thickness) dagegen werden in
einer internen Einheit Linien-Dicke (engl. line-thickness)
gemessen.  Die Linien von Dynamikklammern zum Beispiel
haben standardmäßig eine Dicke von einer Einheit
@code{line-thickness}, während die Dicke eines
Notenhalses 1,3 ist.  Beachten Sie jedoch, dass sich
manche Dicken anders verhalten: die Dicke von
Balken etwa wird in Notenlinienabständen gemessen.

Wie also werden Längen skaliert um der Schriftgröße
zu entsprechen?  Das kann mit einer besonderen Funktion
@code{magstep} vorgenommen werden, die genau für
diesen Zweck vorhanden ist.  Sie nimmt ein Argument auf,
die Änderung der Schriftgröße (#-2 im obigen Beispiel)
und gibt einen Skalierungsfaktor aus, der dazu dient,
Objekte proportionell zueinander zu verändern.  So wird
sie benutzt:

@cindex alignAboveContext-Eigenschaft, Beispiel
@cindex über dem System anordnen, Beispiel
@cindex @code{\with}-Beispiel
@cindex stencil-Eigenschaft, Beispiel
@cindex Schlüssel, Beispiel zur Veränderung
@cindex Taktart, Beispiel zur Veränderung
@cindex Notenlinienabstände verändern
@cindex staff-space-Eigenschaft verändern
@cindex magstep-Funktion, Beispiel
@cindex Schriftart-Eigenschaft, Beispiel

@lilypond[quote,verbatim,fragment,ragged-right,relative=2]
\new Staff ="main" {
  \relative g' {
    r4 g8 g c4 c8 d |
    e4 r8
    <<
      { f c c }
      \new Staff \with {
        alignAboveContext = #"main"
        \override Clef #'stencil = ##f
        \override TimeSignature #'stencil = ##f
        fontSize = #-2
        % Reduce stem length and line spacing to match
        \override StaffSymbol #'staff-space = #(magstep -2)
      }
        { f8 f c }
    >>
    r4 |
  }
}
@end lilypond

@noindent
Da die Länge eines Halses und viele andere Längeneigenschaften
relativ zum Wert des Notenlinienabstands (@code{staff-space})
errechnet werden, werden sie auch automatisch verkleinert.
Das wirkt sich jedoch nur auf die vertikale Skalierung des Ossias
aus -- die horizontale Skala ist durch das Layout des Haupsystems
bestimmt und wird also von diesen Größenänderungen nicht
betroffen.  Wenn natürlich die Größe der gesamten Noten reduziert
würde, würde sich auch die horizontalen Abstände ändern.  Dass
wird später im Layout-Abschnitt betrachtet.

Mit dieser Änderung ist unser Ossia fertig.  Die Größen und Längen
aller anderen Objekte können auf analoge Weise geändert
werden.

Für kleine Größenänderungen, wie in dem obigen Beispiel,
braucht die Dicke der verschiedenen Linien, wie Taktlinien,
Notenlinien, Balken, Dynamikklammern usw. normalerweise
keine spezielle Anpassung.  Wenn die Dicke eines bestimmten
Layout-Objektes angepasst werden muss, kann man das erreichen,
indem die entsprechende @code{thickness}-Eigenschaft des
Objekts mit @code{\override} verändert wird.  Ein Beispiel,
wie man die Dicke von Bögen ändert, wurde schon gezeigt,
siehe @ref{Eigenschaften von Layoutobjekten}.  Die Dicke aller
gezeichneten Objekte (die also nicht aus einer Schriftart 
stammen) können auf gleiche Weise geändert werden.


@node Positionierung von Objekten
@section Positionierung von Objekten
@translationof Placement of objects

@menu
* Automatisches Verhalten::
* within-staff (Objekte innerhalb des Notensystems)::
* Objekte außerhalb des Notensystems::
@end menu


@node Automatisches Verhalten
@subsection Automatisches Verhalten
@translationof Automatic behavior

@cindex within-staff-Objekte
@cindex outside-staff-Objekte
@cindex Objekte innerhalb des Notensystems
@cindex Objekte außerhalb des Notensystems

Es gibt Objekte der Notation, die zum Notensystem gehören, und
andere, die außerhalb des Systems gesetzt werden müssen.  Sie
werden @code{within-staff}-Objekte bzw.
@code{outside-staff}-Objekte genannt.

@code{within-staff}-Objekte werden innerhalb des Notensystems
(engl. staff) gesetzt: Notenköpfe, Hälse, Versetzungszeichen
usw.  Ihre Position ist üblicherweise durch die notierte Musik
bestimmt -- sie werden vertikal auf bestimmten Linien notiert
oder sind an andere Objekte gebunden, die vertikal festgelegt
sind.  Kollisionen von Notenköpfen, Hälsen und Versetzungszeichen
werden normalerweise automatisch vermieden.  Es gibt 
Befehle, um dieses automatische Verhalten zu verändern, wie
unten gezeigt werden soll.

Objekte, die außerhalb des Notensystems gesetzt werden, sind
unter Anderem Übungsmarkierungen, Text und Dynamikzeichen.
LilyPonds Regel für ihre vertikale Positionierung lautet, sie so nah wie
möglich am Notensystem zu setzen, aber nicht so nah, dass
sie mit anderen Objekten kollidieren.  Dabei wird die
@code{outside-staff-priority}-(Priorität außerhalb des Notensystems)-Eigenschaft
eingesetzt, um die Reihenfolge zu bestimmen, in denen Objekte gesetzt werden 
sollen.

Zuerst werden alle Innersystemobjekte von LilyPond gesetzt.
Dann werden die Objekte außerhalb des Systems nach
ihrer 
@code{outside-staff-priority} geordnet.  Die @code{outside-staff}-Objekte
werden dann nacheinander gesetzt, mit der niedrigsten
Priorität beginnend, und so gesetzt, dass sie nicht mit anderen
Objekten kollidieren, die schon gesetzt wurden.  Wenn also zwei
@code{outside-staff}-Objekte um den selben Platz streiten,
wird das mit der geringeren @code{outside-staff-priority} näher
am System gesetzt werden.  Wenn zwei Objekte die selbe Priorität
haben, wird das näher am System gesetzt, welches zuerst
auftritt.

Im folgenden Beispiel haben alle Textbeschriftungen die gleiche
Priorität (weil sie nicht explizit gesetzt worden ist).  Beachten Sie,
dass @qq{Text3} wieder dicht am System gesetzt wurde, weil
er unter @qq{Text2} passt.

@cindex Textbeschriftungsbeispiel

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
c2^"Text1"
c^"Text2"
c^"Text3"
c^"Text4"
@end lilypond

Notensysteme werden in den Standardeinstellungen auch so dicht
beeinander gesetzt wie es möglich ist (mit einem minimalen Abstand).
Wenn Noten sehr weit aus einem System herausragen, zwingen sie
das nächste System weiter weg, wenn eine Kollision drohen würde.
Im nächsten Beispiel sehen Sie, wie Noten auf zwei Systemen
@qq{ineinander greifen}.

@lilypond[quote,ragged-right,verbatim]
<<
  \new Staff {
    \relative c' { c a, }
  }
  \new Staff {
    \relative c'''' { c a, }
  }
>>
@end lilypond


@node within-staff (Objekte innerhalb des Notensystems)
@subsection within-staff (Objekte innerhalb des Notensystems)
@translationof Within-staff objects

Es wurde schon gezeigt, wie die Befehle @code{\voiceXXX} die Richtung
von Bögen, Fingersatz und allen anderen Objekten beeinflusst,
die von der Richtung der Notenhälsen abhängen.  Diese Befehle
sind nötig, wenn polyphone Musik geschrieben wird, damit sich 
die einzelnen Melodielinien klar abzeichnen.  Es kann aber von Zeit
zu Zeit nötig sein, dieses automatische Verhalten zu verändern.  Das
kann entweder für ganze Abschnitte, aber genauso auch nur für eine
einzelne Note vorgenommen werden.  Die Eigenschaft, die die Richtung
bestimmt, ist die @code{direction}-Eigenschaft jedes Layout-Objekts.
Es soll erst erklärt werden, was sie bewirkt und dann eine Anzahl
an fertigen Befehlen für die üblicheren Situationen präsentiert werden,
mit denen Sie gleich loslegen können.

Manche Layout-Objekte, wie Legato- und Bindebögen, biegen sich
oder zeigen entweder nach oben oder nach unten, andere, wie
Hälse und Fähnchen, verändern auch die Position rechts oder links,
je nach der Richtung, in die sie zeigen.  Das wird automatisch 
berücksichtigt, wenn die @code{direction}-Eigenschaft verändert
wird.

@funindex down
@funindex up
@funindex center
@funindex neutral
@cindex hoch-Eigenschaft
@cindex runter-Eigenschaft
@cindex zentriert-Eigenschaft
@cindex neutral-Eigenschaft

Das folgende Beispiel zeigt im ersten Takt die Standardeinstellung
für Hälse, die bei hohen Noten nach unten zeigen und bei tiefen
noten nach oben. Im nächsten Takt werden alle Hälse nach unten
gezwungen, im dritten Takt nach oben, und im vierten wird wieder
der Standard eingestellt.

@cindex Notenhals, Beispiel zur Veränderung
@cindex Richtungseigenschaft, Beispiel

@lilypond[quote,verbatim,relative=2]
a4 g c a
\override Stem #'direction = #DOWN
a g c a
\override Stem #'direction = #UP
a g c a
\revert Stem #'direction
a g c a
@end lilypond

Hier werden die Konstanten @code{DOWN} und @code{UP}
eingesetzt.  Sie haben die Werte @code{-1} bwz. @code{+1}, und
diese numerischen Werte können ebenso benutzt werden.  Auch
der Wert @code{0} kann in manchen Fällen benutzt werden.  Er
bedeutet für die Hälse das gleiche wie @code{UP}, für einige
andere Objekte jedoch @qq{zentiert}.  Es gibt hierzu die Konstante
@code{CENTER}, die den Wert @code{0} hat.

Es gibt aber einfachere Befehle, die normalerweise benutzt werden.
Hier eine Tabelle der häufigsten.  Die Bedeutung des Befehls wird
erklärt, wenn sie nicht selbsverständlich ist.

@multitable @columnfractions .2 .2 .25 .35
@headitem Runter/Links
  @tab Rauf/Rechts
  @tab Rückgängig
  @tab Wirkung
@item @code{\arpeggioArrowDown}
  @tab @code{\arpeggioArrowUp}
  @tab @code{\arpeggioNormal}
  @tab Arpeggio mit Pfeil nach unten, oben oder ohne Pfeil
@item @code{\dotsDown}
  @tab @code{\dotsUp}
  @tab @code{\dotsNeutral}
  @tab Richtung der Verschiebung eines Punktes, um Notenlinien zu vermeiden
@item @code{\dynamicDown}
  @tab @code{\dynamicUp}
  @tab @code{\dynamicNeutral}
  @tab Position der Dynamik-Bezeichnung relativ zum System
@item @code{\phrasingSlurDown}
  @tab @code{\phrasingSlurUp}
  @tab @code{\phrasingSlurNeutral}
  @tab Befehl für Richtung von Phrasierungsbögen
@item @code{\slurDown}
  @tab @code{\slurUp}
  @tab @code{\slurNeutral}
  @tab Befehl für Richtung von Legatobögen
@item @code{\stemDown}
  @tab @code{\stemUp}
  @tab @code{\stemNeutral}
  @tab Befehl für Richtung von Hälsen
@item @code{\textSpannerDown}
  @tab @code{\textSpannerUp}
  @tab @code{\textSpannerNeutral}
  @tab Position von Textbeschrifungen, die als Strecker eingegeben werden
@item @code{\tieDown}
  @tab @code{\tieUp}
  @tab @code{\tieNeutral}
  @tab Befehl für Richtung von Bindebögen
@item @code{\tupletDown}
  @tab @code{\tupletUp}
  @tab @code{\tupletNeutral}
  @tab Befehl für Richtung von Klammern/Zahlen der N-tolen
@end multitable

Diese vordefinierten Befehl können allerdings @strong{nicht}
zusammen mit @code{\once} benutzt werden.  Wenn Sie die
Wirkung eines Befehl auf eine einzige Noten begrenzen wollen,
müssen Sie den entsprechenden
@code{\once \override}-Befehl benutzen oder den definierten
Befehl, gefolgt von dem entsprechenden neutralisierenden
@code{xxxNeutral}-Befehl nach der Note.


@subheading Fingersatz

@cindex Fingersatz, Positionierung
@cindex Fingersatz, Akkorde

Die Positionierung von Fingersatz kann auch durch den Wert
seiner @code{direction}-Eigenschaft beeinflusst werden, aber
eine Veränderung von  @code{direction} hat keinen Einfluss auf
Akkorde. es gibt auch hier
besondere Befehle, mit denen der Fingersatz von einzelnen
Noten in Akkorden kontrolliert werden kann, wobei mögliche
Positionen über, unter der Note und rechts bzw. links von
ihr sind.

Zunächst die Wirkungsweise von @code{direction} auf
den Fingersatz: im ersten Takt der Standard, dann
die Wirkung von @code{DOWN} (runter) und @code{UP}
(hinauf).

@cindex Fingersatz, Beispiel zur Veränderung
@cindex direction-Eigenschaft, Beispiel

@lilypond[quote,verbatim,relative=2]
c-5 a-3 f-1 c'-5
\override Fingering #'direction = #DOWN
c-5 a-3 f-1 c'-5
\override Fingering #'direction = #UP
c-5 a-3 f-1 c'-5
@end lilypond

Eine Beeinflussung der @code{direction}-Eigenschaft ist jedoch 
nicht die einfachste Art, Fingersatzbezeichnungen manuell über oder
unter das System zu setzen.  Normalerweise bietet es sich an,
@code{_} oder @code{^} anstelle von @code{-} vor der Fingersatz-Zahl
zu benutzen.  Hier das vorherigen Beispiel mit dieser Methode:

@cindex Fingersatz-Beispiel

@lilypond[quote,verbatim,relative=2]
c-5 a-3 f-1 c'-5
c_5 a_3 f_1 c'_5
c^5 a^3 f^1 c'^5
@end lilypond

Die @code{direction}-Eigenschaft wirkt sich nicht auf
Akkorde aus, während die Präfixe @code{_} und @code{^} funktionieren.
Standardmäßig wird der Fingersatz automatisch entweder
über oder unter dem Akkord gesetzt:

@cindex Fingersatz-Beispiel

@lilypond[quote,verbatim,relative=2]
<c-5 g-3>
<c-5 g-3 e-2>
<c-5 g-3 e-2 c-1>
@end lilypond

@noindent
aber das kann manuell geändert werden, um einzelne Fingersatzanweisungen
nach oben oder unten zu zwingen:

@cindex Fingersatz-Beispiel

@lilypond[quote,verbatim,relative=2]
<c-5 g-3 e-2 c-1>
<c^5 g_3 e_2 c_1>
<c^5 g^3 e^2 c_1>
@end lilypond

Noch bessere Kontrolle über die Positionierung von Fingersatz für
einzelne Noten in einem Akkord ist mit dem
@code{\set fingeringOrientations}-Befehl möglich.  Die Syntax
lautet:

@example
@code{\set fingeringOrientations = #'([up] [left/right] [down])}
@end example

@noindent
@code{\set}wird benutzt, weil @code{fingeringOrientations} eine
Eigenschaft des @code{Voice}-Kontextes ist, erstellt und eingesetzt
vom @code{New_fingering_engraver}.

Die Eigenschaft kann als Wert eine Liste mit einem bis drei Einträgen
haben.  Damit wird bestimmt, ob Fingersatz oberhalb gesetzt
werden kann (wenn @code{up} in der Liste auftaucht), darunter
(wenn@code{down} auftaucht), links (wenn @code{left} auftaucht)
oder rechts (wenn @code{right} auftaucht).  Wenn andererseits
ein Wert nicht auftaucht, wir auch kein Fingersatz in dieser Richtung
gesetzt.  LilyPond nimmt diese Beschränkung als Bedingung und
errechnet die besten Positionen für die Noten des nächsten Akkordes.
Die seitliche Positionierung kann nur auf einer Seite des Akkordes
geschehen, nicht auf beiden gleichzeitig, es kann also nur entweder
@code{left} oder @code{right} auftreten, nicth beide gleichzeitig.

@warning{Damit eine einzelne Note mit diesem Befehl beeinflusst werden
kann, muss sie als ein @qq{Ein-Noten-Akkord} geschrieben
werden, indem einfache spitze Klammern um die Note positioniert
werden.}

Hier ein paar Beispiele:

@cindex Fingersatz-Beispiel
@cindex @code{\set}, Benutzungsbeispiel
@cindex fingerOrientations-Eigenschaft, Beispiel

@lilypond[quote,verbatim,relative=1]
\set fingeringOrientations = #'(left)
<f-2>
< c-1  e-2 g-3 b-5 > 4
\set fingeringOrientations = #'(left)
<f-2>
< c-1  e-2 g-3 b-5 > 4
\set fingeringOrientations = #'(up left down)
<f-2>
< c-1  e-2 g-3 b-5 > 4
\set fingeringOrientations = #'(up left)
<f-2>
< c-1  e-2 g-3 b-5 > 4
\set fingeringOrientations = #'(right)
<f-2>
< c-1  e-2 g-3 b-5 > 4
@end lilypond

@noindent
Wenn die Fingersatzbezeichnung zu gedrungen aussieht,
kann auch die Schriftgröße (@code{font-size}) verringert
werden.  Der Standardwert kann aus dem
@code{Fingering}-Objekt in der IR entnommen werden,
er ist @code{-5}, versuchen wir es also mit @code{-7}.

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
\override Fingering #'font-size = #-7
\set fingeringOrientations = #'(left)
<f-2>
< c-1  e-2 g-3 b-5 > 4
\set fingeringOrientations = #'(left)
<f-2>
< c-1  e-2 g-3 b-5 > 4
\set fingeringOrientations = #'(up left down)
<f-2>
< c-1  e-2 g-3 b-5 > 4
\set fingeringOrientations = #'(up left)
<f-2>
< c-1  e-2 g-3 b-5 > 4
\set fingeringOrientations = #'(right)
<f-2>
< c-1  e-2 g-3 b-5 > 4
@end lilypond



@node Objekte außerhalb des Notensystems
@subsection Objekte außerhalb des Notensystems
@translationof Outside-staff objects

Objekte außerhalb des Notensystems werden automatisch gesetzt,
um Kollisionen zu vermeiden.  Objekten mit einem geringeren
Prioritätswert der Eigenschaft @code{outside-staff-priority}
werden näher an das System gesetzt, und andere Objekte außerhalb
des Systems werden dann soweit vom System entfernt gesetzt, dass
Zusammenstöße vermieden werden.  Die
@code{outside-staff-priority}-Eigenschaft ist im
@code{grob-interface} definiert und ist also eine Eigenschaft
von allen Layout-Objekten.  Standardmäßig ist sie für alle Objekte
auf falsch (@code{#f}) gesetzt; dieser Wert wird in einen numerischen
Wert dem Objekt entsprechend geändert, wenn das Objekt für die
Notenausgabe erstellt wird.  Die Tabelle unten zeigt die 
Standardwerte für die meistbenutzten @code{outside-staff}-Objekte,
die den Voreinstellungen nach im
@code{Staff}- oder @code{Voice}-Kontext gesetzt werden.

@multitable @columnfractions .3 .3 .3
@headitem Layout-Objekt        
  @tab Priorität
  @tab Kontrolliert Position von:
@item @code{MultiMeasureRestText}
  @tab @code{450}
  @tab Text über Ganztaktpausen
@item @code{TextScript}
  @tab @code{450}
  @tab Textbeschriftung
@item @code{OttavaBracket}
  @tab @code{400}
  @tab Ottava (Oktavierungsklammern)
@item @code{TextSpanner}
  @tab @code{350}
  @tab Text-Strecker
@item @code{DynamicLineSpanner}
  @tab @code{250}
  @tab Alle Dynamik-Bezeichnungen
@item @code{VoltaBracketSpanner}
  @tab @code{100}
  @tab Volta-Klammern
@item @code{TrillSpanner}
  @tab @code{50}
  @tab Triller-Strecker
@end multitable

Hier ein Beispiel, das die Standardpositionierung von einigen
Objekten zeigt.

@cindex Text-Strecker
@cindex Text-Spanner
@funindex \startTextSpan
@funindex \stopTextSpan
@funindex startTextSpan
@funindex stopTextSpan
@cindex Ottava-Klammer
@cindex Oktavierungsklammer

@cindex TextSpanner, Beispiel zur Veränderung
@cindex bound-details-Eigenschaft, Beispiel

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
% Set details for later Text Spanner
\override TextSpanner #'(bound-details left text)
    = \markup { \small \bold Slower }
% Place dynamics above staff
\dynamicUp
% Start Ottava Bracket
\ottava #1
c' \startTextSpan
% Add Dynamic Text
c\pp
% Add Dynamic Line Spanner
c\<
% Add Text Script
c^Text
c c
% Add Dynamic Text
c\ff c \stopTextSpan
% Stop Ottava Bracket
\ottava #0
c, c c c
@end lilypond

Dieses Beispiel zeigt auch, wie man Text-Strecker erstellt, d.h.
Text mit Bindestrichen, der sich über eine bestimmte Länge
erstreckt.  Der Strecker beginnt mit dem
@code{\startTextSpan}-Befehl und endet mit dem
@code{\stopTextSpan}-Befehl, und das Format des Textes
wird mit dem @code{\override TextSpanner}-Befehl bestimmt.
Mehr Einzelheiten siehe @ruser{Text mit Verbindungslinien}.

Im Beispiel wird auch gezeigt, wie Oktavierungsklammern
(Ottava) erstellt werden.

@cindex Taktzahlposition verändern
@cindex Verändern der Taktzahlposition
@cindex Position der Taktzahl, verändern
@cindex Metronom-Bezeichnungsposition verändern
@cindex Verändern der Metronom-Bezeichnungsposition
@cindex Übungszeichenposition verändern
@cindex Verändern der Übungszeichenposition

Beachten Sie, dass Taktnummern, Metronombezeichnungen
und Übungszeichen nicht gezeigt werden.  Sie werden
standardmäßig im @code{Score}-(Partitur)-Kontext
erstellt und ihre @code{outside-staff-priority} wird
in Bezug auf die Layout-Objekte, die im @code{Staff}-Kontext
erstellt werden, ignoriert.  Wenn Sie Taktnummern,
Metronombezeichnungen oder Übungszeichen entsprechend
ihrer Außersystem-Priorität setzen wollen, müssen Sie
die entsprechenden Engraver (@code{Bar_number_engraver},
@code{Metronome_mark_engraver} oder @code{Mark_engraver})
vom @code{Score}-Kontext entfernen und dem
@code{Staff}-Kontext hinzufügen.  Wenn die Engraver so
geändert werden, erhalten sie folgenden Werte für
@code{outside-staff-priority}:

@multitable @columnfractions .3 .3
@headitem Layout-Objekt           @tab Priorität
@item @code{RehearsalMark}        @tab @code{1500}
@item @code{MetronomeMark}        @tab @code{1000}
@item @code{BarNumber}            @tab @code{ 100}
@end multitable

Wenn die Standardwerte der @code{outside-staff-priority} nicht
die Positionierung hervorrufen, die Sie wünschen, kann die
Priorität eines jeden Objektes geändert werden.  Als Beispiel
wollen wir zeigen, wie sich die Oktavierungsklammer unter
den Textstrecker des vorigen Beispiels setzen lässt.  Wir müssen
nur die Priorität des
@code{OttavaBracket}-Objektes in der IR oder der Tabelle oben
herausfinden und einen kleineren Wert angeben als der Wert, den
das @code{TextSpanner}-(Strecker)-Objekt bekommt, wobei noch daran
zu denken ist, dass @code{OttavaBracket} im @code{Staff}-Kontext
erstellt wird:

@cindex TextSpanner, Beispiel zur Veränderung
@cindex bound-details-Eigenschaft, Beispiel

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
% Set details for later Text Spanner
\override TextSpanner #'(bound-details left text)
    = \markup { \small \bold Slower }
% Place dynamics above staff
\dynamicUp
%Place following Ottava Bracket below Text Spanners
\once \override Staff.OttavaBracket #'outside-staff-priority = #340
% Start Ottava Bracket
\ottava #1
c' \startTextSpan
% Add Dynamic Text
c\pp
% Add Dynamic Line Spanner
c\<
% Add Text Script
c^Text
c c
% Add Dynamic Text
c\ff c \stopTextSpan
% Stop Ottava Bracket
\ottava #0
c, c c c
@end lilypond

@cindex Legatobögen und outside-staff-priority
@cindex Legatobögen und Artikulationszeichen
@cindex Artikulationszeichen und Legatobögen

Legatobögen werden als Innersystem-Objekte klassifiziert, aber
sie erscheinen oft auch über dem System, wenn die Noten, an die
sie verbunden sind, sehr hoch im System notiert sind.  Dadurch
können Außersystem-Objekte, wie Artikulationszeichen, zu hoch
gerückt werden.  Die @code{avoid-slur}-Eigenschaft hat nur
eine Auswirkung, wenn auch die @code{outside-staff-priority}
auf @code{#f} gesetzt ist.  Alternativ kann die
@code{outside-staff-priority}  des Legatobogens auf einen
numerischen Wert gesetzt werden, sodass er mit anderen
Außersystem-Objekten anhand dieses Wertes gesetzt wird.
Hier ein Beispiel, das die beiden Möglichkeiten veranschaulicht:

@lilypond[quote,verbatim,relative=2]
c4( c^\markup\tiny\sharp d4.) c8
c4(
\once \override TextScript #'avoid-slur = #'inside
\once \override TextScript #'outside-staff-priority = ##f
c^\markup\tiny\sharp d4.) c8
\once \override Slur #'outside-staff-priority = #500
c4( c^\markup\tiny\sharp d4.) c8
@end lilypond

Eine Änderung der @code{outside-staff-priority} kann auch dazu
benutzt werden, die vertikale Plazierung von individuellen Objekten
zu kontrollieren, auch wenn das Ergebnis nicht immer optimal
ist.  Im nächsten Beispiel soll @qq{Text3} oberhalb von @qq{Text4}
gesetzt werden, das Beispiel wurde behandelt in
@ref{Automatisches Verhalten}.  Der Wert der Priorität muss also für
die Eigenschaft @code{TextScript} entweder in der IR oder in der
Tabelle oben festgestellt werden und dann die Priorität für
@qq{Text3} höher eingestellt werden:

@cindex TextScript, Beispiel zur Veränderung
@cindex outside-staff-priority-Eigenschaft, Beispiel

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
c2^"Text1"
c^"Text2"
\once \override TextScript #'outside-staff-priority = #500
c^"Text3"
c^"Text4"
@end lilypond

Damit wird zwar @qq{Text3} ganz richtig über @qq{Text4}
platziert, aber auch über @qq{Text2}, und @qq{Text4}
wird jetzt weiter unten gesetzt.  Eigentlich sollten ja alle
diese Anmerkungen gleichweit vom System entfernt sein.
Dazu muss offensichtlich horizontal etwas Platz gemacht
werden.  Das kann erreicht werden mit dem
@code{textLengthOn}-(Textlänge an)-Befehl.

@subheading \textLengthOn (Textlänge berücksichtigen)

@cindex Noten, durch Text gespreizt
@funindex \textLengthOn
@funindex textLengthOn
@funindex \textLengthOff
@funindex textLengthOff

Standardmäßig wird Text, der mit dem Beschriftungsbefehl
@code{\markup} bzw. Äquivalenten erstellt wird, kein
zusätzlicher Platz in Bezug auf die Positionierung der Noten
zugestanden.  Der @code{\textLengthOn}-Befehl ändert
dieses Verhalten, so dass die Noten gespreizt werden, wenn
die Breite des Textes es erfordert:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\textLengthOn  % Cause notes to space out to accommodate text
c2^"Text1"
c^"Text2"
c^"Text3"
c^"Text4"
@end lilypond

Dieses Verhalten wird mit dem @code{\textLengthOff}-Befehl 
rückgängig gemacht.  Erinnern Sie sich, dass @code{\once} nur mit
@code{\override}, @code{\set}, @code{\revert} oder @code{unset}
funktioniert, der Befehl kann also nicht zusammen mit
@code{\textLengthOn} benutzt werden.

@cindex Textbeschriftung, Vermeidung von Zusammenstößen
@cindex Zusammenstöße vermeiden mit Textbeschriftung

Textbeschriftung vermeidet auch Noten, die über das System hinausstehen.
Wenn das nicht gewünscht ist, kann die automatische Verschiebung
nach oben hin auch vollständig ausgeschaltet werden, indem die
Priorität auf @code{#f} gesetzt wird.  Hier ein Beispiel, wie
eine Textbeschriftung mit diesen Noten reagiert:

@cindex Textbeschriftung, Beispiel zur Veränderung
@cindex outside-staff-priority-Eigenschaft, Beispiel

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
% This markup is short enough to fit without collision
c2^"Tex"
c''2
R1
% This is too long to fit, so it is displaced upwards
c,,2^"Text"
c''2
R1
% Turn off collision avoidance
\once \override TextScript #'outside-staff-priority = ##f
c,,2^"Long Text   "
c''2
R1
% Turn off collision avoidance
\once \override TextScript #'outside-staff-priority = ##f
\textLengthOn  % and turn on textLengthOn
c,,2^"Long Text   "  % Spaces at end are honored
c''2
@end lilypond


@subheading Dynamik

@cindex Verändern der Positionierung von Dynamikzeichen
@cindex Dynamikzeichen: Positionierung verändern

Dynamikbezeichnung wird üblicherweise unter dem System
gesetzt, kann aber auch nach oben mit dem Befehl
@code{dynamicUp} gezwungen werden.  Die Bezeichnung
wird vertikal relativ zu der Note positioniert, an die sie angefügt
wurde.  Sie wird vertikal variabel gesetzt in Bezug zu 
Innersystemobjekten wie Bögen oder Taktnummern. Damit
können oft recht gute Resultate erreicht werden, wie im
folgenden Beispiel:

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
\clef "bass"
\key aes \major
\time 9/8
\dynamicUp
bes4.~\f\< \( bes4 bes8 des4\ff\> c16 bes\! |
ees,2.~\)\mf ees4 r8 |
@end lilypond

Wenn aber Noten und Dynamikzeichen sehr dicht beieinander
stehen, positioniert die automatische Kollisionsvermeidung
später kommende Dynamikzeichen weiter weg, was allerdings
nicht immer die beste Möglichkeit ist, wie in dem folgenden,
etwas gewollten Beispiel zu sehen ist:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\dynamicUp
a4\f b\mf c\mp b\p
@end lilypond

@noindent
Wenn eine ähnliche Situation in @qq{echter} Musik auftaucht,
kann es nötig sein, die Noten etwas zu spreizen, damit die
Dynamikzeichen alle auf der selben vertikalen Position
gesetzt werden können.  Dieses Verhalten war im Falle von
Textbeschriftungen möglich mit dem @code{\textLengthOn}-Befehl,
aber es gibt keinen entsprechenden Befehl für Dynamik.  Wir
müssen also unsere eigenen Befehle mit @code{\override}
konstruieren.


@subheading Verändern der Größe von grobs

@cindex Grob, Größenveränderung
@cindex Größenveränderung von grobs

Zuallererst müssen wir lernen, wie die Größe von Grobs verändert
wird.  Alle Grobs besitzen einen Referenzpunkt, der
benutzt wird, um ihre Position in Relation zu ihnen übergeordneten
Objekten zu bestimmen.  Dieser Punkt innerhalb des Grobs wird dann
auf einer horizontalen Position (@code{X-offset}) und einer
vertikalen Position (@code{Y-offset}) ausgerichtet, immer bezüglich
des übergeordneten Objektes.  Eine horizontale Strecke wird
durch ein Zahlenpaar angegeben (@code{X-extent}), welche
die linke und rechte Grenze relativ zum übergeordneten Objekt
bezeichnen.  Die vertikale Strecke wir genauso durch ein
Zahlenpaar (@code{Y-extent}) definiert.  Diese Eigenschaften
gehören zu allen Grobs, die das
@code{grob-interface} unterstützen.

@cindex @code{extra-spacing-width}

Standardmäßig haben Außersystemobjekte eine Länge von Null,
so dass sie sich in horizontaler Richtung überlappen können.  Das
geschieht, indem dem linken Rand Unendlich zugewiesen wird
und dem rechten Rand minus Undendlich (der Code der 
@code{extra-spacing-width}-(zusätzliche Positionierungslänge)-Eigenschaft
lautet: @code{'(+inf.0 . -inf.0)}).
Damit sich diese Objekte also horizontal nicht überschneiden, muss
der Wert von @code{extra-spacing-width} auf
@code{'(0 . 0)} gesetzt werden, sodass die wirkliche Länge eines
Objektes zur Geltung kommt.  Mit diesem Befehl wird das für
Dynamik-Zeichen erledigt:

@example
\override DynamicText #'extra-spacing-width = #'(0 . 0)
@end example

@noindent
Schauen wir uns an, wie es mit dem vorigen Beispiel funktioniert:

@cindex DynamicText, Beispiel zur Veränderung
@cindex extra-spacing-width-Eigenschaft, Beispiel

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\dynamicUp
\override DynamicText #'extra-spacing-width = #'(0 . 0)
a4\f b\mf c\mp b\p
@end lilypond

@noindent
Damit werden die Dynamik-Zeichen also wirklich nebeneinander
gesetzt, aber es gibt noch zwei Probleme.  Die Zeichen sollten
etwas weiter außeinander stehen und es wäre gut, wenn sie alle
den gleichen Abstand zum System hätte.  Das erste Problem ist
einfach behoben.  Anstatt der @code{extra-spacing-width}-Eigenschaft
Null zuzuweisen, können wir auch einen etwas größeren Wert
wählen.  Die Einheit wird gemessen in dem Abstand zwischen zwei
Notenlinien, es scheint also gut, den rechten und linken
Rand eine halbe Einheit zu vergrößern:

@cindex DynamicText, Beispiel zur Veränderung
@cindex extra-spacing-width-Eigenschaft, Beispiel

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\dynamicUp
% Extend width by 1 staff space
\override DynamicText #'extra-spacing-width = #'(-0.5 . 0.5)
a4\f b\mf c\mp b\p
@end lilypond

@noindent
Das sieht schon besser aus, aber es wäre noch besser, wenn die
Dynamik-Zeichen alle an einer Linie ausgerichtet wären, anstatt
höher und tiefer zu sitzen.  Das kann mit der
@code{staff-padding}-Eigenschaft erreicht werden,
die wir uns im folgenden Abschnitt genauer anschauen werden.



@node Kollision von Objekten
@section Kollision von Objekten
@translationof Collisions of objects

@menu
* Verschieben von Objekten::
* Überlappende Notation in Ordnung bringen::
* Beispiele aus dem Leben::
@end menu

@node Verschieben von Objekten
@subsection Verschieben von Objekten
@translationof Moving objects

@cindex Verschieben von überschneidenden Objekten
@cindex Verschieben von Zusammenstößen
@cindex Zusammenstöße vermeiden
@cindex Objekte, verschieben von Zusammestößen
@cindex Vermeiden von Zusammenstößen

Es wird vielleicht eine Überraschung sein, aber LilyPond ist nicht 
perfekt. Einige Notationselemente können sich überschneiden. Das 
ist nicht schön, aber zum Glück sehr selten.  Normalerweise müssen
die Objekte zur Klarheit oder aus ästhetischen Gründen verschoben
werden -- sie könnten besser aussehen, wenn sie etwas zusätzlichen
Platz erhalten.

Es gibt im Grunde drei Herangehensweisen, überlappende Notation
zu verbessern.  Man sollte sie in der folgenden Reihenfolge 
anwenden:

@enumerate
@item
Die @strong{Richtung} eines der überlappenden Objekte kann 
geändert werden, indem die vordefinierten Befehle für
Innersystemobjekte verwendet werden, wie beschrieben in
@ref{within-staff (Objekte innerhalb des Notensystems)}.  Hälse, Bögen, Balken, Dynamik-Zeichen
und Triolen können auf diese Weise einfach umgeordnet
werden.  Beschränkt ist diese Methode insofern, als es nur
zwei Möglichkeiten zur Veränderung gibt: oben oder unten.

@item
Die @strong{Objekteigenschaft}, die LilyPond benutzt um die
Layout-Objekte zu platzieren, können mit dem 
@code{\override}-Befehl positioniert werden.  Die Vorteile
von Änderungen dieser Art sind a) dass einige Objekte
automatisch verschoben werden, wenn es nötig ist Platz zu
schaffen und b) ein einziges @code{\override} sich auf
alle Fälle eines Objekttyps bezieht.  Zu diesen Eigenschaften
gehören:

@itemize

@item
@code{direction} (Richtung)

Das wurde schon detailliert behandelt, siehe
@ref{within-staff (Objekte innerhalb des Notensystems)}.

@item
@code{padding}, @code{left-padding},
@code{right-padding}, @code{staff-padding} (Verschiebung)

@cindex left-padding-Eigenschaft
@cindex Padding-Eigenschaft
@cindex right-padding-Eigenschaft
@cindex staff-padding-Eigenschaft
@cindex Verschieben (padding)
@cindex Füllung (padding)
@cindex padding (Füllung)

Wenn ein Objekt platziert wird, bestimmt der Wert seiner
@code{padding}-(Füllungs)-Eigenschaft die Größe des
Abstandes, der zwischen dem Objekt selber und dem
Objekt, relativ zu welchem es positioniert wird, gelassen
werden muss.  Dabei zählt der @code{padding}-Wert
des Objektes, das platziert werden soll, der @code{padding}-Wert
des Objektes, das schon gesetzt wurde, wird hingegegen
ignoriert.  Abstände mit @code{padding} können zu 
allen Objekten hinzugefügt werden, die das
@code{side-position-interface} unterstützen.

Anstelle von @code{padding} wird die Position von
Versetzungszeichengruppen durch die Eigenschaften
@code{left-padding} und @code{right-padding} bestimmt.
Diese Eigenschaften werden im
@code{AccidentalPlacement}-(Versetzungszeichen-Positionierungs)-Objekt
gefunden, das sich innerhalb des @strong{Staff}-Kontexts
befindet.  Während des Notensatzes werden die Notenköpfe
zuerst gesetzt und dann die Versetzungszeichen, wenn denn
welche gesetzt werden,  durch die @code{right-padding}-Eigenschaft
auf die linke Seite der Notenköpfe positioniert, um die Entfernung
von den Notenköpfen zu bestimmen.  Also nur die
@code{right-padding}-(Verschiebung nach rechts)-Eigenschaft des
@code{AccidentalPlacement}-Objekts hat Einfluss auf die
Positionierung der Versetzungszeichen.

Die @code{staff-padding}-(Verschiebung zum System)-Eigenschaft
ist sehr ähnlich wie die @code{padding}-Eigenschaft:
@code{padding} bestimmt den Minimalabstand zwischen
einem Objekt, das das @code{side-position-interface} 
unterstützt, und dem nächsten anderen Objekt (normalerweise
die Note oder Notenlinie); @code{staff-padding} dagegen
wirkt nur auf Objekte die immer außerhalb des Notensystems
sind -- damit wird der minimale Abstand bestimmt, der
zwischen dem Objekt und dem Notensystem gelassen werden 
soll.  @code{staff-padding} hat also @strong{keinen Einfluss}
auf Objekte, die relativ zu einer Note positioniert werden, sondern
nur auf solche, die zum System relativ stehen. Wenn es mit einem
anderen Objekt eingesetzt wird, erhält man keine Fehlermeldung, aber
der Befehl hat auch keine Auswirkungen.

Um herauszufinden, welche @code{padding}-Eigenschaft für
das bestimmte Objekt nötig, ist, das Sie verschieben wollen,
müssen Sie in der IR nach den Objekt-Eigenschaften schauen.
Dabei sollten Sie bedenken, dass sich die @code{padding}-Eigenschaften
nicht unbedingt in dem Objekt selber befinden, schauen Sie
also auch in Objekten nach, die offensichtlich Ähnlichkeiten
haben.

Alle @code{padding}-Werte werden in Notenlinienabständen 
gemessen.  Für die meisten Objekte ist der Wert ungefähr auf
1.0 oder weniger gesetzt (das variiert von Objekt zu Objekt).
Der Wert kann geändert werden, wenn ein größerer (oder
kleinerer) Abstand gewünscht wird.

@item
@code{self-alignment-X} (Selbstpositionierung)

@cindex self-alignment-X-Eigenschaft
@cindex Selbstpositionierung von Objekten
@cindex Ausrichtung von Objekten

Diese Eigenschaft kann benutzt werden, um ein Objekt
nach links, rechts oder zentriert an dem Referenzpunkt des Objekts
auszurichten, an das es verknüpft ist.  Es kann bei allen
Objekten benutzt werden, die das @code{self-alignment-interface}
unterstützen.  Das sind üblicherweise Objekte, die Text
enthalten.  Die möglichen Werte der Eigenschaft sind @code{LEFT},
@code{RIGHT} oder @code{CENTER}.  Alternativ kann ein
numerischer Wert zwischen @code{-1} und @code{+1} 
bestimmt werden: @code{-1} heißt linksbündig, @code{+1}
rechtsbündig und Zahlen dazwischen bewegen den Text
schrittweise von links nach rechts.  Zahlen größer als
@code{1} können angegeben werdne, um den Text
noch weiter nach links zu bewegen, oder weniger als @code{-1},
um ihn weiter nach rechts zu schieben.  Eine Änderung
um @code{1} des Wertes entspricht einer Bewegung um 
die halbe Textbreite.

@item
@code{extra-spacing-width} (zusätzliche Breite)

@cindex extra-spacing-width-Eigenschaft

Diese Eigenschaft steht für alle Objekte zur Verfügung, die
das @code{item-interface} unterstützen.  Es braucht zwei
Zahlen als Argument, die erste wird zur rechten Ausdehnung,
die zweite zur linken Ausdehnung hinzugerechnet.  Negative
Zahlen verschieben die Ausdehnung nach rechts, positive nach
links, um also ein Objekt zu verbreitern, muss die erste
Zahl negativ und die zweite positiv sein.  Allerdings beachten
nicht alle Objekte beide Zahlen.  Das 
@code{accidental}-(Versetzungszeichen)-Objekt etwa beachtet
nur erste Zahl für die linke Ausdehnung.

@item
@code{staff-position} (Notensystempositionierung)

@cindex staff-position-Eigenschaft

@code{staff-position} ist eine Eigenschaft des
@code{staff-symbol-referencer-interface}, die von Objekten unterstützt
wird, die relativ zum Notensystem (engl. staff) positioniert werden.
Hiermit wird die vertikale Position eines Objekts relativ zur
Mittellinie des Systems in halben Notenlinienabständen angegeben.
Das ist sehr nützlich, um Zusammenstöße zwischen Layout-Objekten
wie Ganztaktpausen, Bögen und Noten in verschiedenen Stimmen
zu lösen.

@item
@code{force-hshift} (vertikale Verschiebung erzwingen)

@cindex force-hshift-Eigenschaft

Eng beeinander stehende Noten in einem Akkord oder Noten, die zum
gleichen Zeitpunkt in unterschiedlichen Stimmen stehen, werden
in zwei oder manchmal auch mehr Kolumnen gesetzt, um Kollisionen
zu umgehen.  Diese Kolumnen werden Notenkolumnen genannt;
ein @code{NoteColumn}-Objekt wird erstellt um die Noten in den
Kolumnen zu setzen.

Die @code{force-hshift}-(erzwinge horizontale Verschiebung)-Eigenschaft
ist eine Eigenschaft von @code{NoteColumn} (bzw. vom
@code{note-column-interface}).  Eine Veränderung dieser Eigenschaft
macht es möglich, eine Notenkolumne zu verschieben, dabei gilt als
Einheit die Breite einer Kolumne, also die Breite des Notenkopfes der
ersten Stimme.  Diese Eigenschaft kann in Situationen benutzt werden,
in denen die normalen @code{\shiftOn}-Befehle (siehe auch
@ref{Stimmen explizit beginnen}) das Problem nicht beseitigen.
Diese Eigenschaft ist besser in solchen Fällen zu verwenden als die
@code{extra-offset}-Eigenschaft, weil man die richtige Entfernung nicht
in Notenlinienabständen ausrechnen muss.  Wenn eine Note in eine
Notenkolumne oder aus ihr heraus geschoben wird, werden auch andere
Funktionen beeinflusst, wie etwa die Verschmelzung von Notenköpfen.

@end itemize

@item
Zu guter Letzt, wenn alles andere nicht funktioniert, können Objekte auch
manuell positioniert werden, entweder vertikal in Bezug auf die
Mittellinie des Systems, oder indem sie einen beliebigen Abstand weit
auf eine neue Position verschoben werden.  Der Nachteil ist, dass die
richtigen Werte für eine gute Position manuell ausprobiert werden müssen,
meistens durch Herantasten an den richtigen Wert, und das für jedes
einzelne Objekt extra.  Und weil diese Verschiebungen erst vorgenommen
werden, wenn LilyPond alle anderen Objekte gesetzt hat, ist man als
Notensetzer selber dafür verantwortlich, ob es Zusammenstöße gibt.
Am schwerwiegendsten ist aber die Tatsache, dass die
Verschiebungskoordinaten wahrscheinlich neu errechnent oder 
ausprobiert werden müssen, wenn sich an den Noten und deren
Layout später irgend etwas ändert.  Die Eigenschaften, die für diese
Arte der manuellen Verschiebung verwendet werden können, sind:

@table @code
@item extra-offset (zusätzlicher Abstand)

@cindex extra-offset-Eigenschaft

Diese Eigenschaft gehört zu jedem Layout-Objekt, das das
@code{grob-interface} unterstützt.  Sie braucht ein Zahlenpaar,
das die exakte Verschiebung in horizontaler und vertikaler Richtung
bezeichnet.  Negative Zahlen verschieben das Objekt nach links oder
unten.  Die Einheit sind Notenlinienabstände.  Die zusätzliche
Positionierung wird vorgenommen, nachdem alle anderen Objekte
platziert sind, weshalb ein Objekt irgendwohin verschoben werden
kann, ohne den restlichen Satz zu beeinflussen.

@item positions (Position)

@cindex positions-Eigenschaft

Diese Eigenschaft ist am sinnvollsten, um die Steigung und die
Höhe von Balken, Bögen und Triolenklammern anzupassen.
Sie braucht ein Zahlenpaar, das die Position des rechten und linken
Endes relativ zur Mittellinie des Notensystems bestimmt.  Die
Einheit sind Notenlinienabstände.  Bögen allerdings können nicht
beliebig weit weg positioniert werden.  LilyPond erstellt zunächst eine
Liste an möglichen Positionen für den Bogen und findet normalerweise
die Version, die @qq{am besten aussieht}.  Wenn die 
@code{positions}-Eigenschaft verändert worden ist, wird der
Bogen aus der Liste gewählt, der der gewünschten Position am
nächsten kommt.
@end table

@end enumerate

Ein bestimmtes Objekt hat vielleicht nicht alle dieser Eigenschaften.
Darum ist es nötig, in der IR nachzuschlagen, welche Eigenschaften
ein bestimmtes Objekt unterstützt.

Hier ist eine Liste an Objekten, die am wahrscheinlichsten an einer
Kollision beteiligt sind, daneben findet sich die Bezeichnung des
Objektes, mit der Sie es in der IR finden, um zu bestimmen,
welche Eigenschaften benutzt werden können, um es zu verschieben.

@multitable @columnfractions .5 .5
@headitem Objekttyp           @tab Objektbezeichnung
@item Articulationszeichen             @tab @code{Script}
@item Balken                     @tab @code{Beam}
@item Dynamikzeichen (vertikal)     @tab @code{DynamicLineSpanner}
@item Dynamikzeichen (horizontal)   @tab @code{DynamicText}
@item Fingersatz                @tab @code{Fingering}
@item Übungs-/Textmarken    @tab @code{RehearsalMark}
@item Legatobögen                     @tab @code{Slur}
@item Text z. B. @code{^"text"}  @tab @code{TextScript}
@item Bindebögen                      @tab @code{Tie}
@item N-tolen                   @tab @code{TupletBracket}
@end multitable


@node Überlappende Notation in Ordnung bringen
@subsection Überlappende Notation in Ordnung bringen
@translationof Fixing overlapping notation

Hier soll nun gezeigt werden, wie die Eigenschaften, die im
vorigen Abschnitt vorgestellt wurden, bei der Problemlösung
mit sich überschneidenden Notationselementen eingesetzt
werden können.

@subheading padding (Fülleigenschafte)

@cindex padding (Verschiebungs-Eigenschaft)
@cindex Überschneidende Notation korrigieren
@cindex Korrigieren von überschneidender Notation

Die @code{padding}-(Verschiebungs-)Eigenschaft kann benutzt
werden, um den Abstand zwischen Symbolen zu vergößern (oder
zu verkleinern), die über oder unter den Noten gesetzt werden.

@cindex Script, Beispiel zur Veränderung
@cindex Verschiebungs-Eigenschaft, Beispiel
@cindex padding (Verschiebuns-Eigenschaft), Beispiel

@lilypond[quote,fragment,relative=1,verbatim]
c2\fermata
\override Script #'padding = #3
b2\fermata
@end lilypond

@cindex MetronomMark, Beispiel zur Veränderung
@cindex Verschiebungs-Eigenschaft, Beispiel
@cindex padding (Verschiebuns-Eigenschaft), Beispiel

@lilypond[quote,fragment,relative=1,verbatim]
% This will not work, see below:
\override MetronomeMark #'padding = #3
\tempo 4=120
c1
% This works:
\override Score.MetronomeMark #'padding = #3
\tempo 4=80
d1
@end lilypond

Im zweiten Beispiel können Sie sehen, wie wichtig es ist den richtigen
Kontext anzugeben.  Weil das @code{MetronomeMark}-Objekt
sich im @code{Score}-Kontext befindet, werden Eigenschaftsänderungen
im @code{Voice}-Kontext einfach ignoriert.  Für mehr Einzelheiten siehe
@ruser{Eignschaften verändern}.

Wenn die @code{padding}-Eigenschaft eines Objektes erhöht wird, das
sich in einem Stapel von Objekten befindet, die nach ihrer
Außersystempriorität (@code{outside-staff-priority}) positioniert werden,
werden das Objekt und alle,  die sich außerhalb davon befinden,
entsprechend verschoben.

@subheading left-padding (Verschieben nach rechts) und right-padding (Verschieben nach links)

@cindex left-padding-Eigenschaft (Verschiebung nach links)
@cindex Verschiebung nach rechts oder links
@cindex right-padding-Eigenschaft (Verschiebung nach rechts)

Die @code{right-padding}-Eigenschaft wirkt sich auf den Abstand
zwischen einem Versetzungszeichen und der Note, auf das sie sich
bezieht, aus.  Sie wird nicht sehr oft benötigt, aber die
Standardanordnung kann für einige spezielle Versetzungszeichen-Glyphen
oder Kombinationsglyphen,
wie sie für Mikrotonale Musik benutzt werden, falsch sein.  Derartige
Glyphen müssen notiert werden, indem man den Stencil des
Versetzungszeichens mit einer Textbeschriftung (Markup) ersetzt,
wie im folgenden Beispiel:

@cindex Versetzungszeichen, Beispiel zur Veränderung
@cindex Accidental, Beispiel zur Veränderung
@cindex Text-Eigenschaft, Beispiel
@cindex stencil-Eigenschaft, Beispiel
@cindex AccidentalPlacement, Beispiel zur Veränderung
@cindex right-padding-Eigenschaft, Beispiel
@cindex Verschiebung nach rechts (rigth-padding), Beispiel

@lilypond[quote,ragged-right,verbatim]
sesquisharp = \markup { \sesquisharp }
 \relative c'' {
  c
  % This prints a sesquisharp but the spacing is too small
  \once \override Accidental
    #'stencil = #ly:text-interface::print
  \once \override Accidental #'text = #sesquisharp
  cis c
  % This improves the spacing
  \once \override Score.AccidentalPlacement #'right-padding = #0.6
  \once \override Accidental
    #'stencil = #ly:text-interface::print
  \once \override Accidental #'text = #sesquisharp
  cis
}
@end lilypond

@noindent
Dazu ist aber ein @code{\override}-Befehl für den Stencil des
Versetzungszeichens nötig, der bisher nicht behandelt wurde.
Der Typ des Stencils muss eine Prozedur sein, die hier geändert
wurde, um den Inhalt der @code{text}-Eigenschaft des
@code{Accidental} (Versetzungszeichen)-Objekts zu setzen.  Die
@code{text}-Eigenschaft wiederum wird als @code{sesquisharp}-Glyph
definiert.  Dieser Glyph wird dann weiter vom Notenkopf entfernt
durch die Veränderung von @code{right-padding} mit einem
@code{\override}-Befehl.

@subheading staff-padding (Systemfüllungseigenschaft)

@cindex staff-padding-Eigenschaft
@cindex Objekte an der Grundlinie ausrichten
@cindex Ausrichten von Objekten an der Grundlinie

@code{staff-padding} (Verschiebung zum Notensystem) kann 
verwendet werden um Objekte wie Dynamikzeichen an einer
Grundlinie auf einer bestimmten Höhe über dem System 
auszurichten, sodass sie nicht von der Position der Note abhängen,
an die sie angehängt sind.  Diese Verschiebung ist keine Eigenschaft
von @code{DynamicText}, sondern von @code{DynamicLineSpanner}.
Das liegt daran, dass die Grundlinie sich gleicherweise auf 
@strong{alle} Dynamikzeichen beziehen soll, also auch auf die,
die als Strecker erstellt wurden.  Hier also die Lösung, die Dynamikzeichen
aus dem Beispiel des vorigen Abschnitts auszurichten:

@cindex DynamikText, Beispiel zur Veränderung
@cindex extra-spacing-width-Eigenschaft, Beispiel
@cindex DynamicLineSpanner, Beispiel zur Veränderung
@cindex staff-padding-Eigenschaft, Beispiel

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\dynamicUp
% Extend width by 1 unit
\override DynamicText #'extra-spacing-width = #'(-0.5 . 0.5)
% Align dynamics to a base line 2 units above staff
\override DynamicLineSpanner #'staff-padding = #2
a4\f b\mf c\mp b\p
@end lilypond


@subheading self-alignment-X (Selbstausrichtung-X-Eigenschaft)

@cindex self-alignment-X-Eigenschaft

Das nächste Beispiel zeigt, wie man den Zusammenstoß
einer Fingersatzbezeichnung mit einem Notenhals
verhindern kann, indem die rechte Ecke an dem
Referenzpunkt der abhängigen Note angeordnet wird:

@cindex StringNumber, Beispiel zur Veränderung

@lilypond[quote,fragment,ragged-right,verbatim,relative=3]
\voiceOne
< a \2 >
\once \override StringNumber #'self-alignment-X = #RIGHT
< a \2 >
@end lilypond


@subheading staff-position (Position innerhalb des Systems)

@cindex staff-position-Eigenschaft
@cindex Notensystem-Position-Eigenschaft
@cindex Kollision von Objekten im System
@cindex Zusammenstöße von Objekten im System

Vieltaktpausen in einer Stimmen können mit Noten in anderen
Stimmen kollidieren.  Da diese Pausen zentriert zwischen den
Taktlinien gesetzt werden, würde es für LilyPond eine recht große
Anstrengung bedeuten herauszufinden, welche Noten mit ihnen
zusammenstoßen könnten, denn alle Kollisionsvermeidung
für Noten und Pausen funktioniert nur für Noten bzw. Pausen, die
zur selben Zeit auftreten.  Hier ein typisches Beispiel für eine
Kollision dieser Art:

@lilypond[quote,verbatim,fragment,ragged-right, relative=1]
<< {c c c c} \\ {R1} >>
@end lilypond

Die beste Lösung ist es, die Ganztaktpause nach unten zu
schieben, denn die Pause ist in der zweiten Stimme.  Per
Standardeinstellung für die zweite Stimme (@code{\voiceTwo},
also die zweite Stimme in der
@code{<<@{...@} \\ @{...@}>>}-Konstruktion) wird die
Position auf dem System (@code{staff-position}) auf -4
für @code{MultiMeasureRest}, in unserem Beispiel muss
es also bspw. auf die Position @code{-8} gesetzt werden, 
d.h. vier halbe Notenlinienabstände weiter nach unten:

@cindex MultiMeasureRest, Beispiel zur Veränderung
@cindex Ganztaktpausen, Beispiel zur Veränderung
@cindex staff-position-Eigenschaft, Beispiel

@lilypond[quote,verbatim,fragment,ragged-right, relative=1]
<<
  {c c c c}
\\
  \override MultiMeasureRest #'staff-position = #-8
  {R1}
>>
@end lilypond

Das ist besser, als etwa @code{extra-offset} zu benutzen, denn
in unserem Fall wird die Hilfslinie der Pause automatisch gesetzt.


@subheading extra-offset (Genaues Positionieren)

@cindex extra-offset-Eigenschaft
@cindex Zusätzlicher Abstand, Positionierung
@cindex Positionierung von Objekten
@cindex Objekte, Positionierung

Die @code{extra-offset}-Eigenschaft bietet vollständige Kontrolle
über die Positionierung von Objekten in horizontaler und vertikaler
Richtung.

Im Beispiel unten ist das zweite Fingersatzzeichen (@code{Fingering}) etwas nach
links und 1,8 Notenlinienabstände nach unten verschoben:

@cindex Fingersatz, Beispiel zur Veränderung
@cindex extra-offset-Eigenschaft, Beispiel

@lilypond[quote,fragment,relative=1,verbatim]
\stemUp
f-5
\once \override Fingering
    #'extra-offset = #'(-0.3 . -1.8)
f-5
@end lilypond


@subheading Ausrichtungseigenschaft

@cindex positions-Eigenschaft
@cindex Kontrolle über Triolen, Bögen und Balken manuell
@cindex manuelle Kontrolle über Triolen, Bögen, Balken
@cindex Balken, manuelle Kontrolle
@cindex Bögen, manuelle Kontrolle
@cindex Legatobögen, manuelle Kontrolle
@cindex Phrasierungsbögen, manuelle Kontrolle
@cindex Triollen-Klammer, manuelle Kontrolle

Die @code{positions}-Eigenschaft erlaubt die Kontrolle von Position und
Steigung von Balken, Legato- und Phrasierungsbögen sowie Triolenklammern.
Hier ein Beispiel, in der ein unschöner Phrasierungsbogen auftritt, weil
er den Bogen des Vorschlags vermeidet:

@lilypond[quote,verbatim,fragment,ragged-right,relative=1]
r4  \acciaccatura e8\( d8 c ~c d c d\)
@end lilypond

@noindent
Man könnte einfach den Phrasierungsbogen oberhalb der Noten setzen, und
das wäre auch die beste Lösung:

@cindex Phrasierungsbogen, Beispiel zur Veränderung
@cindex positions-Eigenschaft, Beispiel
@cindex Positionierung, Beispiel

@lilypond[quote,verbatim,fragment,ragged-right,relative=1]
r4
\phrasingSlurUp
\acciaccatura e8\( d8 c ~c d c d\)
@end lilypond

@noindent
aber wenn es einen Grund geben sollte, warum das nicht geht, könnte
man das linke Ende des Phrasierungsbogens etwas nach unten verschieben,
indem man die @code{positions}-Eigenschaft einsetzt.  Damit
verschwindet auch die etwas unschöne Form:

@lilypond[quote,verbatim,fragment,ragged-right,relative=1]
r4
\once \override PhrasingSlur #'positions = #'(-4 . -3)
\acciaccatura
e8\( d8 c ~c d c d\)
@end lilypond

Hier noch ein weiteres Beispiel aus der Einleitung von Chopins
Prelude Op. 28 Nr. 2, das untere System.  Wie zu sehen ist,
stößt der Balken mit den oberen Noten zusammen:

@lilypond[quote,verbatim,fragment,ragged-right]
{
\clef "bass"
<< {b,8 ais, b, g,} \\ {e, g e, g} >>
<< {b,8 ais, b, g,} \\ {e, g e, g} >>
}
@end lilypond

@noindent
Das kann manuell gelöst werden, indem beide Enden des Balkens
von ihrer Position 2 Notenlinienabstände über der Mittellinie
hochgeschoben werden, etwa auf 3:

@cindex Balken, Beispiel zur Veränderung
@cindex positions-Eigenschaft, Beispiel
@cindex Positionierung, Beispiel

@lilypond[quote,verbatim,fragment,ragged-right]
{
  \clef "bass"
  <<
    \override Beam #'positions = #'(3 . 3)
    {b,8 ais, b, g,}
  \\
    {e, g e, g}
  >>
  << {b,8 ais, b, g,} \\ {e, g e, g} >>
}
@end lilypond

@noindent
Hier ist zu beobachten, dass die Veränderung sich auch auf die
weiteren Achtelbalken der ersten Stimme auwirkt, während sie keine
Auswirkung auf die Balken der zweiten Stimme hat.

@subheading force-hshift (vertikale Verschiebunseigenschaft)

@cindex force-hshift-Eigenschaft
@cindex Vertikale Verschiebung erzwingen

@c FIXME: formatting stuff  (ie not important right now IMO)
@c @a nchor Chopin finally corrected TODOgp

An diesem Punkt können wir den letzten Feinschliff an unserem
Chopin-Beispiel vornhemen, das wir behandelt haben in
@ref{Ich höre Stimmen}.  Wir hatten es in folgende Form
gebracht:

@lilypond[quote,verbatim,fragment,ragged-right]
\new Staff \relative c'' {
  \key aes \major
  <<
    { c2 aes4. bes8 } \\
    { aes2 f4 fes   } \\
    { \voiceFour
      <ees c>2
      des2
    }
  >> |
  <c ees aes c>1 |
}
@end lilypond

@noindent
Die unteren zwei Noten des ersten Akkords (also diein der
dritten Stimme) sollten nicht aus der Notenkolumne der
oberen zwei Noten weggeschoben werden.  Um das zu
korrigieren, setzen wir @code{force-hshift}, das eine
Eigenschaft von
@code{NoteColumn} ist, für diese Noten auf Null.
Die untere Note des zweiten Akkordes wird am besten
direkt rechts von den oberen Noten gesetzt.  Das erreichen
wir, indem wir @code{force-hshift} für diese Note auf
0.5 setzen, also eine halbe Notenkopfbreite nach rechts von
der Kolumne der oberen Noten aus.

Hier das Endergebnis:

@cindex Notenkolumne, Beispiel zur Veränderung
@cindex force-hshift-Eigenschaft, Beispiel
@cindex vertikale Verschiebung, Beispiel

@lilypond[quote,verbatim,fragment,ragged-right]
\new Staff \relative c'' {
  \key aes \major
  <<
    { c2 aes4. bes8 } \\
    { aes2 f4 fes   } \\
    { \voiceFour
      \once \override NoteColumn #'force-hshift = #0 <ees c>2
      \once \override NoteColumn #'force-hshift = #0.5 des2
    }
  >> |
  <c ees aes c>1 |
}
@end lilypond


@node Beispiele aus dem Leben
@subsection Beispiele aus dem Leben
@translationof Real music example

Das Kapitel zu Optimierungen soll mit einem komplizierten Beispiel
beendet werden, in dem verschiedene Optimierungen vorgenommen
werden müssen, bis das Ergebnis gut ausssieht.  Das Beispiel wurde
ganz bewusst gewählt um die Benutzung der Notationsreferenz
zu zeigen, wenn ungewöhnliche Notationsprobleme gelöst werden
müssen.  Es ist nicht repräsentativ für normale Notationsprojekte,
lassen Sie sich also nicht durch dieses Beispiel entmutigen!  Zum
Glück sind Probleme wie die hier gezeigten nicht sehr häufig.

Das Beispiel stammt aus Chopins Premiére Ballade, Op. 23, Takte
6--9, der Übergang vom Lento der Einleitung zum Moderato.
Hier zunächst der Satz, wie er aussehen soll, allerdings ohne
Dynamik, Fingersatz und Pedalbezeichnung, um das Beispiel nicht
zu kompliziert zu machen.

@c This example should not be indexed
@lilypond[quote,ragged-right]
rhMusic = \relative c'' {
  r2
  c4.\( g8 |
  \once \override Tie #'staff-position = #3.5
  bes1~ |
  \bar "||"
  \time 6/4
  \mergeDifferentlyHeadedOn
  \mergeDifferentlyDottedOn
  bes2.^\markup {\bold "Moderato"} r8
  <<
    {c,8[ d fis bes a] | }
  \\
    % Reposition the c2 to the right of the merged note
    {c,8~ \once \override NoteColumn #'force-hshift = #1.0
    % Move the c2 out of the main note column so the merge will work
    \shiftOnn c2}
  \\
    % Stem on the d2 must be down to permit merging
    {s8 \stemDown \once \override Stem #'transparent = ##t d2}
  \\
    {s4 fis4.}
  >>
  \mergeDifferentlyHeadedOff
  \mergeDifferentlyDottedOff
  g2.\)
}

lhMusic = \relative c' {
  r2 <c g ees>2( |
  <d g, d>1)\arpeggio |
  r2. d,,4 r4 r |
  r4
}

\score {
  \new PianoStaff <<
    \new Staff = "RH"  <<
      \key g \minor
      \rhMusic
    >>
    \new Staff = "LH" <<
      \key g \minor
      \clef "bass"
      \lhMusic
    >>
  >>
}
@end lilypond

Die erste Überlegung ist, dass das System für die rechte Hand
im dritten Takt vier Stimmen braucht.  Das sind die fünf
Achtelnoten mit Balken, das übergebundene C, die Halbe D, die
mit der Achtel D verschmolzen ist, und die punktierte Viertel
Fis, die auch mit einer Achtelnote verschmolzen ist.  Alles
andere ist eine einzige Stimme, es ist also am einfachsten, die
Stimmen nur zeitweise zu erstellen, wenn sie auftreten.  Wenn
Sie vergessen haben, wie man das anstellt, schauen Sie sich
nochmal den Abschnitt @ref{Ich höre Stimmen} an.  Wir
wollen anfange, indem wir die Noten in zwei Variablen
notieren und dann die Systemstruktur in einer
@code{\score}-Umgebung erstellen.  Das ist, was LilyPond
erstellt:

@lilypond[quote,verbatim,ragged-right]
rhMusic = \relative c'' {
  r2 c4. g8 |
  bes1~ |
  \time 6/4
  bes2. r8
  % Start polyphonic section of four voices
  <<
    {c,8 d fis bes a | }
  \\
    {c,8~ c2 | }
  \\
    {s8 d2 | }
  \\
    {s4 fis4. | }
  >>
  g2.
}

lhMusic = \relative c' {
  r2 <c g ees>2 |
  <d g, d>1 |
  r2. d,,4 r4 r |
  r4
}

\score {
  \new PianoStaff <<
    \new Staff = "RH"  <<
      \key g \minor
      \rhMusic
    >>
    \new Staff = "LH" <<
      \key g \minor
      \clef "bass"
      \lhMusic
    >>
  >>
}
@end lilypond

Alle Noten sind richtig, aber die Positionierung sehr
verbesserungsbedürftig.  Der Bindebogen stößt mit
der veränderten Taktart zusammen, die Balkung im
dritten Takt ist falsch, die Noten werden nicht 
verschmolzen und einige Notationselemente fehlen ganz.
Behandeln wir zunächst die einfacheren Dinge.  Der
Balken kann durch eine manuelle Begrenzung einfach
korrigiert werden, und auch der Legatobogen der linken
Hand und der Phrasierungsbogen der rechten Hand
sind schnell gesetzt, denn sie wurden schon in der
Übung erklärt.  Damit haben wir folgendes Notenbild:

@lilypond[quote,verbatim,ragged-right]
rhMusic = \relative c'' {
  r2 c4.\( g8 |
  bes1~ |
  \time 6/4
  bes2. r8
  % Start polyphonic section of four voices
  <<
    {c,8[ d fis bes a] | }
  \\
    {c,8~ c2 | }
  \\
    {s8 d2 | }
  \\
    {s4 fis4. | }
  >>
  g2.\)
}

lhMusic = \relative c' {
  r2 <c g ees>2( |
  <d g, d>1) |
  r2. d,,4 r4 r |
  r4
}

\score {
  \new PianoStaff <<
    \new Staff = "RH"  <<
      \key g \minor
      \rhMusic
    >>
    \new Staff = "LH" <<
      \key g \minor
      \clef "bass"
      \lhMusic
    >>
  >>
}
@end lilypond

Der erste Takt stimmt jetzt schon.  Der zweite Takt enthält ein
Arpeggio und wird mit einer doppelten Taktlinie beschlossen.
Wie können wir diese notieren, denn sie sind im Handbuch zum
Lernen nicht vorgekommen?  Hier brauchen wir jetzt die
Notationsreferenz.  Ein Blick in den Index zeigt uns die
Einträge für @qq{Arpeggio} und @qq{Taktlinien}: ein
Arpeggio also erstellt man mit dem Befehl @code{\arpeggio}
hinter einem Akkord und eine doppelte Taktlinie wird mit dem
Befehl @code{\bar "||"} erstellt.  Das ist einfach.  Als nächstes
muss der Zusammenstoß des Bindebogens mit der Taktartbezeichnung
gelöst werden.  Das geht am besten, indem wir den Bogen nach
oben verschieben.  Wie man Objekte verschiebt wurde schon
behandelt in @ref{Verschieben von Objekten}, wo stand, dass Objekte
die
relativ zum System positioniert werden, verschoben werden 
können, indem ihre @code{staff-position}-Eigenschaft
geändert wird, die in halben Notenlienienabständen relativ
zur Mittellinie angegeben wird.  Dieser @code{\override}-Befehl
also, direkt vor die erste übergebundene Note gestellt, verschiebt
den Bindebogen (@code{tie}) 3,5 halbe Notenlinienabstände
über die Mittellinie:

@code{\once \override Tie #'staff-position = #3.5}

Damit ist auch der zweite Takt vollständig:

@lilypond[quote,verbatim,ragged-right]
rhMusic = \relative c'' {
  r2 c4.\( g8 |
  \once \override Tie #'staff-position = #3.5
  bes1~ |
  \bar "||"
  \time 6/4
  bes2. r8
  % Start polyphonic section of four voices
  <<
    {c,8[ d fis bes a] | }
  \\
    {c,8~ c2 | }
  \\
    {s8 d2 | }
  \\
    {s4 fis4. | }
  >>
  g2.\)
}

lhMusic = \relative c' {
  r2 <c g ees>2( |
  <d g, d>1)\arpeggio |
  r2. d,,4 r4 r |
  r4
}

\score {
  \new PianoStaff <<
    \new Staff = "RH"  <<
      \key g \minor
      \rhMusic
    >>
    \new Staff = "LH" <<
      \key g \minor
      \clef "bass"
      \lhMusic
    >>
  >>
}
@end lilypond

In Takt drei beginnt der Moderato-Abschnitt.  In der
Übung wurde behandelt, wie man fetten Text mit dem
@code{\markup}-Befehl eingibt, es ist also einfach, das
@qq{Moderato} hinzuzufügen.  Wie aber werden Noten
verschmolzen?  Hier nehmen wir wieder die Notationsreferenz
zu Hilfe.  Die Suche nach @qq{Verschmelzen} (engl. merge)
im Index führt uns zu den Befehlen um Noten mit
unterschiedlichen Köpfen und unterschiedlichen Punkten
zu verschmelzen in @ruser{Auflösung von Zusammenstößen}.  In unserem
Beispiel müssen sowohl unterschiedliche Köpfe also auch
unterschiedliche Punktierung verschmolzen werden, wir
brauchen also die Befehle

@example
\mergeDifferentlyHeadedOn
\mergeDifferentlyDottedOn
@end example

@noindent
aus der Notationsreferenz, die wir an den Beginn unseres
Abschnittes stellen und

@example
\mergeDifferentlyHeadedOff
\mergeDifferentlyDottedOff
@end example

@noindent
um das Verhalten wieder auszuschalten. Das sieht so aus:

@cindex Bindebogen, Beispiel zur Veränderung
@cindex staff-position-Eigenschaft, Beispiel

@lilypond[quote,verbatim,ragged-right]
rhMusic = \relative c'' {
  r2 c4.\( g8 |
  \once \override Tie #'staff-position = #3.5
  bes1~ |
  \bar "||"
  \time 6/4
  bes2.^\markup {\bold "Moderato"} r8
  \mergeDifferentlyHeadedOn
  \mergeDifferentlyDottedOn
  % Start polyphonic section of four voices
  <<
    {c,8[ d fis bes a] | }
  \\
    {c,8~ c2 | }
  \\
    {s8 d2 | }
  \\
    {s4 fis4. | }
  >>
  \mergeDifferentlyHeadedOff
  \mergeDifferentlyDottedOff
  g2.\)
}

lhMusic = \relative c' {
  r2 <c g ees>2( |
  <d g, d>1)\arpeggio |
  r2. d,,4 r4 r |
  r4
}

\score {
  \new PianoStaff <<
    \new Staff = "RH"  <<
      \key g \minor
      \rhMusic
    >>
    \new Staff = "LH" <<
      \key g \minor
      \clef "bass"
      \lhMusic
    >>
  >>
}
@end lilypond

Mit diesen Veränderungen wurden die beiden Fis-Noten 
verschmolzen, aber nicht die zwei Ds.  Warum nicht?  Die
Antwort befindet sich im gleicher Abschnitt der Notationsreferenz:
Noten, die verschmolzen werden, müssen Hälse in entgegengesetzte
Richtungen aufweisen und zwei Noten können nicht verschmolzen
werden, wenn eine dritte Noten in der gleichen Kolumne
stört.  In unserem Fall weisen beide Hälse nach oben und es
befindet sich zur gleichen Zeit auch noch eine dritte Note, das C.
Wie die Richtung von Hälsen geändert wird, wissen wir schon:
mit @code{\stemDown}, und in der Notationsreferenz findet
sich auch Information, wie das C verschoben werden kann: mit
dem @code{\shift}-Befehl.  Aber welcher von ihnen?  Das C
befindet sich in der zweiten Stimme, die @qq{shift off} hat,
die zwei Ds sind in den Stimmen eins und drei, die @qq{shift
off} bzw. @qq{shift on} haben.  Das C muss also noch eine
Stufe weiter verschoben werden mit @code{\shiftOnn}, damit
es die Verschmelzung der Ds nicht stört.  Das sieht jetzt so
aus:

@lilypond[quote,verbatim,ragged-right]
rhMusic = \relative c'' {
  r2 c4.\( g8 |
  \once \override Tie #'staff-position = #3.5
  bes1~ |
  \bar "||"
  \time 6/4
  bes2.^\markup {\bold "Moderato"} r8
  \mergeDifferentlyHeadedOn
  \mergeDifferentlyDottedOn
  % Start polyphonic section of four voices
  <<
    {c,8[ d fis bes a] | }
  \\
    % Move the c2 out of the main note column so the merge will work
    {c,8~ \shiftOnn c2 | }
  \\
    % Stem on the d2 must be down to permit merging
    {s8 \stemDown d2 | }
  \\
    {s4 fis4. | }
  >>
  \mergeDifferentlyHeadedOff
  \mergeDifferentlyDottedOff
  g2.\)
}

lhMusic = \relative c' {
  r2 <c g ees>2( |
  <d g, d>1)\arpeggio |
  r2. d,,4 r4 r |
  r4
}

\score {
  \new PianoStaff <<
    \new Staff = "RH"  <<
      \key g \minor
      \rhMusic
    >>
    \new Staff = "LH" <<
      \key g \minor
      \clef "bass"
      \lhMusic
    >>
  >>
}
@end lilypond

Fast schon geschafft.  Nur noch ein Problem ist übrig: Der Hals nach
unten des verschmolzenen sollte nicht da sein, und das C sähe
besser auf der rechten Seite des Ds aus.  Beides können wir mit den
gelernten Optimierungsmethoden erreichen. Den Hals machen
wir durchsichtig und das C verschieben wir mit der
@code{force-hshift}-Eigenschaft.  Hier ist das Endergebnis:

@cindex Notenkolumne, Beispiel zur Veränderung
@cindex force-hshift-Eigenschaft, Beispiel
@cindex Hals, Beispiel zur Veränderung
@cindex Notenhals, Beispiel zur Veränderung
@cindex transparent-Eigenschaft, Beispiel

@lilypond[quote,verbatim,ragged-right]
rhMusic = \relative c'' {
  r2
  c4.\( g8 |
  \once \override Tie #'staff-position = #3.5
  bes1~ |
  \bar "||"
  \time 6/4
  bes2.^\markup {\bold "Moderato"} r8
  \mergeDifferentlyHeadedOn
  \mergeDifferentlyDottedOn
  <<
    {c,8[ d fis bes a] | }
  \\
    % Reposition the c2 to the right of the merged note
    {c,8~ \once \override NoteColumn #'force-hshift = #1.0
    % Move the c2 out of the main note column so the merge will work
    \shiftOnn c2}
  \\
    % Stem on the d2 must be down to permit merging
    {s8 \stemDown \once \override Stem #'transparent = ##t d2}
  \\
    {s4 fis4.}
  >>
  \mergeDifferentlyHeadedOff
  \mergeDifferentlyDottedOff
  g2.\)
}

lhMusic = \relative c' {
  r2 <c g ees>2( |
  <d g, d>1)\arpeggio |
  r2. d,,4 r4 r |
  r4
}

\score {
  \new PianoStaff <<
    \new Staff = "RH"  <<
      \key g \minor
      \rhMusic
    >>
    \new Staff = "LH" <<
      \key g \minor
      \clef "bass"
      \lhMusic
    >>
  >>
}
@end lilypond


@node Weitere Optimierungen
@section Weitere Optimierungen
@translationof Further tweaking

@menu
* Andere Benutzung von Optimierungen::
* Variablen für Optimierungen einsetzen::
* Mehr Information::
* Vermeiden von Optimierungen durch langsamere Übersetzung::
* Fortgeschrittene Optimierungen mit Scheme::
@end menu

@node Andere Benutzung von Optimierungen
@subsection Andere Benutzung von Optimierungen
@translationof Other uses for tweaks

@cindex Transparente Objekte
@cindex Entfernen von Objekten
@cindex Verstecken von Objekten
@cindex Unsichtbare Objekte
@cindex transparent-Eigenschaft, Benutzung
@cindex Objekte unsichtbar machen
@cindex Objekte entfernen
@cindex Objekte verstecken
@cindex Noten zwischen Stimmen überbinden
@cindex Überbinden von Noten zwischen Stimmen

@subheading Noten zwischen unterschiedlichen Stimmen überbinden

Das nächste Beispiel zeigt, wie man Noten von verschiedenen
Stimmen miteinander verknüpfen kann, indem man Bindebögen
für Überbindungen benutzt.  Normalerweise können nur zwei
Noten der gleichen Stimme übergebunden werden.  Wenn
man zwei Stimmen benutzt, wobei die überbundenen Noten
sich in der selben befinden,

@lilypond[quote,fragment,relative=2]
<< { b8~ b8\noBeam }
\\ { b[ g8] }
>>
@end lilypond

@noindent
und dann den ersten Hals nach oben unsichtbar macht,
sieht es so aus, als ob die Überbindung zwischen
den Stimmen stattfindet:

@cindex Hals, Beispiel zur Veränderung
@cindex Notenhals, Beispiel zur Veränderung
@cindex transparent-Eigenschaft, Beispiel

@lilypond[quote,fragment,relative=2,verbatim]
<<
  {
    \once \override Stem #'transparent = ##t
    b8~ b8\noBeam
  }
\\
  { b[ g8] }
>>
@end lilypond

Um sicherzugehen, dass der unsichtbare Hals den Bindebogen
nicht zu sehr verkleinert, kann er verlängert werden, indem
seine Länge (@code{length}) auf den Wert @code{8}
gesetzt wird:

@lilypond[quote,fragment,relative=2,verbatim]
<<
  {
    \once \override Stem #'transparent = ##t
    \once \override Stem #'length = #8
    b8~ b8\noBeam
  }
\\
  { b[ g8] }
>>
@end lilypond


@subheading Eine Fermate in MIDI simulieren

@cindex stencil-Eigenschaft, Benutzung
@cindex Fermate, Benutzung in MIDI
@cindex MIDI: Fermate erstellen

Für Objekte außerhalb des Notensystems ist es normalerweise
besser, die @code{stencil}-Eigenschaft anstelle der
@code{transparent}-Eigenschaft zu verändern, wenn man
sie vom fertigen Notensatz entfernen will.  Indem die
@code{stencil}-Eigenschaft auf falsch (@code{#f}) gesetzt
wird, wird das entsprechende Objekt vollständig entfernt.
Das bedeutet, dass es die Positionierung der anderen Objekte
nicht beeinflusst.

Auf diese Art kann etwa das Tempo geändert werden, damit
in der MIDI-Ausgabe eine Fermate zu hören ist, ohne dass
im Notensatz etwas von diesen Tempoänderungen zu sehen
ist.  Die Metronombezeichnung soll auch nicht die Position
von Text an der gleichen Stelle oder die Abstände zwischen
zwei Systemen beeinflussen.  Darum ist es am besten, 
@code{stencil} auf @code{#f} zu setzen.  Im Beispiel wird
der Unterschied zwischen einem unsichtbaren Objekt und
einem entfernten Objekt gezeigt:

@cindex Metronom-Bezeichnung, Beispiel zur Veränderung
@cindex transparent-Eigenschaft, Beispiel

@lilypond[quote,verbatim,ragged-right]
\score {
  \relative c'' {
    % Visible tempo marking
    \tempo 4=120
    a4 a a
    \once \override Score.MetronomeMark #'transparent = ##t
    % Invisible tempo marking to lengthen fermata in MIDI
    \tempo 4=80
    a\fermata
    % New tempo for next section
    \tempo 4=100
    a a a a
  }
  \layout { }
  \midi { }
}
@end lilypond

@lilypond[quote,verbatim,ragged-right]
\score {
  \relative c'' {
    % Visible tempo marking
    \tempo 4=120
    a4 a a
    \once \override Score.MetronomeMark #'stencil = ##f
    % Invisible tempo marking to lengthen fermata in MIDI
    \tempo 4=80
    a\fermata
    % New tempo for next section
    \tempo 4=100
    a a a a
  }
  \layout { }
  \midi { }
}
@end lilypond

@noindent
Mit beiden Methoden wird die Tempobezeichnung entfernt, mit
der die Fermate verlängert wird, und beide beeinflussen die
MIDI-Ausgabe wie gewünscht.  Die unsichtbare Metronombezeichnung
schiebt aber die folgende Bezeichnung in die Höhe, während
das im zweiten Beispiel, in dem der @code{stencil} entfernt
wurde, nicht passiert.


@node Variablen für Optimierungen einsetzen
@subsection Variablen für Optimierungen einsetzen
@translationof Using variables for tweaks

@cindex Variablen, Benutzung zur Optimierung
@cindex Optimierung mit Variablen

@code{\override}-Befehle sind oft lang und mühsam zu
tippen, und sie müssen immer absolut richtig sein.  Wenn
derselbe Befehl mehrere Male benutzt werden muss, lohnt
es sich oft schon, eine Variable zu definieren, in der er
sich befindet.

Als Beispiel sollen einige Worte im
Gesangstext fett und kursiv hervorgehoben werden.
Die Befehle @code{\italic} und @code{\bold} funktionieren
im Gesangstext-Kontext nur, wenn sie gleichzeitig mit den Wörtern,
auf die sie angewendet werden sollen, zusätzlich
in eine @code{\markup}-Umgebung eingeschlossen
werden. Durch diese Einbettung können einzelne Wörter nicht
einfach zu einer Variable umgeformt werden.  Als
Alternative versuchen wir, einen Befehl mit
@code{\override} und @code{\revert} zu konstruieren.

@example
@code{\override Lyrics . LyricText #'font-shape = #'italic}
@code{\override Lyrics . LyricText #'font-series = #'bold}

@code{\revert Lyrics . LyricText #'font-shape}
@code{\revert Lyrics . LyricText #'font-series}
@end example

Das wäre natürlich noch viel mühsamer, wenn viele Wörter eine
Hervorhebung benötigen.  Anstelle dieser Befehlsketten @emph{können}
wir jedoch zwei Variablen definieren.  Mit ihnen und dem entsprechenden
Wort in geschweiften Klammern erreichen wir den gewünschten Effekt.
Ein weiterer Vorteil ist, dass in diesem Fall die Leerzeichn um die
Punkte herum nicht benötigt werden, weil sie nicht innerhalb des
@code{lyricmode}-Kontextes interpretiert werden.  Hier ein Beispiel;
die Bezeichnungen können natürlich auch kürzer sein,
um noch weniger schreiben zu müssen:

@cindex LyricText, Beispiel zur Veränderung
@cindex Gesangstext, Beispiel zur Veränderung
@cindex font-shape-Eigenschaft, Beispiel
@cindex font-series-Eigenschaft, Beispiel

@lilypond[quote,verbatim]
emphasize = {
  \override Lyrics.LyricText #'font-shape = #'italic
  \override Lyrics.LyricText #'font-series = #'bold
}
normal = {
  \revert Lyrics.LyricText #'font-shape
  \revert Lyrics.LyricText #'font-series
}

global = { \time 4/4 \partial 4 \key c \major}
SopranoMusic   = \relative c' { c4 | e4. e8 g4  g  | a a g }
AltoMusic  = \relative c' { c4 | c4. c8 e4  e  | f f e }
TenorMusic = \relative c  { e4 | g4. g8 c4. b8 | a8 b c d e4 }
BassMusic  = \relative c  { c4 | c4. c8 c4  c  | f8 g a b c4 }
VerseOne   = \lyrics { E -- | ter -- nal \emphasize Fa -- ther, \normal | strong to save, }
VerseTwo   = \lyricmode { O | \emphasize Christ, \normal whose voice the | wa -- ters heard, }
VerseThree = \lyricmode { O | \emphasize Ho -- ly Spi -- rit, \normal | who didst brood }
VerseFour  = \lyricmode { O | \emphasize Tri -- ni -- ty \normal of | love and pow'r }

\score {
  \new ChoirStaff <<
    \new Staff <<
      \clef "treble"
      \new Voice = "Soprano"  { \voiceOne \global \SopranoMusic }
      \new Voice = "Alto" { \voiceTwo \AltoMusic }
      \new Lyrics \lyricsto "Soprano" { \VerseOne   }
      \new Lyrics \lyricsto "Soprano" { \VerseTwo   }
      \new Lyrics \lyricsto "Soprano" { \VerseThree }
      \new Lyrics \lyricsto "Soprano" { \VerseFour  }
    >>
    \new Staff <<
      \clef "bass"
      \new Voice = "Tenor" { \voiceOne \TenorMusic }
      \new Voice = "Bass"  { \voiceTwo \BassMusic  }
    >>
  >>
}
@end lilypond


@node Mehr Information
@subsection Mehr Information
@translationof Other sources of information

Die Programmreferenz enthält sehr viel Information über LilyPond, aber 
noch mehr Information findet sich in den internen 
LilyPond-Dateien.  Um sie erforschen zu können, müssen Sie erst
das richtige Verzeichnis auf Ihrem System finden.  Die Position
hängt a) davon ab, ob Ihre LilyPond-Installation mit der vorkompilierten
Version von der LilyPond-Internetseite vorgenommen wurde oder Sie
die Version durch Ihren Paketmanager installiert haben (also
z. B. in einer Linux-Distribution oder unter fink oder cygwin
installiert), und b) auf welchem Betriebssystem Sie das Programm
benutzen:

@strong{Von lilypond.org heruntergeladen}

@itemize @bullet
@item Linux

Wechseln Sie in das Verzeichnis
@file{@var{INSTALL_VERZ}/lilypond/usr/share/lilypond/current/}

@item MacOS X

Wechseln Sie in das Verzeichnis
@file{@var{INSTALL_VERZ}/LilyPond.app/Contents/Resources/share/lilypond/current/}
indem Sie entweder mit dem Befehl @code{cd} vom Terminal aus
in das Verzeichnis wechseln, oder mit Control-Klick auf das
LilyPond-Programmsymbol gehen und @qq{Show Package Contents}
auswählen.

@item Windows

Wechseln Sie mit dem Windows Explorer ins Verzeichnis
@file{@var{INSTALL_VERZ}/LilyPond/usr/share/lilypond/current/}

@end itemize

@strong{Mit einem Paket-Manager installiert oder selber aus
den Quellen kompiliert}

Wechseln Sie in das Verzeichnis
@file{@var{PREFIX}/share/lilypond/@var{X.Y.Z}/}, wobei
@var{PREFIX} bei Ihrem Paket-Manager oder dem
@code{configure}-Skript gesetzt wird, und @var{X.Y.Z}
die LilyPond-Versionsnummer.

@smallspace

In diesem Ordner sind die zwei interessanten Unterordner:

@itemize
@item @file{ly/} - beinhaltet Dateien im LilyPond-Format
@item @file{scm/} - beinhaltet Dateien im Scheme-Format
@end itemize

Schauen wir uns zuerst einige Dateien in @file{ly/} an.
Öffnen Sie @file{ly/property-init.ly} in einem Texteditor.
Der, den Sie normalerweise für @code{.ly}-Dateien benutzen,
genügt.  Diese Datei enthält die Definitionen aller vordefinierten
Befehle für LilyPond, wie etwa @code{\stemUp} und
@code{\slurDotted}.  Sie können sehen, dass es sich um
nichts mehr handelt als Definitionen von Variablen, die eine
oder mehrere @code{\override}-Befehle enthalten.  Der
Befehl @code{/tieDotted} etwa wird folgendermaßen definiert:

@example
tieDotted = @{
  \override Tie #'dash-period = #0.75
  \override Tie #'dash-fraction = #0.1
@}
@end example

Wenn Sie diese Voreinstellungen der vordefinierten Befehl nicht
mögen, können Sie sie ganz einfach umdefinieren, genauso wie
jede andere Variable auch, indem Sie sie an den Anfang Ihrer
Quelldatei schreiben.

Hier sind die wichtisgsten Dateien, die sich im Ordner
@file{ly/} befinden:

@multitable @columnfractions .4 .6
@headitem Dateiname
  @tab Inhalt
@item @file{ly/engraver-init.ly}
  @tab Definitionen von Engraver-Kontexten
@item @file{ly/paper-defaults-init.ly}
  @tab Spezifikationen von Voreinstellungen für Papiermaße
@item @file{ly/performer-init.ly}
  @tab Definitionen von Performer-Kontexten
@item @file{ly/property-init.ly}
  @tab Definitionen aller vordefinierten Befehle
@item @file{ly/spanner-init.ly}
  @tab Definitionen aller vordefinierten Strecker-Befehle
@end multitable

Andere Einstellungen (wie die Definitionen von Beschriftungsbefehlen)
sind in @code{.scm}-(Scheme)-Dateien gespeichert.  Die
Scheme-Programmiersprache wird benutzt, um eine
programmierbare Schnittstelle zu den internen Operationen von
LilyPond zu haben.  Eine weitere Erklärung dieser Dateien ist
im Moment außerhalb des Rahmens dieses Handbuchs, denn
sie erfordern einige Kenntnis der Scheme-Sprache.  Die Warnung
ist hier angebracht, dass des ein gutes technisches Verständnis
oder sehr viel Zeit braucht, um Scheme und diese
Dateien zu verstehen (siehe auch @ref{Scheme-Übung}).

Wenn Sie sich mit Scheme auskennen, sind hier mögliche
interessante Dateien:

@multitable @columnfractions .4 .6
@headitem Dateiname
  @tab Inhalt
@item @file{scm/auto-beam.scm}
  @tab Sub-Balken-Voreinstellungen
@item @file{scm/define-grobs.scm}
  @tab Voreinstellungen für Grob-Eigenschaften
@item @file{scm/define-markup-commands.scm}
  @tab Definition aller Markup-Beschriftungsbefehle
@item @file{scm/midi.scm}
  @tab Voreinstellung für die MIDI-Ausgabe
@item @file{scm/output-lib.scm}
  @tab Einstellungen mit Einfluss auf die Darstellung von Bunddiagrammen, Farben, Versetzungszeichen, Taktlinien usw.
@item @file{scm/parser-clef.scm}
  @tab Definitionen der unterstützten Schlüssel
@item @file{scm/script.scm}
  @tab Voreinstellungen for Artikulationszeichen
@end multitable


@node Vermeiden von Optimierungen durch langsamere Übersetzung
@subsection Vermeiden von Optimierungen durch langsamere Übersetzung
@translationof Avoiding tweaks with slower processing

LilyPond kann einige zusätzliche Tests durchführen, während 
die Noten gesetzt werden.  Dadurch braucht das Programm länger, 
um den Notensatz zu produzieren, aber üblicherweise werden 
weniger nachträgliche Anpassungen nötig sein.  Wenn eine
Textsilbe oder eine Beschriftung aus dem Rand der Partitur
ragt, wird durch diese Tests die Zeile gerade so weit komprimiert,
dass sie sich innerhalb der Ränder befindet.

@example
\new Score \with @{
 %  Um sicher zu gehen, dass Texte und Liedtext 
 %  innerhalb der Papierränder bleiben
 \override PaperColumn #'keep-inside-line = ##t
 \override NonMusicalPaperColumn #'keep-inside-line = ##t
@} @{
   ...
@}
@end example


@node Fortgeschrittene Optimierungen mit Scheme
@subsection Fortgeschrittene Optimierungen mit Scheme
@translationof Advanced tweaks with Scheme

Auch wenn viele Sachen mit @code{\override} und @code{\tweak}
möglich sind, gibt es eine sehr viel mächtigere Möglichkeit, die
Arbeitsweise von LilyPond mit Hilfe der programmierbaren Schnittstelle
zu beeinflussen.  Code, der in der Scheme-Programmiersprache
geschrieben ist, kann direkt in die interne Satzmaschine von LilyPond
eingefügt werden.  Natürlich brauchen Sie dazu wenigstens ein
grundlegendes Verständnis von Scheme.  Eine Einleitung finden
Sie in der @ref{Scheme-Übung}.

Zur Illustration der vielen Möglichkeiten soll gezeigt werden, dass eine
Eigenschaft nicht nur auf eine Konstante, sondern auch auf eine
Scheme-Prozedur gesetzt werden kann, die dann jedes Mal
aufgerufen wird, wenn die Eigenschaft von LilyPond benutzt
wird.  Die Eigenschaft kann damit dynamisch auf einen Wert
gesetzt werden, der durch die Prozedur jedes Mal neu bestimmt
wird.  In diesem Beispiel wird die Farbe der Notenköpfe entsprechend
zu ihrer Position innerhalb der Tonleiter gesetzt.

@cindex x11-Farben, Beispiel zur Benutzung
@cindex Notenkopf, Beispiel zur Veränderung
@cindex Farb-Eigenschaft, in Scheme-Prozedur gesetzt

@lilypond[quote,verbatim,ragged-right]
#(define (color-notehead grob)
  "Color the notehead according to its position on the staff."
  (let ((mod-position (modulo (ly:grob-property grob 'staff-position) 7)))
    (case mod-position
      ;;   Return rainbow colors
      ((1) (x11-color 'red    ))  ; for C
      ((2) (x11-color 'orange ))  ; for D
      ((3) (x11-color 'yellow ))  ; for E
      ((4) (x11-color 'green  ))  ; for F
      ((5) (x11-color 'blue   ))  ; for G
      ((6) (x11-color 'purple ))  ; for A
      ((0) (x11-color 'violet ))  ; for B
    )
  )
)

\relative c' {
  % Arrange to obtain color from color-notehead procedure
  \override NoteHead #'color = #color-notehead
  c2 c' |
  b4 g8 a b4 c |
  c,2 a' |
  g1 |
}
\addlyrics {
  Some -- where o -- ver the Rain -- bow, way up high,
}
@end lilypond

Weiter Beispiele, die die Benutzung dieser programmierbaren
Schnittstelle zeigen, finden sich in @ref{Optimierungen mit Scheme}.
