@c -*- coding: utf-8; mode: texinfo; documentlanguage: ja -*-

@ignore
    Translation of GIT committish: 499a511d4166feaada31114e097f86b5e0c56421

    When revising a translation, copy the HEAD committish of the
    version that you are working on.  For details, see the Contributors'
    Guide, node Updating translation committishes..
@end ignore

@c \version "2.12.0"


@c Translators: Yoshiki Sawada
@c Translation status: post-GDP


@node 出力を調整する
@chapter 出力を調整する
@translationof Tweaking output

この章では出力を変更する方法について議論します。LilyPond は本当にさまざまな設@c
定が可能です。もしかすると出力のすべての部分が変更されるかもしれません。

@menu
* 調整の基本::
* 内部リファレンス マニュアル::
* オブジェクトの見た目::
* オブジェクトの配置::
* オブジェクトの衝突::
* 更なる調整::
@end menu

@node 調整の基本
@section 調整の基本
@translationof Tweaking basics


@menu
* 調整の紹介::
* オブジェクトとインタフェイス::
* オブジェクトとプロパティの命名規約::
* 調整手段::
@end menu


@node 調整の紹介
@subsection 調整の紹介
@translationof Introduction to tweaks

@q{調整} は入力ファイルの解釈中にとられるアクションを変更し、譜刻される音楽の@c
見た目を変更するためにユーザが利用可能なさまざまな手段を指す LilyPond の@c
用語です。@c
いくつかの調整はとても簡単に使うことができます。@c
他の調整はもっと複雑です。@c
しかしながら、調整のために利用可能な手段を組み合わせることによって、@c
ほとんどいかなる望みの見た目を持った楽譜でも譜刻することが可能になります。

このセクションでは、調整を理解するのに必要な基礎となるコンセプトを@c
カバーします。@c
その後、コピーするだけで効果が得られる作成準備が完了している@c
さまざまなコマンドについての情報を提供し、同時に、あなたがあなた自身の調整を@c
開発する方法を学べるようにそれらのコマンドがどのように構築されるのかを示します。

この章を読み始める前に、あなたは @ref{コンテキストとエングラーバ} を@c
再読することを望むかもしれません。@c
なぜなら、コンテキスト、エングラーバとそれらの中に含まれるプロパティは@c
調整について理解し、調整を構成するための基礎だからです。


@node オブジェクトとインタフェイス
@subsection オブジェクトとインタフェイス
@translationof Objects and interfaces

@cindex object (オブジェクト)
@cindex grob (グラフィカル オブジェクト)
@cindex spanner (スパナ)
@cindex interface (インタフェイス)
@cindex properties, object (オブジェクト プロパティ)
@cindex object properties (オブジェクト プロパティ)
@cindex layout object (レイアウト プロパティ)
@cindex object, layout (レイアウト プロパティ)

調整には LilyPond プログラムの内部オペレーションと構造体への変更も含まれます。@c
そのため、我々はまずそれらの内部オペレーションと構造体を記述するために@c
使用されるいくつかの用語を導入しなければなりません。

@q{オブジェクト} という用語は入力ファイルを処理している最中に LilyPond に@c
よってビルドされる多くの内部構造体を参照するために使われる汎用的な用語です。@c
LilyPond が @code{@bs{}new Staff} のようなコマンドに遭遇した場合、@c
タイプ @code{Staff} の新しいオブジェクトを構築します。@c
その @code{Staff} オブジェクトは、その譜表のコンテキスト内部で機能するために@c
割り当てられているエングラーバの詳細とともに、その譜表に関連付けられている@c
すべてのプロパティ -- 例えば、その譜表の名前、調号 -- を保持します。@c
同様に、@code{Voice} オブジェクト、@code{Score} オブジェクト、@c
@code{Lyrics} オブジェクトなどの他のすべてのコンテキストのプロパティを@c
保持するためのオブジェクトが存在し、さらに、小節線、符頭、タイ、強弱記号などの@c
すべての記譜要素を表すためのオブジェクトも存在します。@c
各オブジェクトはそれ自体のプロパティ値のセットを持ちます。

いくつかのタイプのオブジェクトには特別な名前が与えられています。@c
符頭、符幹、スラー、タイ、運指記号、音部記号などの譜刻される出力上の記譜要素を@c
表すオブジェクトは @q{レイアウト オブジェクト} と呼ばれ、@c
しばしば @q{グラフィカル オブジェクト} 
あるいは短くして @q{グロッブ (Grob: GRaphical OBject)} と呼ばれます。@c
これらのオブジェクトも上記の汎用的な観点から見るとオブジェクトであり、@c
それゆえ、それらもまたそれらのオブジェクトに関連付けされたプロパティ -- 
そのオブジェクトの位置、サイズ、色など -- を持ちます。

いくつかのレイアウト オブジェクトも特別です。@c
フレージング スラー、クレッシェンド、オッターバ (訳者: オクターブ？) 記号、@c
他の多くのグラフィカル オブジェクトが置かれる場所は一点ではありません -- 
それらは開始点、終了点、そしておそらくそれらの形に関係する他のプロパティを@c
持ちます。@c
これらのオブジェクトのように形が伸長されるオブジェクトは 
@q{スパナ (Spanners)} と呼ばれます。

@q{インタフェイス} とは何なのかという説明が残っています。@c
多くのオブジェクト -- たとえそれらが非常に異なっていたとしても -- 
は同じ方法で処理される必要がある共通特徴 (common feature) を共有します。@c
例えば、すべてのグラフィカル オブジェクトは色、サイズ、位置などを持ち、@c
これらのプロパティはすべて LilyPond が入力ファイルを構文解釈する最中に@c
同じ方法で処理されます。@c
これらの内部オペレーションを簡潔にするために、これらの共通アクションと@c
プロパティは 1 つのグループとして 
@code{grob-interface} と呼ばれるオブジェクトにまとめられています。@c
これと同じような共有プロパティのグループ化が他にも多くあり、@c
それぞれに対して最後に @code{interface} が付く名前が与えられています。@c
そのようなインタフェイスの総数は 100 を越えます。@c
我々は後でなぜこれがユーザにとって利益となり、役に立つのかを見ていきます。

これらは、我々がこの章で使用するオブジェクトと関係する主要な用語です。


@node オブジェクトとプロパティの命名規約
@subsection オブジェクトとプロパティの命名規約
@translationof Naming conventions of objects and properties


@cindex naming conventions for objects (オブジェクトの命名規則)
@cindex naming conventions for properties (プロパティの命名規則)
@cindex objects, naming conventions (オブジェクトの命名規則)
@cindex properties, naming conventions (プロパティの命名規則)

我々は以前にも @ref{コンテキストとエングラーバ} で@c
いくつかのオブジェクト命名規約を見てきました。@c
ここで参照のために、最も一般的なオブジェクトとプロパティをリストアップし、@c
それに加えてそれらの命名規約と実際の名前の例を挙げます。@c
何らかの大文字のアルファベットを表すために @q{A} を使用し、@c
いくつかの小文字のアルファベットを表すために @q{aaa} を使用しています。@c
他の文字は実際の命名でもそのまま使用されます。

@multitable @columnfractions .33 .33 .33
@headitem オブジェクト/プロパティのタイプ
  @tab 命名規約
  @tab 例
@item コンテキスト
  @tab Aaaa や AaaaAaaaAaaa
  @tab Staff, GrandStaff
@item レイアウト オブジェクト
  @tab Aaaa や AaaaAaaaAaaa
  @tab Slur, NoteHead
@item エングラーバ
  @tab Aaaa_aaa_engraver
  @tab Clef_engraver, Note_heads_engraver
@item インタフェイス
  @tab aaa-aaa-interface
  @tab grob-interface, break-aligned-interface
@item コンテキスト プロパティ
  @tab aaa や aaaAaaaAaaa
  @tab alignAboveContext, skipBars
@item レイアウト オブジェクト プロパティ
  @tab aaa や aaa-aaa-aaa
  @tab direction, beam-thickness
@end multitable

これから見ていくのですが、タイプが異なるオブジェクトのプロパティは@c
異なるコマンドによって変更されます。@c
そのため、プロパティの名前からオブジェクトの種類を識別できるようになると@c
役に立ちます。


@node 調整手段
@subsection 調整手段
@translationof Tweaking methods

@cindex tweaking methods (調性手段)

@strong{@bs{}override コマンド}

@cindex override command (override コマンド)
@cindex override syntax (override 構文)

@funindex \override
@funindex override

我々はすでに @ref{コンテキスト プロパティを変更する} と 
@ref{エングラーバを追加 / 削除する} で@strong{コンテキスト}のプロパティを@c
変更したり、@strong{エングラーバ}を追加/削除したりするために使用するコマンド 
@code{@bs{}set} と @code{@bs{}with} を見てきました。@c
ここでは更に重要ないくつかのコマンドについて見ていきます。

@strong{レイアウト オブジェクト}のプロパティを変更するためのコマンドは 
@code{@bs{}override} です。このコマンドは LilyPond の奥深くにある@c
内部プロパティを変更しなければならないため、これまで見てきたコマンドのように@c
単純な構文ではありません。@c
どのコンテキストの中にあるどのオブジェクトのどのプロパティを@c
変更しなければならないのか、そこにセットする新しい値を何にするのかを@c
正確に知っている必要があります。@c
どのようにこれを行うのかを見ていきましょう。

このコマンドの一般的な構文は以下のようなものです:

@example
@bs{}override @var{Context}.@var{LayoutObject} #'@var{layout-property} =
#@var{value}
@end example

@noindent
これは @var{Context} コンテキストのメンバである 
@var{LayoutObject} という名前のレイアウトの 
@var{layout-property} という名前のプロパティに値 @var{value} をセットします。

必要とされているコンテキストが明白であり、それが最下位レベルの@c
コンテキストである -- @c
つまり、@code{Voice}, @code{ChordNames} や @code{Lyrics} である -- 場合、@c
その @var{Context} は省略可能可能であり (そして通常は省略されます)、@c
この後の例の多くでも省略します。@c
後ほど、コンテキストを指定しなければならない場合について見ていきます。

これから後のセクションでは広範囲に亘るプロパティとそれらの値を扱います。@c
しかしながら、そのフォーマットとそれらのコマンドの使用方法を示すためには、@c
容易に理解できる簡単なプロパティと値を 2, 3 使用してみるだけです。

今や、レイアウト プロパティの前に置かれなければならない @code{#'} や@c
プロパティ値の前に置かれなければならない @code{#} について心配する必要は@c
ありません。@c
これらは常にそのような形式で正確に記述されなければなりません。@c
これは調整では最も一般的に使用されるコマンドであり、この章の残りの部分の@c
大半ではプロパティ (変更コマンド) の使用方法を示すための例を記述しています。@c
ここでは符頭の色を変更する簡単な例を挙げます:


@cindex color property, example (color プロパティの例)
@cindex NoteHead, example of overriding (NoteHead をオーバライドする例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
c d
\override NoteHead #'color = #red
e f g
\override NoteHead #'color = #green
a b c
@end lilypond


@strong{@bs{}revert コマンド}

@cindex revert command (revert コマンド)

@funindex \revert
@funindex revert

一旦オーバライドされると、そのプロパティは再度オーバライドされるか 
@code{@bs{}revert} コマンドに遭遇するまで新しい値のままでいます。@c
@code{@bs{}revert} コマンドは以下の構文を持ち、@c
プロパティの値をオリジナルのデフォルト値に戻します。@c
何度か @code{@bs{}override} コマンドが発行されている場合は、@c
前の値に戻すわけではないということに注意してください。


@example
@bs{}revert @var{Context}.@var{LayoutObject} #'@var{layout-property}
@end example

繰り返しますが、@code{@bs{}override} コマンドでの @var{Context} と同様に、@c
多くの場合で @var{Context} を記述する必要はありません。@c
以下の例の多くで、@var{Context} は省略されます。@c
ここでは、最後の 2 つの音符の符頭の色をデフォルトに戻します:

@cindex color property, example (color プロパティの例)
@cindex NoteHead, example of overriding (NoteHead をオーバライドする例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
c d
\override NoteHead #'color = #red
e f g
\override NoteHead #'color = #green
a
\revert NoteHead #'color
b c
@end lilypond

@strong{@bs{}once prefix}

@funindex \once
@funindex once

@code{@bs{}override} コマンドと @code{@bs{}set} コマンドには両方とも@c
接頭辞 @code{@bs{}once} が付く可能性があります。@c
これはその後に続く @code{@bs{}override} や @code{@bs{}set} コマンドを@c
その場一回限り有効にし、その後にそのプロパティの値をデフォルト値に戻します。@c
上と同じ例を使って、以下のように 1 つだけの音符の色を変更することができます:

@cindex color property, example (color プロパティの例)
@cindex NoteHead, example of overriding (NoteHead をオーバライドする例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
c d
\once \override NoteHead #'color = #red
e f g
\once \override NoteHead #'color = #green
a b c
@end lilypond

@strong{@bs{}overrideProperty コマンド}

@cindex overrideProperty command (overrideProperty コマンド)

@funindex \overrideProperty
@funindex overrideProperty

オーバライド コマンドには @code{@bs{}overrideProperty} という@c
もう 1 つのフォーマットがあり、時々必要となります。@c
完璧を期すためにここでこれに言及しましたが、@c
詳細は @ruser{Difficult tweaks} を参照してください。
@c Maybe explain in a later iteration  -td

@strong{@bs{}tweak コマンド}

@cindex tweak command (tweak コマンド)

@funindex \tweak
@funindex tweak

利用可能な最後の調整コマンドは @code{@bs{}tweak} です。@c
これは同じタイミングで起こるオブジェクト -- 和音の中にある音符などのように -- 
のプロパティを変更するために使用されます。@c
@code{@bs{}override} コマンドを使用すると和音の中にあるすべての音符に@c
影響を与えます。@c
一方、@code{@bs{}tweak} は入力ストリームの中でその @code{@bs{}tweak} の@c
すぐ後にある要素 1 つだけに影響を与えます。

ここで例を挙げます。@c
C メジャー コードの中にある真ん中の音符 (ミドル E) の符頭のサイズを@c
変更したいとします。@c
まず最初に、@code{@bs{}once @bs{}override} だとどうなるか見てみましょう:

@cindex font-size property, example (font-size プロパティの例)
@cindex NoteHead, example of overriding (NoteHead をオーバライドする例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
  <c e g>4
  \once \override NoteHead #'font-size = #-3
  <c e g>
  <c e g>
@end lilypond

このオーバライドは和音の中にある@emph{すべて}の符頭に影響を与えています。@c
これは和音の中にあるすべての音符が同じ@emph{タイミング}で起こるためであり、@c
@code{@bs{}once} のアクションは @code{@bs{}override} と同様に同じタイミングで@c
起こる、指定されたタイプすべてのレイアウト オブジェクトへのオーバライドに@c
適用されます。

@code{@bs{}tweak} コマンドはこれとは異なるやり方で処理されます。@c
これは入力ストリームの中ですぐ後に続く要素にだけ作用します。@c
しかしながら、これは入力ストリームから直接作成されるオブジェクト -- 
本質的に符頭とアーティキュレーション -- にだけ効果を持ちます。@c
符幹や臨時記号などのオブジェクトは後で作成されるため、@c
この方法では調整できません。@c
さらに、@code{@bs{}tweak} が符頭に適用される場合、@c
それらは和音の内部になければ@emph{なりません} -- 
つまり、単一山括弧 @code{< .. >} の内部です。@c
そのため、単一の音符 (和音ではない音符) を調整するには、@c
@code{@bs{}tweak} コマンドはその音符とともに@c
単一の山括弧で囲わなければなりません。

それでは例に戻り、この方法で和音の真ん中の音符のサイズを変更します:

@cindex font-size property, example (font-size プロパティの例)
@cindex @code{@bs{}tweak}, example (@code{@bs{}tweak} の例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
  <c e g>4
  <c \tweak #'font-size #-3 e g>4
@end lilypond

@code{@bs{}tweak} の構文は @code{@bs{}override} コマンドの構文とは@c
異なるということに注意してください。@c
コンテキストもレイアウト オブジェクトも指定されません。@c
実際、それらを指定するとエラーになります。@c
これらは両方とも入力ストリームの中で後に続く要素によって示されます。@c
さらに、イコール記号を使うべきではないということに注意してください。@c
そのため、@code{@bs{}tweak} コマンドの一般的な構文は単純に以下のようになります:

@example
@bs{}tweak #'@var{layout-property} #@var{value}
@end example

さらに、@code{@bs{}tweak} コマンドは一連のアーティキュレーションの中にある@c
ただ 1 つのアーティキュレーションを変更されるためにも使用できます。@c
ここに例を挙げます:

@cindex color property, example (color プロパティの例)
@cindex @code{@bs{}tweak}, example (@code{@bs{}tweak} の例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
a ^Black
  -\tweak #'color #red ^Red
  -\tweak #'color #green _Green
@end lilypond

@noindent
@code{@bs{}tweak} コマンドは、まるでそれがアーティキュレーションの@c
一部であるかのように、アーティキュレーション マークの前に@c
置かれなければならないということに注意してください。

@cindex tuplets, nested (ネストされた連符)
@cindex triplets, nested (ネストされた 3 連符)
@cindex bracket, tuplet (連符の囲み)
@cindex bracket, triplet (3 連符の囲み)
@cindex tuplet bracket (連符の囲み)
@cindex triplet bracket (3 連符の囲み)

@funindex TupletBracket

さらに、@code{@bs{}tweak} コマンドは、同時に起こるネストされた@c
連符記号のセットのうちの 1 つの見た目を変更するためにも使用されます。@c
以下の例では、長い連符記号と 3 つの短い連符記号のうちの最初の連符記号が@c
同時に起こります。@c
そのため、@code{@bs{}override} コマンドだと両方の連符記号に@c
適用されてしまいます。@c
この例では、@code{@bs{}tweak} は 2 つの連符記号を区別するために@c
使用されています。@c
最初の @code{@bs{}tweak} コマンドは長い連符記号を音符の上に置くことを@c
指定していて、2 番目の @code{@bs{}tweak} コマンドは最初の短い連符記号の数字を@c
赤で描くことを指定しています。

@cindex @code{@bs{}tweak}, example (@code{@bs{}tweak} の例)
@cindex direction property, example (direction プロパティの例)
@cindex color property, example (color プロパティの例)

@lilypond[quote,ragged-right,verbatim,fragment,relative=2]
\tweak #'direction #up
\times 4/3 {
  \tweak #'color #red
  \times 2/3 { c8[ c8 c8] }
  \times 2/3 { c8[ c8 c8] }
  \times 2/3 { c8[ c8 c8] }
}
@end lilypond

ネストされた連符が同時に起こらない場合、それらの見た目は @code{@bs{}override} 
コマンドを用いた通常通りの方法で変更されるかもしれません:

@cindex text property, example (text プロパティの例)
@cindex tuplet-number function, example (tuplet-number 関数の例)
@cindex transparent property, example (transparent プロパティの例)
@cindex TupletNumber, example of overriding (TupletNumber をオーバライドする例)

@c NOTE Tuplet brackets collide if notes are high on staff
@c See issue 509
@lilypond[quote,ragged-right,verbatim,fragment,relative=1]
\times 2/3 { c8[ c c]}
\once \override TupletNumber
  #'text = #tuplet-number::calc-fraction-text
\times 2/3 {
  c[ c]
  c[ c]
  \once \override TupletNumber #'transparent = ##t
  \times 2/3 { c8[ c c] }
\times 2/3 { c8[ c c]}
}
@end lilypond


@seealso
記譜法リファレンス:
@ruser{The tweak command}


@node 内部リファレンス マニュアル
@section 内部リファレンス マニュアル
@translationof The Internals Reference manual


@menu
* レイアウト オブジェクトのプロパティ::
* インタフェイスの中で見つかるプロパティ::
* プロパティのタイプ::
@end menu

@node レイアウト オブジェクトのプロパティ
@subsection レイアウト オブジェクトのプロパティ
@translationof Properties of layout objects

@cindex properties of layout objects (レイアウト オブジェクトのプロパティ)
@cindex properties of grobs (グラフィカル オブジェクトのプロパティ)
@cindex grobs, properties of (グラフィカル オブジェクトのプロパティ)
@cindex layout objects, properties of (レイアウト オブジェクトのプロパティ)
@cindex Internals Reference manual (内部リファレンス マニュアル)

あなたがスラーを楽譜に描き、そのスラーが細すぎるためにもう少し太くしたいと@c
思ったとします。@c
どうやってスラーを太くしますか？@c
以前に LilyPond の自由度の高さについて述べたので、@c
そのようなことが可能であることは知っています。@c
あなたはおそらく @code{@bs{}override} コマンドが必要であると推測するでしょう。@c
しかしながら、スラーの太さプロパティは存在するのでしょうか？@c
そして、それが存在するならどうやって変更するのでしょうか？@c
このようなことに内部リファレンス マニュアルは触れています。@c
内部リファレンス マニュアルには、あなたがスラーを太くするために必要な情報、@c
他のすべての @code{@bs{}override} コマンドを構築するために必要な情報が@c
含まれています。

内部リファレンスを見ていく前に一言警告です。@c
これは@strong{リファレンス} ドキュメントであり、@c
説明はほんの少しかまったく含まれていません: 
リファレンスの目的は情報を正確に、かつ簡潔に提供することです。@c
そのため、内部リファレンスを一見してひるんでしまうかもしれません。@c
しかし、心配しないでください！@c
ここにあるガイダンスと説明を読めば、少し練習するだけで、@c
内部リファレンスから必要な情報を取り出せるようになります。

@cindex override example (オーバライドの例)
@cindex Internals Reference, example of using (内部リファレンスの使用例)
@cindex @code{@bs{}addlyrics} example (@code{@bs{}addlyrics} の例)

実際の音楽からの簡単な断片を持つ具体例を使用していきましょう:

@lilypond[quote,verbatim,relative=2]
{
  \time 6/8
  {
    r4 b8 b[( g]) g |
    g[( e]) e d[( f]) a |
    a g
  }
  \addlyrics {
    The man who feels love's sweet e -- mo -- tion
  }
}
@end lilypond

ここで、スラーをもう少し太くしようと決めたことにします。@c
それは可能でしょうか？@c
スラーは確かにレイアウト オブジェクトです。@c
そのため、その疑問は @q{スラーに属していて、太さを制御するプロパティは@c
存在するのか？} ということになります。@c
その答えを得るために内部リファレンス -- 縮めて IR -- を見なければなりません。

あなたが使用しているバージョンの LilyPond のための内部リファレンスは 
LilyPond ウェブサイト @uref{http://lilypond.org} で見つかるでしょう。@c
ドキュメント ページに行き、内部リファレンスへのリンクをクリックしてください。@c
学習目的のためには標準の HTML バージョンを使うべきであり、@c
@q{one big page} (@q{大きな 1 ページにまとめたもの}) や PDF を@c
使うべきではありません。@c
次の数段落を読めば、あなたが内部リファレンスを読むときに@c
実際にすべきことがわかるでしょう。

内部リファレンスの@strong{トップ ページ}下には 5 つのリンクがあります。@c
@emph{バックエンド} へのリンクを選択してください。@c
そこにはレイアウト オブジェクトについての情報があります。@c
@strong{バックエンド} 下にある @emph{すべてのレイアウト オブジェクト} への@c
リンクを選択してください。@c
そのページには、あなたが使用しているバージョンの LilyPond で使用される@c
すべてのレイアウト オブジェクトがアルファベット順で@c
リストアップされています。@c
Slur へのリンクを選択すると、Slur のプロパティがリスト アップされます。

記譜法リファレンスからこのページを見つける方法もあります。@c
スラーについて扱っているページで、内部リファレンスへのリンクが@c
見つかるかもしれません。@c
このリンクでこのページに直接行くことができます。@c
しかしながら、あなたが調整するレイアウト オブジェクトの名前を@c
想像できる場合は、すぐに内部リファレンスに行ってそこで探す方が簡単です。

内部リファレンスの Slur ページでは、まず Slur オブジェクトは 
@code{Slur_engraver} によって作成されるということが述べられています。@c
それから、標準設定がをリストアップされています。@c
標準設定はアルファベット順にはなって@strong{いない}ということに@c
注意してください。@c
太さを制御していそうなプロパティを探してブラウザを@c
スクロール ダウンさせていくと、以下が見つかります:

@example
@code{thickness} (number)
     @code{1.2}
     Line thickness, generally measured in @code{line-thickness}
@end example

これが太さを変更するプロパティのようです。@c
@code{thickness} の値は@emph{数}であり、デフォルト値は 1.2、@c
この値は他のプロパティでは @code{line-thickness} と@c
呼ばれるということがわかります。

前にも言ったように、内部リファレンスには説明がほとんど、@c
あるいはまったくありません。@c
しかしながら、すでにスラーの太さを変えるための十分な情報を持っています。@c
レイアウト オブジェクトの名前は @code{Slur} であり、変更するプロパティの名前は 
@code{thickness} であり、スラーをもっと太くするには@c
新しい値を 1.2 よりも大きくすべきであることがわかります。

今度は、レイアウト オブジェクト名で見つけた値を置き換えることによって 
@code{@bs{}override} コマンドを構築することができます。@c
コンテキストは省略します。@c
最初は太さに非常に大きな値を割り当ててみます。@c
それによって、そのコマンドが確かに機能していることを確かめることができます。@c
実行するコマンドは以下のようになります:

@example
@bs{}override Slur #'thickness = #5.0
@end example

プロパティ名の前に @code{#'} を付けること、@c
新しい値の前に @code{#} を付けることを忘れないでください！

最後の疑問は @q{このコマンドをどこに置くべきか？} ということです。@c
そのことについて不確かであり、学んでいる最中であるのならば、@c
ベストな答えはこうです @q{音楽表記の内部で、最初のスラーの直前}。@c
ではやってみましょう:

@cindex Slur example of overriding (Slur をオーバライドする例)
@cindex thickness property, example (thickness プロパティの例)

@lilypond[quote,verbatim,relative=2]
{
  \time 6/8
  {
    % Increase thickness of all following slurs from 1.2 to 5.0
    \override Slur #'thickness = #5.0
    r4 b8 b[( g]) g |
    g[( e]) e d[( f]) a |
    a g
  }
  \addlyrics {
    The man who feels love's sweet e -- mo -- tion
  }
}
@end lilypond

@noindent
確かにスラーが太くなっています。

これが @code{@bs{}override} コマンドを構築する基本的な方法です。@c
これより後のセクションで遭遇するものはもう少し複雑ですが、@c
必要な要点はすべて知っています -- しかしながら、まだ練習が必要でしょう。@c
これは以下の例で提供されます。


@subheading コンテキストを見つけ出す

@cindex context, finding (コンテキストを見つけ出す)
@cindex context, identifying correct (正しいコンテキストを特定する)

しかしながら、まず最初にコンテキストを指定しなければならないとしたら@c
どうでしょうか？@c
指定すべきコンテキストは何でしょうか？@c
スラーとボイスは音楽表記の各行で明らかに関係が深いので、@c
スラーは @code{Voice} コンテキストの中にあると推測できるかもしれません。@c
しかし、それは確かでしょうか？@c
この問題を解決するには、Slur について記述している内部リファレンス ページの@c
先頭に戻ります。@c
そこには @q{Slur オブジェクトは Slur エングラーバによって作成される} と@c
書かれています。@c
そのため、スラーは @code{Slur_engraver} が存在しているコンテキストの@c
どれかで作成されるということになります。@c
@code{Slur_engraver} へのリンクを辿ります。@c
そのページの最後の方で @code{Slur_engraver} は 5 つのボイス コンテキスト -- 
標準のボイス コンテキストである @code{Voice} を含む -- の一部であることが@c
述べられています。@c
ですから、推測は正しかったのです。@c
そして、@code{Voice} は最下位のコンテキストの 1 つである -- このことは、@c
そこに音符を入力するという事実によって明らかに示されています -- ため、@c
ここではそのコンテキストを省略することができるのです。


@subheading 1 回だけオーバライドする

@cindex overriding once only (一度だけオーバライドする)
@cindex once override (一度だけオーバライドする)

@funindex \once
@funindex once

上記の最後の例では@emph{すべて}のスラーが太くなっています。@c
しかし、最初のスラーだけを太くしたい場合はどうでしょうか？@c
これは @code{@bs{}once} コマンドを使うことによって達成されます。@c
@code{@bs{}override} コマンドの直前に @code{@bs{}once} コマンドを@c
置くことによって、@code{@bs{}override} コマンドは@strong{直後にある}音符から@c
始まるスラーだけを変更するようになります。@c
直後にある音符がスラーの開始点ではない場合、そのコマンドは@c
まったく機能しません -- それがスラーに遭遇するまで保持されるということはなく、@c
ただ切り捨てられるだけです。@c
そのため、@code{@bs{}once} コマンド付きの @code{@bs{}override} コマンドは@c
以下のように上記の例とは異なる場所に置かなくてはなりません:

@cindex Slur, example of overriding (Slur をオーバライドする例)
@cindex thickness property, example (thickness プロパティの例)

@lilypond[quote,verbatim,relative=2]
{
  \time 6/8
  {
    r4 b8
    % Increase thickness of immediately following slur only
    \once \override Slur #'thickness = #5.0
    b[( g]) g |
    g[( e]) e d[( f]) a |
    a g
  }
  \addlyrics {
    The man who feels love's sweet e -- mo -- tion
  }
}
@end lilypond

@noindent
今度は、最初のスラーだけが太くなりました。

@code{@bs{}once} コマンドは @code{@bs{}set} コマンドの前でも@c
使用される可能性があります。


@subheading 元に戻す

@cindex revert (元に戻す)
@cindex default properties, reverting to (デフォルトのプロパティに戻す)

@funindex \revert
@funindex revert

最後に、最初の 2 つだけのスラーを太くしたい場合はどうでしょうか？@c
その場合、2 つのコマンド -- それぞれの前に @code{@bs{}once} を付けた -- 
をスラーが始まる音符の直前に置きます:

@cindex Slur, example of overriding (Slur をオーバライドする例)
@cindex thickness property, example (thickness プロパティの例)

@lilypond[quote,verbatim,relative=2]
{
  \time 6/8
  {
    r4 b8
    % Increase thickness of immediately following slur only
    \once \override Slur #'thickness = #5.0
    b[( g]) g |
    % Increase thickness of immediately following slur only
    \once \override Slur #'thickness = #5.0
    g[( e]) e d[( f]) a |
    a g
  }
  \addlyrics {
    The man who feels love's sweet e -- mo -- tion
  }
}
@end lilypond

@noindent
あるいは、@code{@bs{}once} コマンドを省略して、2 番目のスラーの後に 
@code{thickness} プロパティをデフォルト値に戻すために 
@code{@bs{}revert} コマンドを使うこともできます:

@cindex Slur, example of overriding (Slur をオーバライドする例)
@cindex thickness property, example (thickness プロパティの例)

@lilypond[quote,verbatim,relative=2]
{
  \time 6/8
  {
    r4 b8
    % Increase thickness of all following slurs from 1.2 to 5.0
    \override Slur #'thickness = #5.0
    b[( g]) g |
    g[( e])
    % Revert thickness of all following slurs to default of 1.2
    \revert Slur #'thickness
    e d[( f]) a |
    a g
  }
  \addlyrics {
    The man who feels love's sweet e -- mo -- tion
  }
}
@end lilypond

@noindent
@code{@bs{}revert} コマンドは @code{@bs{}override} コマンドで@c
変更されたどのプロパティでもデフォルト値に戻すことができます。@c
状況に相応しい方を使用してください。

これで内部リファレンスと調整の基本的な方法についての紹介を終わりにします。@c
この章で後に続くセクションの中にあるいくつのかの例でも一部では、@c
内部リファレンスの特徴についての追加の紹介や、そこから情報を取り出すための@c
更なる練習を提供します。@c
それらの例ではガイダンスや説明のための言葉はずっと少ないでしょう。


@node インタフェイスの中で見つかるプロパティ
@subsection インタフェイスの中で見つかるプロパティ
@translationof Properties found in interfaces

@cindex interface (インタフェイス)
@cindex interface properties (インタフェイス プロパティ)
@cindex properties in interfaces (インタフェイス内のプロパティ)

今度は歌詞をイタリック体で譜刻したいということにします。@c
そうするには @code{@bs{}override} コマンドを@c
どのように使う必要があるのでしょうか？@c
以前と同様に、まず @q{すべてのレイアウト オブジェクト} をリストアップしている@c
内部リファレンス ページを開き、歌詞をコントロールしていそうなオブジェクトを@c
探します。@c
@code{LyricText} がそれであるようです。@c
これをクリックすると、歌詞のテキストに対してセットすることができる@c
プロパティが表示されます。@c
そこには @code{font-series} と @code{font-size} が含まれますが、@c
歌詞をイタリック体にするためのプロパティらしきものはありません。@c
これは、形に関するプロパティはすべてのフォント オブジェクトに共通なもの@c
であり、そのため、各レイアウト オブジェクトに含まれているのではなく、@c
他の同様な共通プロパティと一緒にグループ化されていて、@c
@strong{インタフェイス}の 1 つ @code{font-interface} の中に@c
置かれているからです。

そのため、インタフェイスのプロパティを見つける方法と、どのオブジェクトが@c
これらのインタフェイス プロパティを使うのかを調べる方法を学ぶ必要があります。

@code{LyricText} について記述している内部リファレンスのページを@c
再び開いてください。@c
そのページの最後に @code{LyricText} がサポートするインタフェイスへのリンクが@c
リスト アップされています。@c
そのリストには @code{font-interface} を含むいくつかの要素があります。@c
このリンクをクリックすると、このインタフェイスに@c
関連付けされているプロパティのところに行きます。@c
これらのプロパティは @code{LyricText} を含む @code{font-interface} を@c
サポートするすべてのオブジェクトのプロパティでもあります。

@code{font-shape(symbol)} を含むフォントを制御するユーザが@c
設定可能なプロパティをすべて見つけました。@c
@code{font-shape(symbol)} では @code{symbol} を @code{upright}, 
@code{italics}, あるいは @code{caps} にセットすることができます。

そこには、@code{font-series} と @code{font-size} もリスト アップされている@c
ことに気づくでしょう。@c
そこで次のような疑問が湧いてきます: 
共通フォントプロパティ @code{font-series} と @code{font-size} は 
@code{LyricText} とインタフェイス @code{font-interface} の両方で@c
リスト アップされているのに、なぜ @code{font-shape} はそうでないのか？@c
その答えは、@code{font-series} と @code{font-size} は、@c
@code{LyricText} オブジェクトが作成されるときに、@c
それらのグローバルなデフォルト値から変更されるのに対して、@c
@code{font-shape} はそうではないからです。@c
@code{LyricText} の中にあるエントリから @code{LyricText} に適用される@c
それら 2 つのプロパティの値がわかります。@c
@code{font-interface} をサポートする他のオブジェクトは、@c
それらのオブジェクトが作成されるときに、@c
それらのプロパティを異なる値にセットします。

今度は歌詞をイタリック体に変更するように @code{@bs{}override} コマンドを@c
構築できるかどうかを見ていきましょう。@c
オブジェクトは @code{LyricText} であり、@c
プロパティは @code{font-shape} であり、セットする値は @code{italic} です。@c
前と同様に、コンテキストを省略します。

話は逸れますが重要なことを 1 つ挙げます。@c
@code{font-shape} の値はシンボルなので、シングル アポストロフィ @code{'} を@c
付ける必要があるということに注意してください。@c
その理由は、以前の例での @code{thickness} や @code{font-shape} の前に@c
アポストロフィを付ける必要がある理由と同じです。@c
それらも両方ともシンボルです。@c
シンボルは LilyPond によって内部的に読み取られます。@c
それらのいくつかは @code{thickness} や @code{font-shape} のようなプロパティの@c
名前であり、他のものは @code{italic} のようにプロパティに与えられる値として@c
使用されます。@c
任意のテキスト文字列との違い -- 任意のテキスト文字列は @code{"a text string"} 
のような形で表記されます -- に注意してください。@c
シンボルと文字列についてのより詳細な説明は、@ref{Scheme チュートリアル} を@c
参照してください。

さて、それでは歌詞をイタリック体で譜刻するために必要となる 
@code{@bs{}override} コマンドは以下のようになります:

@example
\override LyricText #'font-shape = #'italic
@end example

@noindent
そして、これは以下のように影響を与える歌詞の前に、そして近くに置くべきです:

@cindex font-shape property, example (font-shape プロパティの例)
@cindex italic, example (italic の例)
@cindex LyricText, example of overriding (Lyric をオーバライドする例)
@cindex @code{\addlyrics}, example (@code{\addlyrics} の例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 6/8
  {
    r4 b8 b[( g]) g |
    g[( e]) e d[( f]) a |
    a g
  }
  \addlyrics {
    \override LyricText #'font-shape = #'italic
    The man who feels love's sweet e -- mo -- tion
  }
}
@end lilypond

@noindent
これで歌詞がすべてイタリック体で譜刻されました。


@subheading 歌詞モードの中でコンテキストを指定する

@cindex context, specifying in lyric mode (歌詞モード内でコンテキストを指定する)
@cindex lyric mode, specifying context (歌詞モード内でコンテキストを指定する)

歌詞の場合、以前のようなコマンドの発行の仕方の中でコンテキストを@c
指定しようとしても失敗するでしょう。@c
歌詞モードの中で入力される音節はスペース、改行、数字のいずれかで区切られます。@c
他のすべての文字は音節の一部と見なされます。@c
これが、終端の @code{@}} の前にはスペースか改行を@c
置かなければならない理由です。@c
そうしないと、終端の @code{@}} は最後の音節の一部に含まれてしまいます。@c
同様に、コンテキスト名とオブジェクト名を区切るために、@c
ピリオドまたはドット @q{.} の前と後ろにスペースを挿入しなければなりません。@c
さもないと 2 つの名前は一緒になってしまい、インタプリタはそれらを@c
認識できなくなります。@c
そのため、コマンドは以下のようにすべきです:

@example
@bs{}override Lyrics . LyricText #'font-shape = #'italic
@end example

@warning{歌詞の中では、最後の音節と終端の波括弧の間に常にスペースを@c
置いてください。}

@warning{歌詞の中のオーバライドでは、コンテキスト名とオブジェクト名の@c
間にあるドットの両側に常にスペースを置いてください。}


@seealso
学習マニュアル: @ref{Scheme チュートリアル}


@node プロパティのタイプ
@subsection プロパティのタイプ
@translationof Types of properties

@cindex property types (プロパティ タイプ)

これまでにプロパティのタイプを 2 つ見てきました: 
@code{number} と @code{symbol} です。@c
プロパティに与える値が有効であるためには、その値は正しいタイプであり、@c
そのタイプのルールに従っていなければなりません。@c
プロパティのタイプは内部リファレンスの中で常にプロパティ名の後の括弧の中に@c
表示されています。@c
ここに、あなたが必要になるであろうプロパティのタイプを、@c
そのタイプのルールといくつかの例と共にリスト アップします。@c
もちろん、@code{@bs{}override} コマンドの中でプロパティの値を入力する時は、@c
常にそれらの値の前にハッシュ記号 @code{#} を付け加える必要があります。

@multitable @columnfractions .2 .45 .35
@headitem プロパティ タイプ
  @tab 規則
  @tab 例
@item Boolean
  @tab 真か偽のどちらかで、それぞれ #t と #f で表されます
  @tab @code{#t}, @code{#f}
@item Dimension (譜表スペース)
  @tab 正の小数 (譜表スペース単位)
  @tab @code{2.5}, @code{0.34}
@item Direction
  @tab 有効な向きを表す定数またはそれと等価な数値 (-1 から 1 までの小数が@c
許可されます)
  @tab @code{LEFT}, @code{CENTER}, @code{UP},
       @code{1}, @code{-1}
@item Integer
  @tab 正の整数
  @tab @code{3}, @code{1}
@item List
  @tab 値のセット。@c
セットの値はスペースで区切られ、前にアポストロフィが付いた括弧で囲まれます
  @tab @code{'(left-edge staff-bar)}, @code{'(1)},
       @code{'(1.0 0.25 0.5)}
@item Markup
  @tab 有効なマークアップ
  @tab @code{@bs{}markup @{ \italic "cresc." @}}
@item Moment
  @tab make-moment 関数で構築される全音符の分数
  @tab @code{(ly:make-moment 1 4)},
       @code{(ly:make-moment 3 8)}
@item Number
  @tab 正または負の小数
  @tab @code{3.5}, @code{-2.45}
@item (数の) Pair
  @tab @q{スペース . スペース} で区切られ、前にアポストロフィが付いた括弧で@c
囲まれた 2 つの数値
  @tab @code{'(2 . 3.5)}, @code{'(0.1 . -3.2)}
@item Symbol
  @tab プロパティに許可されているシンボルのセットのいずれかであり、@c
前にアポロストロフィを付けます
  @tab @code{'italic}, @code{'inside}
@item Unknown
  @tab 手続き。何のアクションも起こさない場合は @code{#f}
  @tab @code{bend::print}, @code{ly:text-interface::print},
       @code{#f}
@item Vector
  @tab 前にアポストロフィ-ハッシュ @code{'#} が付いた括弧で囲まれた 
3 要素のリスト
  @tab @code{'#(#t #t #f)}
@end multitable


@seealso
学習マニュアル: @ref{Scheme チュートリアル}


@node オブジェクトの見た目
@section オブジェクトの見た目
@translationof Appearance of objects

いくつかの例を使ってこれまでに学んだことを練習して、譜刻される楽譜の見た目を@c
変更するためにどのように調整が使われるのかを見ていきましょう。


@menu
* オブジェクトの可視性と色::
* オブジェクトのサイズ::
* オブジェクトの長さと太さ::
@end menu


@node オブジェクトの可視性と色
@subsection オブジェクトの可視性と色
@translationof Visibility and color of objects

教育目的の楽譜では、ある要素を省略した楽譜を譜刻して、学生にそれを付け足させる@c
という訓練にしたいと思うかもしれません。@c
簡単な例として、その訓練とは小節線の無い楽譜だと仮定してみましょう。@c
しかしながら、通常、小節線は自動的に挿入されます。@c
どうやって小節線が譜刻されることを防ぐのでしょうか？

このことに挑戦する前に、オブジェクト プロパティは@emph{インタフェイス}と@c
呼ばれるものにグループ化されているということを思い出してください -- 
@ref{インタフェイスの中で見つかるプロパティ} を参照してください。@c
これはあるグラフィカル オブジェクトを調整するために一緒に@c
使用されるかもしれないプロパティをグループ化したものです -- 
あるオブジェクトに対してインタフェイス内のプロパティの 1 つを使うことが@c
許可されるのなら、他のプロパティも許可されます。@c
あるオブジェクトはいくつかのインタフェイス内にあるプロパティを使用し、@c
別のオブジェクトはそれとは別のインタフェイス内にあるプロパティを使用します。@c
ある特定のグラフィカルオブジェクトによって使用されるプロパティを保持している@c
インタフェイスは、そのグラフィカル オブジェクトについて記述している@c
内部リファレンス ページの最後にリスト アップされていて、@c
それらのプロパティはそれらのインタフェイスを参照することによって閲覧できます。

グラフィカル オブジェクトについての情報を見つけ出す方法を 
@ref{レイアウト オブジェクトのプロパティ} で説明しました。@c
同じアプローチを使って、内部リファレンスで小節線を@c
譜刻するレイアウト オブジェクトを見つけ出します。@c
@emph{バックエンド}を経由して@emph{すべてのレイアウト オブジェクト}に行くと、@c
そこに @code{BarLine} と呼ばれる@c
レイアウト オブジェクトがあることがわかります。@c
そのレイアウト オブジェクトのプロパティには小節線の可視性をコントロールする 
2 つのプロパティが含まれています: @c
@code{break-visibility} と @code{stencil} です。@c
さらに、@code{BarLine} はインタフェイスのいくつかをサポートしています。@c
@code{grob-interface} もサポートされていて、@c
そこには @code{transparent} プロパティと @code{color} プロパティが@c
含まれています。@c
これらすべてが小節線の可視性に影響を与えます (そしてもちろん、@c
拡大解釈すれば他の多くのレイアウト オブジェクトにも影響を与えます)。@c
次はこれらのプロパティをそれぞれ見ていきましょう。


@subheading ステンシル (stencil)

@cindex stencil property (stencil プロパティ)

このプロパティは譜刻すべきシンボル (グリフ) を指定することによって@c
小節線の見た目を制御します。@c
他の多くのプロパティでも共通に言えますが、このプロパティの値に 
@code{#f} をセットすることによって何も譜刻させなくすることができます。@c
ではやってみましょう。@c
以前と同様に、暗黙のコンテキスト @code{Voice} は省略します:

@cindex BarLine, example of overriding (BarLine をオーバライドする例)
@cindex stencil property, example (stencil プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override BarLine #'stencil = ##f
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

小節線はまだ譜刻されています。@c
何が間違っているのでしょうか？@c
内部リファレンスに戻って、@code{BarLine} のプロパティを記述しているページを@c
読み返してください。@c
そのページの先頭に 
@qq{BarLine オブジェクトは Bar_engraver によって作成されます} と@c
記述されています。@c
@code{Bar_engraver} ページに行ってください。@c
そのページの最後で、@code{Bar_engraver} を保持するコンテキストが@c
リスト アップされています。@c
それらのコンテキストのタイプはすべて @code{Staff} です。@c
ですから、@code{@bs{}override} コマンドが予期したように機能しなかったのは、@c
@code{BarLine} はデフォルトの @code{Voice} コンテキストの中には@c
いなかったからなのです。@c
コンテキストが間違って指定された場合、そのコマンドは機能しません。@c
エラー メッセージは生成されず、ログ ファイルには何もログが残りません。@c
正しいコンテキストを付け加えることによってコマンドを修正してみましょう:

@cindex BarLine, example of overriding (BarLine をオーバライドする例)
@cindex stencil property, example (stencil プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.BarLine #'stencil = ##f
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

今度は小節線が消えました。


@subheading 可視性の破棄 (break-visibility)

@cindex break-visibility property (break-visibility プロパティ)

内部リファレンスの @code{BarLine} のプロパティから 
@code{break-visibility} プロパティには 3 つのブール値からなるベクトルが@c
必要であることがわかります。@c
これらはそれぞれ、小節線が行の最後、行の途中、行の最初に譜刻されるかどうかを@c
制御します。@c
以下の例ではすべての小節線を消したいので、必要となる値は 
@code{'#(#f #f #f)} です。@c
それではやってみましょう。@c
@code{Staff} コンテキストを含めることを忘れないでください。@c
また、この値を書くときに括弧を始める前に @code{#'#} を@c
付ける必要があることにも注意してください。@c
@code{'#} はベクトルを導入するときに値の一部として必要とされ、@c
先頭の @code{#} は @code{@bs{}override} コマンドの中で常に値の前に@c
置くことが必要とされます。

@cindex BarLine, example of overriding (BarLine をオーバライドする例)
@cindex break-visibility property, example (break-visibility プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.BarLine #'break-visibility = #'#(#f #f #f)
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

今度もすべての小節線が消えました。


@subheading 透過性 (transparent)

@cindex transparent property (transparent プロパティ)
@cindex transparency (透明性)

内部リファレンスの @code{grob-interface} ページにあるプロパティから 
@code{transparent} プロパティはブール値であることがわかります。@c
これはグラフィカル オブジェクトを透明にする場合には @code{#t} に@c
セットします。@c
次の例では、小節線ではなく拍子記号を不可視にしてみましょう。@c
そうするには、まず、拍子記号のグラフィカル オブジェクト名を@c
見つける必要があります。@c
@code{TimeSignature} レイアウト オブジェクトのプロパティを見つけるために@c
内部リファレンスの @q{すべてのレイアウト オブジェクト} ページに@c
戻ってください。@c
@code{TimeSigunature} は @code{Time_signature_engraver} によって作り出され、@c
さらに、@code{Time_signature_engraver} は @code{Staff} コンテキストに含まれ、@c
さらに、@code{Staff} コンテキストは @code{grob-interface} を@c
サポートしているということがわかります。@c
そのため、拍子記号を透明にするためのコマンドは以下のようになります:

@cindex TimeSignature, example of overriding (TimeSignature をオーバライドする例)
@cindex transparent property, example (transparent プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.TimeSignature #'transparent = ##t
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
拍子記号は消えました。@c
しかしながら、このコマンドは拍子記号があるべき場所に隙間を残しています。@c
たぶん、これは学生がその部分を埋めるための練習としては望ましいでしょうが、@c
他の状況ではこの隙間は望ましくありません。@c
この隙間を取り除くには、拍子記号の @code{transparent} の代わりに@c
ステンシル (型、型紙) を @code{#f} にセットします:

@cindex TimeSignature, example of overriding (TimeSignature をオーバライドする例)
@cindex stencil property, example (stencil プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.TimeSignature #'stencil = ##f
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
違いは明白です: ステンシルを @code{#f} にセットすると、@c
オブジェクト自体が削除されます。@c
一方、オブジェクトを @code{transparent} (透明) にするとそのオブジェクトは@c
消えますが、オブジェクトは不可視になっただけです。


@subheading 色 (color)

@cindex color property (color プロパティ)

最後に、小節線の色を白にすることによって小節線を不可視にしてみましょう。@c
(これには白い小節線が譜表線と交差したところで@c
譜表線を見えたり見えなくしてしまうかもしれないという問題があります。@c
以下のいくつかの例で、このことを予測することはできないと思うかもしれません。@c
そうなる理由と、それを制御する方法についての詳細は、@c
@ruser{Painting objects white} でカバーされています。@c
しかしここでは色について学んでいるところなので、@c
オブジェクトを白で描くことの限界を受け入れるだけにしてください。)

@code{grob-interface} はカラー プロパティの値はリストであると指定しています。@c
しかしながら、そのリストが何であるべきなのかの説明はありません。@c
カラー プロパティで必要とされるリストは実際のところ内部ユニットの中にある@c
値のリストです。@c
しかし、内部ユニットの中にある値を知らなくても済むように、@c
カラーを指定するための手段がいくつか用意されています。@c
最初の方法は @ruser{List of colors} にある最初の表でリスト アップされている 
@q{標準} のカラーの 1 つを使用する方法です。@c
小節線を白にするには以下のように記述します:

@cindex BarLine, example of overriding (BarLine をオーバライドする例)
@cindex color property, example (color プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.BarLine #'color = #white
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
今度も再び小節線は見えなくなりました。@c
@emph{white} の前にアポストロフィは付かないということに注意してください -- 
これはシンボルではなく@emph{関数}です。@c
この関数が呼び出されると、この関数はカラーを白にセットするために@c
必要とされる内部値のリストを提供します。@c
標準カラー リストにある他のカラーもまた関数です。@c
これが機能していることをあなた自身が納得するために、@c
カラーをこのリストの中にある他の関数の 1 に変更しようと思うかもしれません。

@cindex color, X11 (X11 カラー)
@cindex X11 colors (X11 カラー)

@funindex x11-color

カラーを変えるための 2 番目の方法は、@ruser{List of colors} の 
2 番目のリストの中にある X11 カラー名のリストを使用する方法です。@c
しかしながら、以下のように、これらの前には X11 カラー名を内部値のリストに@c
変更するもう 1 つの関数 -- @code{x11-color} -- がなければなりません:

@cindex BarLine, example of overriding (BarLine をオーバライドする例)
@cindex color property, example (color プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.BarLine #'color = #(x11-color 'white)
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
この場合、関数 @code{x11-color} はシンボルを引数として扱うので、@c
シンボルの前にはアポストロフィをつけなくてはならず、@c
@code{x11-color} とシンボルは括弧で囲まれていなければならないということに@c
注意してください。

@cindex rgb colors (RGB カラー)
@cindex color, rgb (RGB カラー)

@funindex rgb-color

まだ 3 番目の方法が残っています。@c
これは RGB 値を内部カラーに変換する @code{rgb-color} 関数を使用する方法です。@c
この関数は赤、緑、青の輝度を表す 3 つの引数をとります。@c
これらの引数は 0 から 1 までの値をとります。@c
ですから、カラーを赤にセットする場合の値は @code{(rgb-color 1 0 0)} となり、@c
白の場合は @code{(rgb-color 1 1 1)} となります:

@cindex BarLine, example of overriding (BarLine をオーバライドする例)
@cindex color property, example (color プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.BarLine #'color = #(rgb-color 1 1 1)
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

最後に、X11 カラー セットの一部であるグレー スケールを用いる方法もあります。@c
グレー スケールの範囲は黒 @code{'grey0'} から白 @code{'grey100'} まで 
1 段階ずつあります。@c
グレー スケールの使用方法を示すために、@c
例の中にあるすべてのレイアウト オブジェクトのカラーをさまざまな濃度の@c
グレーにセットしてみましょう:

@cindex StaffSymbol, example of overriding (StaffSymbol をオーバライドする例)
@cindex TimeSignature, example of overriding (TimeSignature をオーバライドする例)
@cindex Clef, example of overriding (Clef をオーバライドする例)
@cindex NoteHead, example of overriding (NoteHead をオーバライドする例)
@cindex Stem, example of overriding (Stem をオーバライドする例)
@cindex BarLine, example of overriding (BarLine をオーバライドする例)
@cindex color property, example (color プロパティの例)
@cindex x11-color, example of using (x11-color の使用例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
{
  \time 12/16
  \override Staff.StaffSymbol   #'color = #(x11-color 'grey30)
  \override Staff.TimeSignature #'color = #(x11-color 'grey60)
  \override Staff.Clef          #'color = #(x11-color 'grey60)
  \override Voice.NoteHead      #'color = #(x11-color 'grey85)
  \override Voice.Stem          #'color = #(x11-color 'grey85)
  \override Staff.BarLine       #'color = #(x11-color 'grey10)
  c4 b8 c d16 c d8 |
  g, a16 b8 c d4 e16 |
  e8
}
@end lilypond

@noindent
各レイアウト オブジェクトに関連付けされているコンテキストに注意してください。@c
これらのコンテキストを正しく取得することが重要であり、そうしなければコマンドは@c
機能しません！@c
コンテキストの中には特定のエングラーバが置かれているということを@c
忘れないでください。@c
エングラーバに対するデフォルト コンテキストを見つけ出すには、@c
内部リファレンスのレイアウト オブジェクトからスタートして、@c
そこからそれを作り出すエングラーバのページに行きます。@c
エングラーバのページには、@c
通常はどのコンテキストにそのエングラーバが含まれているのかが記述されています。


@node オブジェクトのサイズ
@subsection オブジェクトのサイズ
@translationof Size of objects

@cindex changing size of objects (オブジェクトのサイズを変更する)
@cindex size of objects (オブジェクトのサイズ)
@cindex objects, size of (オブジェクトのサイズ)
@cindex objects, changing size of (オブジェクトのサイズを変更する)

以前の例を見直すことから始めてみましょう (@ref{音楽表記をネストする} を@c
参照してください)。@c
そこでは @rglos{ossia} として新たに一時的な譜表を導入する方法が示されています。

@cindex alignAboveContext property, example (alignAboveContext プロパティの例)
@cindex @code{\with}, example (@code{\with} の例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\new Staff ="main" {
       \relative g' {
         r4 g8 g c4 c8 d |
         e4 r8
         <<
           { f c c }
           \new Staff \with {
             alignAboveContext = #"main" }
           { f8 f c }
         >>
         r4 |
       }
     }
@end lilypond

通常、オッシアは音部記号と拍子記号無しで記述され、メインの譜表よりもわずかに@c
小さく譜刻されます。@c
今度は、すでに音部記号と拍子記号を削除する方法を知っています -- 
以下のようにそれぞれのステンシルを @code{#f} にセットするだけです:

@cindex alignAboveContext property, example (alignAboveContext プロパティの例)
@cindex @code{\with}, example (@code{\with} の例)
@cindex stencil property, example (stencil プロパティの例)
@cindex Clef, example of overriding (Clef をオーバライドする例)
@cindex TimeSignature, example of overriding (TimeSignature をオーバライドする例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\new Staff ="main" {
  \relative g' {
    r4 g8 g c4 c8 d |
    e4 r8
    <<
      { f c c }
      \new Staff \with {
        alignAboveContext = #"main"
      }
      {
        \override Staff.Clef #'stencil = ##f
        \override Staff.TimeSignature #'stencil = ##f
        { f8 f c }
      }
    >>
    r4 |
  }
}
@end lilypond

@noindent
ここで、@code{@bs{}with} 節の後にある追加の括弧のペアが、その括弧に@c
囲まれているオーバライドと音楽がオッシア譜表に適用されることを保証するために、@c
必要となります。

しかし、@code{@bs{}with} を使った譜表コンテキストの変更と 
@code{@bs{}override} を使った音部記号と拍子記号のステンシルの変更との違いは@c
何なのでしょうか？@c
主な違いは、@code{@bs{}with} 節の中で行われた変更はそのコンテキストが@c
作成されるときに行われ、そのコンテキストでは@strong{デフォルト}値として@c
残ります。@c
一方、音楽の中に埋め込まれた @code{@bs{}set} コマンドや 
@code{@bs{}override} コマンドは動的です -- それらは音楽のある特定のポイントに@c
同期して変更を行います。@c
変更が @code{@bs{}unset} や @code{@bs{}revert} を使ってセットを解除されたり@c
元に戻された場合、デフォルト値 -- これは @code{@bs{}with} 節で@c
セットされていた場合はその値、そうでない場合は通常のデフォルト値 -- に戻ります。

いくつかのコンテキスト プロパティは @code{@bs{}with} 節でのみ変更可能です。@c
これらは、コンテキストが作成された後では、変更されることのないプロパティです。@c
@code{alignAboveContext} とそのパートナー @code{alignBelowContext} が@c
そのようなプロパティです -- いったん譜表が作成されると、@c
譜表のアラインメントは決定され、@c
それを後で変更しようとすることには意味がありません。

レイアウト オブジェクトのデフォルト値は @code{@bs{}with} 節で@c
セットすることもできます。@c
通常の @code{@bs{}override} コマンドをコンテキスト名を省いて@c
使用するだけです。@c
コンテキスト名を省略するのは、そのコンテキストは明らかに 
@code{@bs{}with} 節が変更しようとしているコンテキストだからです。@c
実際、@code{@bs{}with} 節の中でコンテキストを指定するとエラーが発生します。

それでは上記の例を以下のように書き換えます:

@cindex alignAboveContext property, example (alignAboveContext プロパティの例)
@cindex @code{\with}, example (@code{\with} の例)
@cindex Clef, example of overriding (Clef をオーバライドする例)
@cindex TimeSignature, example of overriding (TimeSignature をオーバライドする例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\new Staff ="main" {
  \relative g' {
    r4 g8 g c4 c8 d |
    e4 r8
    <<
      { f c c }
      \new Staff \with {
        alignAboveContext = #"main"
        % Don't print clefs in this staff
        \override Clef #'stencil = ##f
        % Don't print time signatures in this staff
        \override TimeSignature #'stencil = ##f
      }
        { f8 f c }
    >>
    r4 |
  }
}
@end lilypond

最後に、レイアウト オブジェクトのサイズを変更してみます。

いくつかのレイアウト オブジェクトはある書体から選択されたグリフとして@c
作成されます。@c
これには符頭、臨時記号、マークアップ、音部記号、拍子記号、強弱記号、@c
歌詞が含まれます。@c
それらのサイズは、これから見ていくように、@code{font-size} プロパティを@c
変更することによって変更されます。@c
スラーやタイのような他のレイアウト オブジェクト -- 一般には、@c
スパナ オブジェクト (spanner objects) -- は個々に描かれるため、@c
@code{font-size} プロパティとは関係がありません。@c
一般に、それらのオブジェクトはそれらを取り付けられるオブジェクトからサイズを@c
決定する (訳者: 例えば、スラーはそのスラーが付着する音符から@c
そのスラーのサイズを決定する) ので、@c
通常はサイズを手動で変更する必要はありません。@c
さらに、符幹や小節線の長さ、連桁や他の線の太さ、譜表線の間隔などといった@c
他のプロパティはすべて特別な方法で変更する必要があります。

オッシアの例に戻って、まず @code{font-size} を変更してみましょう。@c
これを行うには 2 通りの方法があります。@c
以下のようなコマンドで @code{NoteHead} のような各オブジェクト タイプの@c
フォント サイズを変更する:

@example
\override NoteHead #'font-size = #-2
@end example

あるいは、@code{@bs{}set} を使って特別なプロパティ @code{fontSize} を@c
設定するか、それを @code{@bs{}with} 節に含める 
(ただし、@code{@bs{}set} は含めません) ことによって@c
すべてのフォントのサイズを変更します:

@example
\set fontSize = #-2
@end example

これらの命令文は両方ともフォント サイズを前の値から 2 段階減らします。@c
各段階でサイズはおよそ 12% 増減します。

それではオッシアの例でフォント サイズを変更してみましょう:

@cindex alignAboveContext property, example (alignAboveContext プロパティの例)
@cindex @code{\with}, example (@code{\with} の例)
@cindex Clef, example of overriding (Clef をオーバライドする例)
@cindex TimeSignature, example of overriding (TimeSignature をオーバライドする例)
@cindex fontSize property, example (fontSize プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\new Staff ="main" {
  \relative g' {
    r4 g8 g c4 c8 d |
    e4 r8
    <<
      { f c c }
      \new Staff \with {
        alignAboveContext = #"main"
        \override Clef #'stencil = ##f
        \override TimeSignature #'stencil = ##f
        % Reduce all font sizes by ~24%
        fontSize = #-2
      }
        { f8 f c }
    >>
    r4 |
  }
}
@end lilypond

これでもまだ完璧ではありません。@c
符頭とフラグは小さくなりましたが、符幹はそれに対して長すぎ、@c
譜表線は離れすぎています。@c
これらをフォント サイズの減少に比例してスケール ダウンさせる必要があります。@c
次のサブ セクションでそれを行う方法について議論します。


@node オブジェクトの長さと太さ
@subsection オブジェクトの長さと太さ
@translationof Length and thickness of objects

@cindex distances (距離)
@cindex thickness (太さ)
@cindex length (長さ)
@cindex magstep
@cindex size, changing (サイズを変更する)
@cindex stem length, changing (符幹の長さを変更する)
@cindex staff line spacing, changing (譜表線の間隔を変更する)

LilyPond では距離と長さは一般に譜表スペース -- 譜表の中の隣り合う線の間隔 -- 
で測ります (特別な場合では、譜表スペースの半分で測ることもあります)。@c
一方、たいていの @code{thickness} プロパティは @code{line-thickness} と@c
呼ばれる内部プロパティを単位として測ります。@c
例えば、デフォルトでは、ヘアピン (訳者: 強弱記号) の線の太さは 
1 単位の @code{line-thickness} であり、@c
音符の符幹の @code{thickness} は 1.3 です。@c
けれども、それとは単位の異なる太さプロパティがあるということにも@c
注意してください。@c
例えば、連桁の太さプロパティは譜表スペースで測ります。

それでは、どうやって長さをフォント サイズに比例させるのでしょうか？@c
これは、まさにこの目的のために提供されている @code{magstep} と呼ばれる@c
特別な関数の助けを借りることによって達成できます。@c
この関数は引数を 1 つ -- フォント サイズの変化 (前の例では #-2) -- 
をとり、他のオブジェクトの縮小に比例したスケーリング ファクタを返します。@c
以下のように使用します:

@cindex alignAboveContext property, example (alignAboveContext プロパティの例)
@cindex @code{\with}, example (@code{\with} の例)
@cindex Clef, example of overriding (Clef をオーバライドする例)
@cindex TimeSignature, example of overriding (TimeSignature をオーバライドする例)
@cindex fontSize property, example (fontSize プロパティの例)
@cindex StaffSymbol, example of overriding (StaffSymbol をオーバライドする例)
@cindex magstep function, example of using (magstep 関数の使用例)
@cindex staff-space property, example (staff-space プロパティの例)
@cindex stencil property, example (stencil プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\new Staff ="main" {
  \relative g' {
    r4 g8 g c4 c8 d |
    e4 r8
    <<
      { f c c }
      \new Staff \with {
        alignAboveContext = #"main"
        \override Clef #'stencil = ##f
        \override TimeSignature #'stencil = ##f
        fontSize = #-2
        % Reduce stem length and line spacing to match
        \override StaffSymbol #'staff-space = #(magstep -2)
      }
        { f8 f c }
    >>
    r4 |
  }
}
@end lilypond

@noindent
符幹の長さと他の多くの長さに関係するプロパティは常に 
@code{staff-space} プロパティの値と比例関係になるよう算出されるため、@c
それらの長さも自動的にスケール ダウンされます。@c
これはオッシアの垂直方向のスケールだけに効果を及ぼすということに@c
注意してください -- 水平方向のスケールは、メインの音楽と同期するよう、@c
メインの音楽のレイアウトによって決定されるため、水平方向のスケールは 
@code{staff-space} の変更によっていかなる影響も受けません。@c
もちろん、メインの音楽のすべてのスケールがこの方法で変更された場合、@c
水平方向のスペースも影響を受けます。@c
このことについては、後のレイアウト セクションで議論します。

そして、これでオッシアの作成は完了です。@c
他のすべてのオブジェクトのサイズと長さが類似の方法で変更されるかもしれません。

上記の例のようなスケールのちょっとした変更に対して、小節線、連桁、ヘアピン、@c
スラーなどのさまざまな描画線の太さは通常はグローバルな調節を必要としません。@c
ある特定のレイアウト オブジェクトの太さを調節する必要がある場合、@c
それを達成する最良の方法はそのオブジェクトの @code{thickness} プロパティを@c
オーバライドすることです。@c
スラーの太さを変更する例は @ref{レイアウト オブジェクトのプロパティ} で@c
示されています。@c
すべての描画オブジェクト (つまり、フォントから作り出される@c
オブジェクトではないもの) の太さが同様の方法で変更されるかもしれません。


@node オブジェクトの配置
@section オブジェクトの配置
@translationof Placement of objects


@menu
* 自動配置::
* 譜表内部オブジェクト::
* 譜表外部オブジェクト::
@end menu


@node 自動配置
@subsection 自動配置
@translationof Automatic behavior

@cindex within-staff objects (譜表内部オブジェクト)
@cindex outside-staff objects (譜表内部オブジェクト)
@cindex objects, within-staff (譜表内部オブジェクト)
@cindex objects, outside-staff (譜表外部オブジェクト)

音楽記譜法には譜表に属するオブジェクトがいくつかあり、@c
他のオブジェクトは譜表の外側に置かれるべきです。@c
それらはそれぞれ譜表内部オブジェクトと譜表外部オブジェクトと呼ばれます。

譜表内部オブジェクトは譜表上に置かれます -- 
符頭、符幹、臨時記号などです。@c
通常、それらの位置は音楽自体によって決定されます -- 
譜表内部オブジェクトは譜表のある特定の線と同じ垂直位置に置かれたり、@c
そこに置かれるべき他のオブジェクトにくっつけられたりします。@c
近接する和音の中にある符頭、符幹、臨時記号の衝突は普通は自動的に回避されます。@c
これから見ていくように、この自動配置を変更することができるコマンドと@c
オーバライドがあります。

譜表の外部にあるオブジェクトには、リハーサル記号、テキスト、@c
強弱記号などがあります。@c
LilyPond が持つ譜表外部オブジェクトの垂直位置のルールは、@c
譜表外部オブジェクトをできるだけ譜表の近くに、しかし他のオブジェクトと@c
衝突しない程度の近さに置くというものです。@c
以下で示すように、LilyPond はオブジェクトを配置する順番を決定するために 
@code{outside-staff-priority} プロパティを使用します。

最初に、LilyPond はすべての譜表内部オブジェクトを配置します。@c
それから、@code{outside-staff-priority} に従って譜表外部オブジェクトを@c
並べます。@c
譜表外部オブジェクトは最小の @code{outside-staff-priority} を@c
持つオブジェクトから順番に 1 つずつ並べられ、すでに配置されたオブジェクトと@c
衝突しないように配置されます。@c
つまり、2 つの譜表外部オブジェクトが同じスペースを巡って競合する場合、@c
より小さな @code{outside-staff-priority} を持つオブジェクトが@c
譜表の近くに配置されます。@c
2 つのオブジェクトが同じ @code{outside-staff-priority} を持つ場合、@c
先に発生するオブジェクトが譜表の近くに配置されます。

以下の例では、すべてのマークアップ テキストが同じ優先度を持っています 
(なぜなら、優先度が明示的にセットされていないからです)。@c
@q{Text3} が自動的に譜表の近く、@q{Text2} の@c
すぐ下に納まるよう配置されていることに注意してください。

@cindex markup example (マークアップの例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
c2^"Text1"
c^"Text2"
c^"Text3"
c^"Text4"
@end lilypond

デフォルトでは、譜も互いにできるだけ近くなるよう配置されます 
(最小間隔に従います)。@c
音符が隣接する譜表に向かって長く突き出てている場合、譜を離さないと@c
記譜したものが重なり合ってしまう場合にのみ譜は離されます。@c
以下の例は譜の調整によって音符が @q{ぴったりと納まる} 様子を示しています:

@lilypond[quote,ragged-right,verbatim]
<<
  \new Staff {
    \relative c' { c a, }
  }
  \new Staff {
    \relative c'''' { c a, }
  }
>>
@end lilypond


@node 譜表内部オブジェクト
@subsection 譜表内部オブジェクト
@translationof Within-staff objects

これまでにコマンド @code{\voiceXXX} がスラー、タイ、運指法記号、@c
符幹の向きに依存する他のすべてに対してどのように影響を与えるかを見てきました。@c
これらのコマンドは、多声部音楽を記述しているときに上下する旋律を@c
見分けられるようにすることを可能にするために不可欠なものです。@c
しかしながら、この自動機能をオーバライドする必要がある場合もあります。@c
このオーバライドは音楽全体に対しても、個々の音符に対してもできます。@c
この自動機能を制御しているプロパティは各レイアウト オブジェクトの 
@code{direction} プロパティです。@c
まず、これは何をするのかを説明し、それから、作成済みのコマンドを@c
いくつか紹介します。@c
それらのコマンドを使うと、一般的な変更のための明示的なオーバライドを@c
コードしなくて済みます。


スラーやタイのようなレイアウト オブジェクトはカーブを描き、曲がり、@c
上下します。@c
符幹やフラグのような他のオブジェクトも上下の向きによって位置が左右します。@c
@code{direction} がセットされているときは、これは自動的に制御されます。

@cindex down (下)
@cindex up (上)
@cindex center (中央)
@cindex neutral (ニュートラル)

以下の例は、小節 1 で符幹のデフォルトの振る舞いを示しています。@c
高い位置にある音符の符幹は下向きで、低い位置にある音符の符幹は上向きです。@c
続いて 4 つの音符の符幹をすべて強制的に下向きにし、4 つの音符の符幹を@c
すべて強制的に上向きにし、最後に 4 つの音符の符幹をデフォルトに戻します。

@cindex Stem, example of overriding (Stem をオーバライドする例)
@cindex direction property, example (direction プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
a4 g c a
\override Stem #'direction = #DOWN
a g c a
\override Stem #'direction = #UP
a g c a
\revert Stem #'direction
a g c a
@end lilypond

ここで定数 @code{DOWN} と @code{UP} を使っています。@c
これらはそれぞれ値 @code{-1} と @code{+1} を持ち、定数の代わりに@c
それらの数値を使うこともできまはす。@c
さらに値 @code{0} を使う場合もあります。@c
この値は符幹では @code{UP} を意味するものとして扱われますが、@c
いくつかのオブジェクトでは @q{center} という意味になります。@c
値 @code{0} を持つ定数に @code{CENTER} があります。

しかしながら、これらの明示的なオーバライドは普通は使われません。@c
もっと簡単で定義済みのコマンドが利用可能だからです。@c
ここに一般的なコマンドの表を挙げます。@c
それぞれのコマンドの意味が明白でない場合は、そのコマンドの意味を述べています。

@multitable @columnfractions .2 .2 .25 .35
@headitem 下/左
  @tab 上/右
  @tab 元に戻す
  @tab 効果
@item @code{\arpeggioArrowDown}
  @tab @code{\arpeggioArrowUp}
  @tab @code{\arpeggioNormal}
  @tab 矢印が下に付く、上に付く、付かない
@item @code{\dotsDown}
  @tab @code{\dotsUp}
  @tab @code{\dotsNeutral}
  @tab 譜表線を避けるための移動方向
@item @code{\dynamicDown}
  @tab @code{\dynamicUp}
  @tab @code{\dynamicNeutral}
  @tab
@item @code{\phrasingSlurDown}
  @tab @code{\phrasingSlurUp}
  @tab @code{\phrasingSlurNeutral}
  @tab Note: スラー コマンドとは別になります
@item @code{\slurDown}
  @tab @code{\slurUp}
  @tab @code{\slurNeutral}
  @tab
@item @code{\stemDown}
  @tab @code{\stemUp}
  @tab @code{\stemNeutral}
  @tab
@item @code{\textSpannerDown}
  @tab @code{\textSpannerUp}
  @tab @code{\textSpannerNeutral}
  @tab スパナとして挿入されるテキストが譜表の下/上にくる
@item @code{\tieDown}
  @tab @code{\tieUp}
  @tab @code{\tieNeutral}
  @tab
@item @code{\tupletDown}
  @tab @code{\tupletUp}
  @tab @code{\tupletNeutral}
  @tab 連符記号が音符の下/上にくる
@end multitable

これらの定義済みコマンドの前には @code{@bs{}once} が@c
付か@strong{ない}かもしれません。@c
コマンドの効果を単一の音符に制限したい場合、@c
等価の @code{@bs{}once @bs{}override} コマンドを使用するか、@c
あるいは、定義済みコマンドを使用して、効果を受けた音符の後に@c
対応する @code{@bs{}xxxNeutral} コマンドを置かなければなりません。

@subheading 運指法記号 (Fingering)

@cindex fingering, placement (運指法記号の配置)
@cindex fingering, chords (和音の運指法記号)

単一の音符に対する運指法記号の配置も @code{direction} プロパティによって@c
制御できますが、@code{direction} を変更しても和音の運指法記号は影響を@c
受けません。@c
これから見ていくように、和音の中の個々の音符の運指法記号を制御するための@c
特別なコマンドがあります。@c
このコマンドを使うことで運指法記号を各音符の上、下、左、右に@c
配置することができます。

まず、単一の音符の運指法記号に対する @code{direction} を効果を示します。@c
最初の小節はデフォルト状態で、その後で @code{DOWN} と @code{UP} を@c
指定したときの効果を示します:

@cindex Fingering, example of overriding (Fingering をオーバライドする例)
@cindex direction property, example (direction プロパティの例)

@lilypond[quote,verbatim,relative=2]
c-5 a-3 f-1 c'-5
\override Fingering #'direction = #DOWN
c-5 a-3 f-1 c'-5
\override Fingering #'direction = #UP
c-5 a-3 f-1 c'-5
@end lilypond

しかしながら、@code{direction} プロパティをオーバライドすることは、@c
手動で運指法記号を音符の上または下に配置するもっとも簡単な方法ではありません。@c
運指法番号の前に @code{-} の代わりに @code{_} または @code{^} を使う方が@c
普通は適切です。@c
ここで、上記の例にこの方法を用いた例を挙げます:

@cindex fingering example (運指法記号の例)

@lilypond[quote,verbatim,relative=2]
c-5 a-3 f-1 c'-5
c_5 a_3 f_1 c'_5
c^5 a^3 f^1 c'^5
@end lilypond

@code{direction} プロパティは和音では無視されますが、@c
方向を示す接頭辞 @code{_} と @code{^} は機能します。@c
以下で示すように、デフォルトでは、運指法記号は和音の音符の@c
上と下の両方に自動的に配置されます:

@cindex fingering example (運指法記号の例)

@lilypond[quote,verbatim,relative=2]
<c-5 g-3>
<c-5 g-3 e-2>
<c-5 g-3 e-2 c-1>
@end lilypond

@noindent
しかし、以下で示すように、運指法番号のすべてまたはいずれかを手動で強制的に@c
和音の上または下に配置するために、これはオーバライドされるかもしれません:

@cindex fingering example (運指法記号の例)

@lilypond[quote,verbatim,relative=2]
<c-5 g-3 e-2 c-1>
<c^5 g_3 e_2 c_1>
<c^5 g^3 e^2 c_1>
@end lilypond

@code{\set fingeringOrientations} コマンドを使うことによって和音の中に@c
ある個々の音符の運指法記号の配置をより細かく制御することさえできます。@c
このコマンドのフォーマットは以下のようなものです:

@example
@code{\set fingeringOrientations = #'([up] [left/right] [down])}
@end example

@noindent
@code{fingeringOrientations} は @code{Voice} コンテキストのプロパティであり、@c
@code{New_fingering_engraver} によって作成、使用されるため、@c
@code{\set} が使用されます。

このプロパティには 1 つから 3 つまでの値のリストがセットされるかもしれません。@c
このプロパティは運指法記号を上 (リストに @code{up} がある場合)、@c
下 (リストに @code{down} がある場合)、@c
左 (リストに @code{left} がある場合。リストに @code{right} がある場合は右) 
に配置します。@c
逆に配置位置がリストされていない場合、その位置に運指法記号は配置されません。@c
LilyPond はこれらの制約を受け取り、
後に続く和音の音符への運指法記号をうまく配置します。@c
@code{left} と @code{right} は相互排他的であるということに注意してください -- 
運指法記号は左右のどちらかにしか配置されないか、どちらにも配置されません。

@warning{このコマンドを使って単一の音符への運指法記号の配置を@c
コントロールするには、その音符を山括弧で囲んで単一音符の和音として@c
記述する必要があります。}

いくつか例を挙げます:

@cindex fingering example (運指法記号の例)
@cindex @code{\set}, example of using (@code{\set} の使用例)
@cindex fingeringOrientations property, example (fingeringOrientations プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
\set fingeringOrientations = #'(left)
<f-2>
< c-1  e-2 g-3 b-5 > 4
\set fingeringOrientations = #'(left)
<f-2>
< c-1  e-2 g-3 b-5 > 4
\set fingeringOrientations = #'(up left down)
<f-2>
< c-1  e-2 g-3 b-5 > 4
\set fingeringOrientations = #'(up left)
<f-2>
< c-1  e-2 g-3 b-5 > 4
\set fingeringOrientations = #'(right)
<f-2>
< c-1  e-2 g-3 b-5 > 4
@end lilypond

@noindent
運指法記号が少し込み合っているように見える場合は、@c
@code{font-size} でサイズを下げることができます。@c
デフォルト値は内部リファレンスの @code{Fingering} オブジェクトのページから 
@code{-5} であることがわかるので、@code{-7} にセットしてみましょう:

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
\override Fingering #'font-size = #-7
\set fingeringOrientations = #'(left)
<f-2>
< c-1  e-2 g-3 b-5 > 4
\set fingeringOrientations = #'(left)
<f-2>
< c-1  e-2 g-3 b-5 > 4
\set fingeringOrientations = #'(up left down)
<f-2>
< c-1  e-2 g-3 b-5 > 4
\set fingeringOrientations = #'(up left)
<f-2>
< c-1  e-2 g-3 b-5 > 4
\set fingeringOrientations = #'(right)
<f-2>
< c-1  e-2 g-3 b-5 > 4
@end lilypond 


@node 譜表外部オブジェクト
@subsection 譜表外部オブジェクト
@translationof Outside-staff objects

譜表外部オブジェクトは自動的に衝突を回避するよう配置されます。@c
小さな値の @code{outside-staff-priority} プロパティを持つオブジェクトは@c
譜表の近くに配置され、他の譜表外部オブジェクトは衝突を避けるのに必要な分だけ@c
離されます。@c
@code{outside-staff-priority} は @code{grob-interface} の中で@c
定義されているため、すべてのレイアウト  オブジェクトのプロパティです。@c
デフォルトでは、すべての譜表内部オブジェクトの @code{outside-staff-priority} は 
@code{#f} にセットされていて、譜表外部オブジェクトが作成されたときに@c
その譜表外部オブジェクトの @code{outside-staff-priority} に適当な数値が@c
セットされます。@c
以下の表はデフォルトで @code{Staff} コンテキストまたは 
@code{Voice} コンテキストの中に配置される@c
いくつかの一般的な譜表外部オブジェクトのデフォルトの 
@code{outside-staff-priority} 値を示しています。

@multitable @columnfractions .3 .3 .3
@headitem レイアウト オブジェクト
  @tab 優先度
  @tab 以下のオブジェクトの配置を制御する:
@item @code{MultiMeasureRestText}
  @tab @code{450}
  @tab 全休符上のテキスト
@item @code{TextScript}
  @tab @code{450}
  @tab マークアップ テキスト
@item @code{OttavaBracket}
  @tab @code{400}
  @tab オッターバ (オクターブを上下させる記号) の囲み
@item @code{TextSpanner}
  @tab @code{350}
  @tab テキスト スパナ
@item @code{DynamicLineSpanner}
  @tab @code{250}
  @tab すべての強弱記号
@item @code{VoltaBracketSpanner}
  @tab @code{100}
  @tab Volta (番号付きのリピート) の囲み
@item @code{TrillSpanner}
  @tab @code{50}
  @tab トリル記号
@end multitable

これらのうちのいくつかのデフォルトでの配置を示している例を挙げます。

@cindex text spanner (テキスト スパナ)
@cindex ottava bracket (オッターバ囲み)

@funindex \startTextSpan
@funindex startTextSpan
@funindex \stopTextSpan
@funindex stopTextSpan

@cindex TextSpanner, example of overriding (TextSpanner をオーバライドする例)
@cindex bound-details property, example (bound-details プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
% Set details for later Text Spanner
\override TextSpanner #'(bound-details left text)
    = \markup { \small \bold Slower }
% Place dynamics above staff
\dynamicUp
% Start Ottava Bracket
\ottava #1
c' \startTextSpan
% Add Dynamic Text
c\pp
% Add Dynamic Line Spanner
c\<
% Add Text Script
c^Text
c c
% Add Dynamic Text
c\ff c \stopTextSpan
% Stop Ottava Bracket
\ottava #0
c, c c c
@end lilypond

この例はテキスト スパナ -- 音楽の上に置かれる延長線付きのテキスト -- の@c
作成方法についても示しています。@c
スパナは @code{@bs{}startTextSpan} コマンドから 
@code{@bs{}stopTextSpan} コマンドまで延び、テキストのフォーマットは 
@code{@bs{}override TextSpanner} コマンドによって定義されます。@c
詳細は @ruser{Text spanners} を参照してください。

この例はさらにオッターバ囲みを作成する方法についても示しています。

@cindex tweaking bar number placement (小節番号の配置を調節する)
@cindex bar numbers, tweaking placement (小節番号の配置を調節する)
@cindex tweaking metronome mark placement (メトロノーム記号の配置を調節する)
@cindex metronome mark, tweaking placement (メトロノーム記号の配置を調節する)
@cindex tweaking rehearsal mark placement (リハーサル記号の配置を調節する)
@cindex rehearsal marks, tweaking placement (リハーサル記号の配置を調節する)

小節番号、メトロノーム記号、リハーサル記号は示されていないということに@c
注意してください。@c
デフォルトでは、それらは @code{Score} コンテキストの中で作成され、@c
それらの @code{outside-staff-priority} は @code{Staff} コンテキストの中で@c
作成されるレイアウト オブジェクトとは異なり無視されます。@c
小節番号、メトロノーム記号あるいはリハーサル記号を@c
それらの @code{outside-staff-priority} に従って配置したいのなら、@c
@code{Score} コンテキストからそれぞれ @code{Bar_number_engraver}, 
@code{Metronome_mark_engraver}, @code{Mark_engraver} を削除して最上位の 
@code{Staff} コンテキストに置く必要があります。@c
そうした場合、それらの記号には@c
以下のデフォルトの @code{outside-staff-priority} 値が与えられます:

@multitable @columnfractions .3 .3
@headitem レイアウト オブジェクト           @tab 優先度
@item @code{RehearsalMark}        @tab @code{1500}
@item @code{MetronomeMark}        @tab @code{1000}
@item @code{BarNumber}            @tab @code{ 100}
@end multitable

@code{outside-staff-priority} のデフォルト値による配置が@c
あなたの望みに合わない場合、いずれかのオブジェクトの優先度を@c
オーバライドすることになるかもしれません。@c
上記の例で、オッターバ囲みをテキスト スパナの下に配置したいとします。@c
すべきことは、@code{OttavaBracket} は @code{Staff} コンテキストの中に@c
作成されるということを思い出し、@code{OttavaBracket} の優先度を@c
内部リファレンスか上記の表で調べて、それを @code{TextSpanner} の値よりも@c
小さくすることです:

@cindex TextSpanner, example of overriding (TextSpanner をオーバライドする例)
@cindex bound-details property, example (bound-details プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
% Set details for later Text Spanner
\override TextSpanner #'(bound-details left text)
    = \markup { \small \bold Slower }
% Place dynamics above staff
\dynamicUp
%Place following Ottava Bracket below Text Spanners
\once \override Staff.OttavaBracket #'outside-staff-priority = #340
% Start Ottava Bracket
\ottava #1
c' \startTextSpan
% Add Dynamic Text
c\pp
% Add Dynamic Line Spanner
c\<
% Add Text Script
c^Text
c c
% Add Dynamic Text
c\ff c \stopTextSpan
% Stop Ottava Bracket
\ottava #0
c, c c c
@end lilypond

@cindex slurs and outside-staff-priority (スラーと outside-staff-priority)
@cindex slurs and articulations (スラーとアーティキュレーション)
@cindex articulations and slurs (アーティキュレーションとスラー)

スラーはデフォルトでは譜表内部オブジェクトに分類されています。@c
しかしながら、譜表の上部に配置された音符に付くスラーは@c
しばしば譜表の上に表示されます。@c
このことは、スラーがまず最初に配置されるため、アーティキュレーションなどの@c
譜表外部オブジェクトをあまりにも高い位置に押し上げる可能性があります。@c
アーティキュレーションの @code{avoid-slur} プロパティに 
@code{'inside} をセットすることでアーティキュレーションを@c
スラーよりも内側に配置することができます。@c
しかし、@code{avoid-slur} プロパティはアーティキュレーションの 
@code{outside-staff-priority} が @code{#f} にセットされている場合にのみ@c
効果を持ちます。@c
代替手段として、スラーの @code{outside-staff-priority} に数値を@c
セットすることによって、スラーを他の譜表外部オブジェクトとともに 
@code{outside-staff-priority} 値に従って配置することができます。@c
ここで、2 つの方法の効果を示す例を挙げます:

@lilypond[quote,verbatim,relative=2]
c4( c^\markup\tiny\sharp d4.) c8
c4(
\once \override TextScript #'avoid-slur = #'inside
\once \override TextScript #'outside-staff-priority = ##f
c^\markup\tiny\sharp d4.) c8
\once \override Slur #'outside-staff-priority = #500
c4( c^\markup\tiny\sharp d4.) c8
@end lilypond

@code{outside-staff-priority} は、個々のオブジェクトの垂直方向の配置を@c
制御するために使用することもできます。@c
しかしながら、その結果は常に望み通りになるわけではありません。@c
@ref{自動配置} にある例で @qq{Text3} を @qq{Text4} の上に@c
配置したいとします。@c
すべきことは @code{TextScript} の優先度を内部リファレンスか上記の表で調べて、@c
@qq{Text3} の優先度を大きくすることです:

@cindex TextScript, example of overriding (TextScript をオーバライドする例)
@cindex outside-staff-priority property, example (outside-staff-priority プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
c2^"Text1"
c^"Text2"
\once \override TextScript #'outside-staff-priority = #500
c^"Text3"
c^"Text4"
@end lilypond

これはたしかに @qq{Text3} を @qq{Text4} の上に配置しています。@c
しかし、@qq{Text3}を @qq{Text2} の上に配置して、@c
@qq{Text4} を押し下げてもいます。@c
おそらく、これはそれほど望ましい結果ではないでしょう。@c
本当に望んでいることは、すべての注釈を@c
譜表の上に譜表から同じ距離だけ離して配置することです。@c
そうするには明らかに、テキストのためにもっと広いスペースを確保するために、@c
音符を水平方向に広げる必要があります。@c
これは @code{@bs{}textLengthOn} コマンドを用いることで達成できます。

@subheading \textLengthOn

@cindex notes, spreading out with text (テキストに合わせて音符の間隔を広げる)

@funindex \textLengthOn
@funindex textLengthOn
@funindex \textLengthOff
@funindex textLengthOff

デフォルトでは、音楽のレイアウトが考慮されている限り、@c
マークアップによって作り出されるテキストは水平方向のスペースと関係しません。@c
@code{@bs{}textLengthOn} コマンドはこの動作を逆にして、@c
テキストの配置に便宜をはかる必要がある限り、音符の間隔を広げます:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\textLengthOn  % Cause notes to space out to accommodate text
c2^"Text1"
c^"Text2"
c^"Text3"
c^"Text4"
@end lilypond

デフォルトの動作に戻すためのコマンドは @code{@bs{}textLengthOff} です。@c
@code{@bs{}once} は @code{@bs{}override}, @code{@bs{}set}, @code{@bs{}revert} 
それに @code{@bs{}unset} だけに付けることができるということを@c
思い出してください。@c
そのため、@code{@bs{}textLengthOn} で @code{@bs{}once} を使うことはできません。

@cindex markup text, allowing collisions (マークアップ テキストの衝突を許可する)

マークアップ テキストは譜表の上に突き出している音符を避けます。@c
このことが望ましくない場合、優先度を @code{#f} にセットすることによって@c
上方向への自動再配置を Off にすることになるかもしれません。@c
ここで、マークアップ テキストがそのような音符とどのように相互作用するかを@c
示す例を挙げます。

@cindex TextScript, example of overriding (TextScript をオーバライドする例)
@cindex outside-staff-priority property, example (outside-staff-priority プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
% This markup is short enough to fit without collision
c2^"Tex"
c''2
R1
% This is too long to fit, so it is displaced upwards
c,,2^"Text"
c''2
R1
% Turn off collision avoidance
\once \override TextScript #'outside-staff-priority = ##f
c,,2^"Long Text   "
c''2
R1
% Turn off collision avoidance
\once \override TextScript #'outside-staff-priority = ##f
\textLengthOn  % and turn on textLengthOn
c,,2^"Long Text   "  % Spaces at end are honored
c''2
@end lilypond


@subheading 強弱記号

@cindex tweaking dynamics placement (強弱記号の配置を調整する)
@cindex dynamics, tweaking placement (強弱記号の配置を調整する)

通常、強弱記号は譜表の下に配置されます。@c
しかしながら、@code{dynamicUp} コマンドを使うことで上に@c
配置されるかもしれません。@c
強弱記号は、その記号が付いている音符と垂直方向の関係で配置され、@c
フレージング スラーや小節番号などの譜表内部オブジェクトのすべてよりも@c
下 (あるいは上) に配置されます。@c
このことは、以下の例のように、@c
到底受け入れられない結果を生み出す可能性があります:

@lilypond[quote,fragment,ragged-right,verbatim,relative=1]
\clef "bass"
\key aes \major
\time 9/8
\dynamicUp
bes4.~\f\< \( bes4 bes8 des4\ff\> c16 bes\! |
ees,2.~\)\mf ees4 r8 |
@end lilypond

しかしながら、音符とそれに付けられた強弱記号が互いに近い場合、@c
自動配置は後の方にある強弱記号を譜表から離すことによって衝突を避けます。@c
しかし、以下のかなり不自然な例が示すように、@c
それは最適な配置ではないかもしれません:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\dynamicUp
a4\f b\mf c\mp b\p
@end lilypond

@noindent
@q{実際} の音楽で同じような状況があった場合、音符の間隔をもう少し広げて、@c
すべての強弱記号が譜表から垂直方向に同じだけ離れるようにする方が@c
望ましいかもしれません。@c
マークアップ テキストの場合は @code{@bs{}textLengthOn} コマンドを@c
用いることによってそうすることができますが、@c
強弱記号には等価のコマンドがありません。@c
そのため、@code{@bs{}override} コマンドを用いてそれを達成する方法を@c
見出す必要があります。

@subheading グラフィカル オブジェクトのサイズ

@cindex grob sizing (グラフィカル オブジェクトのサイズを決定する)
@cindex sizing grobs (グラフィカル オブジェクトのサイズを決定する)

まず最初に、グラフィカル オブジェクトのサイズがどのように決定されるかを@c
学ばなくてはなりません。@c
すべてのグラフィカル オブジェクトの内部では参照ポイントが定義され、@c
それはそれらの親オブジェクトとの相対位置を決定するために使用されます。@c
このポイントは親オブジェクトから垂直方向に @code{X-offset}、@c
垂直方向に @code{Y-offset} 離れた位置になります。@c
オブジェクトの水平方向の広がりは数値のペア @code{X-extent} で与えられ、@c
そのペアはオブジェクトの左端と右端の参照ポイントとの相対関係について@c
述べています。@c
垂直方向の広がりも同様に数値のペア @code{Y-extent} によって与えられます。@c
これらは @code{grob-interface} をサポートする@c
すべてのグラフィカル オブジェクトが持つプロパティです。

@cindex @code{extra-spacing-width}

デフォルトでは、譜表外部オブジェクトには 0 の幅が与えられているため、@c
水平方向で重なる可能性があります。@c
これは @code{extra-spacing-width} に @code{'(+inf.0 . -inf.0)} を@c
セットすることによって、左端の広がりにプラス無限大、右端の広がりに@c
マイナス無限大を付け加えるというトリックによって達成されています。@c
そのため、譜表外部オブジェクトが水平方向で重ならないことを保証するには、@c
@code{extra-spacing-width} の値を @code{'(0 . 0)} に@c
オーバライドする必要があります。@c
これにより、本当の幅が明らかになります。@c
以下は強弱記号テキストに対してこれを行うコマンドです:

@example
\override DynamicText #'extra-spacing-width = #'(0 . 0)
@end example

@noindent
これが前の例で機能するかどうかを見てみましょう:

@cindex DynamicText, example of overriding (DynamicText をオーバライドする例)
@cindex extra-spacing-width property, example (extra-spacing-width プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\dynamicUp
\override DynamicText #'extra-spacing-width = #'(0 . 0)
a4\f b\mf c\mp b\p
@end lilypond

@noindent
確かに強弱記号の再配置をストップさせています。@c
しかし、2 つの問題が残っています。@c
強弱記号を互いにもう少し離すべきであり、それらは譜表から@c
同じ距離にあるほうが望ましいです。@c
最初の問題は簡単に解決できます。@c
@code{extra-spacing-width} を 0 にする代わりに、@c
もう少し大きな値を与えるのです。@c
単位は 2 本の譜表線の間隔なので、左端を 1 単位の半分だけ左に移動させ、@c
右端を 1 単位の半分だけ右に移動させると解決になります:

@cindex DynamicText, example of overriding (DynamicText をオーバライドする例)
@cindex extra-spacing-width property, example (extra-spacing-width プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\dynamicUp
% Extend width by 1 staff space
\override DynamicText #'extra-spacing-width = #'(-0.5 . 0.5)
a4\f b\mf c\mp b\p
@end lilypond

@noindent
これで前よりも良くなりました。@c
しかし、強弱記号が音符に合わせて上下するよりも、@c
同じベースラインで揃っている方が望ましいでしょう。@c
それを行うためのプロパティは @code{staff-padding} であり、@c
後に続くセクションでカバーされています。


@node オブジェクトの衝突
@section オブジェクトの衝突
@translationof Collisions of objects


@menu
* オブジェクトを移動させる::
* 表記の重なりを修正する::
* 実際の音楽からの例::
@end menu


@node オブジェクトを移動させる
@subsection オブジェクトを移動させる
@translationof Moving objects

@cindex moving overlapping objects (重なり合っているオブジェクトを移動させる)
@cindex moving colliding objects (衝突しているオブジェクトを移動させる)
@cindex moving colliding grobs (衝突しているグラフィカル オブジェクトを移動させる)
@cindex objects, moving colliding (衝突しているオブジェクトを移動させる)
@cindex grobs, moving colliding (衝突しているグラフィカル オブジェクトを移動させる)

これを聞いて驚くかもしれませんが、LilyPond は完璧ではありません。@c
いくつかの記譜要素が重なりある可能性があります。@c
これは遺憾なことですが、実際にはごく稀です。@c
通常、オブジェクトを移動させる必要性は読みやすさや美しさのためです -- 
オブジェクトの周りにもう少しスペースを多く/少なくとった方が@c
より良くなるといった場合です。

記譜要素の重なりを解決する主要なアプローチが 3 つあります。@c
それらは以下の順番で考慮されるべきです:

@enumerate
@item
重なり合っているオブジェクトの 1 つの @strong{direction} を 
@ref{譜表内部オブジェクト} でリストアップした内部オブジェクトのための@c
定義済みコマンドを用いて変更することになるかもしれません。@c
符幹、スラー、連桁、タイ、強弱記号、テキスト、@c
連符はこの方法で容易に再配置できるかもしれません。@c
この方法の限界は配置の仕方の選択肢が 2 つしかないことであり、@c
どちらも適当でないかもしれません。

@item
LilyPond がレイアウト オブジェクトを配置するときに使用する@c
@strong{オブジェクト プロパティ}を @code{@bs{}override} を用いて@c
変更することになるかもしれません。@c
オブジェクト プロパティに変更を加えることの利点は、@c
(a) スペースをとる必要がある場合に他のいくつかのオブジェクトは@c
自動的に移動させられます、@c
(b) 1 回のオーバライドを同じオブジェクト タイプの@c
インスタンスすべてに適用することができます。@c
変更するプロパティには以下のものが含まれます:

@itemize

@item
@code{direction}

これはすでに詳しくカバーされています -- 
@ref{譜表内部オブジェクト} を参照してください。

@item
@code{padding}, @code{left-padding},
@code{right-padding}, @code{staff-padding}

@cindex padding (パディング)
@cindex left-padding property (left-padding プロパティ)
@cindex padding property (padding プロパティ)
@cindex right-padding property (right-padding プロパティ)
@cindex staff-padding property (staff-padding プロパティ)

あるオブジェクトが配置されるとき、そのオブジェクトの 
@code{padding} プロパティが、そのオブジェクトとそのオブジェクトに@c
最も隣接するオブジェクトの端との間に置かれる間隔を指定します。@c
@strong{配置される最中}のオブジェクトの @code{padding} 値が@c
使用されるということに注意してください。@c
すでに配置されたオブジェクトの @code{padding} 値は無視されます。@c
@code{padding} によって指定された間隔は @code{side-position-interface} を@c
サポートするオブジェクトすべてに適用することができます。

臨時記号のグループの配置は、@code{padding} の代わりに、@code{left-padding} と 
@code{right-padding} によって制御されます。@c
これらのプロパティは @code{AccidentalPlacement} オブジェクトの中にあり、@c
注意すべきことに、そのオブジェクトは 
@strong{Staff} コンテキストの中にあります。@c
譜刻プロセスでは、符頭が最初に譜刻され、臨時記号 (がある場合は) が@c
次に符頭の左側に付け加えられます。@c
このとき、臨時記号と符頭の間隔は 
@code{right-padding} プロパティによって指定されます。@c
そのため、@code{AccidentalPlacement} オブジェクトの 
@code{right-padding} プロパティだけが臨時記号の配置に影響を与えます。

@code{staff-padding} プロパティは @code{padding} プロパティと@c
深い関わりがあります: 
@code{padding} プロパティは、@code{side-position-interface} を@c
サポートするオブジェクトとそれに最隣接する他のオブジェクト 
(一般には音符や譜表線) との間のスペースの最小量を制御します。@c
一方、@code{staff-padding} は常に譜表の外側に配置される@c
レイアウト オブジェクトにのみ適用されます -- 
これは譜表の外側に配置されるオブジェクトと譜表の間に挿入されるべき@c
スペースの最小量を制御します。@c
@code{staff-paddin} は譜表ではなく音符との相対関係で配置されるオブジェクトには@c
影響を与えないということに注意してください。@c
そのようなオブジェクトに対して @code{staff-padding} のオーバライドを@c
行ったとしてもエラーは起きないかもしれませんが、無視されます。

あなたが再配置しようとしているオブジェクトに対して求められる 
@code{padding} プロパティはどれなのかを見つけるには、内部リファレンスに@c
戻ってそのオブジェクトのプロパティを調べる必要があります。@c
@code{padding} プロパティはあなたが再配置しようとしているオブジェクトの中には@c
無いかもしれないということに注意してください。@c
その場合は、そのオブジェクトに関係があるオブジェクトを調べてください。

すべての @code{padding} 値は譜表スペースで測られます。@c
たいていのオブジェクトでは、この値はデフォルトで約 1.0 か@c
それ以下にセットされています (それぞれのオブジェクトで値はさまざまです)。@c
間隔を大きく (あるいは小さく) する必要がある場合、@c
その値はオーバライドされるかもしれません。

@item
@code{self-alignment-X}

@cindex self-alignment-X property (self-alignment-X プロパティ)

このプロパティを使うことで、親オブジェクトの参照ポイントに従って、@c
オブジェクトを左、右、中央に揃えることができます。@c
このプロパティは @code{self-alignment-interface} をサポートする@c
オブジェクトすべてに対して使用することができます。@c
一般に、テキストを保持するオブジェクトです。@c
値は @code{Left}, @code{RIGHT}, @code{CENTER} です。@c
代替手段として、@code{-1} から @code{+1} までの数値を@c
指定することもできます。@c
@code{-1} は左揃えであり、@code{+1} は右揃え、@c
その間の数値は左揃えから右揃えへのテキストを移動させます 
(訳者: @code{-0.5} であれば、左揃えと中央揃えの中間ということ)。@c
@code{1} よりも大きな数値を指定することでテキストをさらに左へ、@c
@code{-1} よりも小さな数値を指定することでテキストを@c
さらに右へ移動させることができます。@c
この値を @code{1} 増減することによる移動量はそのテキストの長さの半分です。

@item
@code{extra-spacing-width}

@cindex extra-spacing-width property (extra-spacing-width プロパティ)

このプロパティは @code{item-interface} をサポートするオブジェクトすべてで@c
利用可能です。@c
このプロパティは 2 つの数値をとり、最初の数値はオブジェクトの左側に@c
余白を追加し、2 番目の数値はオブジェクトの右側に余白を追加します。@c
負値はオブジェクトの端を左に移動させ、正値は右に移動させます。@c
そのため、オブジェクトを広くするには、最初の数値を負値にして、@c
2 番目の数値を正値にする必要があります。@c
すべてのオブジェクトが両方の数値を遵守するわけではないということに@c
注意してください。@c
例えば、@code{Accidental} オブジェクトは最初の数値 (左端) にしか@c
注意を払いません。

@item
@code{staff-position}

@cindex staff-position property (staff-position プロパティ)

@code{staff-position} は @code{staff-symbol-referencer-interface} の@c
プロパティです。@c
これは、譜表との相対関係で配置されるオブジェクトによってサポートされます。@c
このプロパティはオブジェクトの垂直方向の位置を、譜表の中央にある譜表線から@c
譜表スペースの半分を単位として、指定します。@c
このプロパティは複数小節に亘る休符、タイ、異なるボイスの中にある音符といった@c
レイアウト オブジェクトの衝突を解決する場合に有用です。

@item
@code{force-hshift}

@cindex force-hshift property (force-hshift プロパティ)

和音の中で近接して配置された音符や異なるボイスの中にあって同時に起こる音符は、@c
符頭の衝突を避けるために、2 つ (場合によってはそれ以上) の列に@c
配置されます。@c
この列は音符列と呼ばれ、その列に音符をレイアウトするために @code{NoteColumn} 
と呼ばれるオブジェクトが作成されます。

@code{force-hshift} プロパティは @code{NoteColumn} のプロパティです 
(実際には @code{note-column-interface} のプロパティです)。@c
このプロパティを変更することで音符列を、音符列特有の単位 -- 
すなわち、最初のボイスの中にある音符の符頭の幅 -- に従って、@c
移動させることができます。@c
このプロパティは、通常の 
@code{@bs{}shiftOn} コマンド 
(@ref{ボイスの明示的なインスタンス化} を参照してください) 
が音符の衝突を解決できないような複雑な状況で使用されるべきです。@c
この目的のためには、@code{extra-offset} プロパティを用いるよりも 
@code{force-hshift} プロパティを用いる方が好ましいです。@c
なぜなら、譜表スペースを単位とした距離を算出する必要が無く、@c
@code{NoteColumn} の内外に音符を移動させることは符頭のマージといった@c
他のアクションに影響を与えるからです。

@end itemize

@item
最後に、他の方法がすべて失敗した場合、オブジェクトを手動で譜表の中央線からの@c
垂直方向の相対位置に従って、あるいは新たに設定した位置との距離に従って、@c
再配置することになるかもしれません。@c
この方法の欠点は、再配置のための正確な値を算出する必要がある -- 
しばしば、その算出はそれぞれのオブジェクトに対して個々に、トライ＆エラーで@c
行われます -- 必要があるということ、さらに、この方法による移動は 
LilyPond が他のオブジェクトをすべて配置した後に行われるため、@c
ユーザはその結果として起こるかもしれない衝突を@c
すべて回避する責任があるということです。@c
しかし、この方法の最大の問題点は、音楽が後で変更された場合に、@c
再配置用の値を再び算出する必要があるということです。@c
このタイプの手動再配置のために使用されるプロパティは以下のようなものです:

@table @code
@item extra-offset

@cindex extra-offset property (extra-offset プロパティ)

このプロパティは @code{grob-interface} をサポートするレイアウト オブジェクトの@c
いずれかに適用されます。@c
このプロパティはペアになった数値をとり、それぞれの数値は@c
水平方向と垂直方向の移動を指定します。@c
負値はオブジェクトを左または下へ移動させます。@c
単位は譜表スペースです。@c
この移動はオブジェクトの譜刻が完了した後に行われるため、あるオブジェクトを@c
任意の位置へ、他のオブジェクトに影響を与えることなく、再配置することができます。

@item positions

@cindex positions property (positions プロパティ)

このプロパティは、連桁、スラー、連符の傾きと高さを手動で調節するために@c
最も有用なプロパティです。@c
このプロパティはペアになった数値をとり、それぞれの数値は連桁、@c
スラーなどの左端と右端の位置を譜表の中央線との距離で指定します。@c
単位は譜表スペースです。@c
けれども、スラーとフレージング スラーを任意の値で@c
再配置することはできないということに注意してください。@c
LilyPond はまずスラーが取り得る位置のリストを生成し、それからデフォルトでは 
@qq{最良に見える} スラーを探します。@c
@code{positions} がオーバライドされていた場合、@c
そのリストの中からリクエストされた位置に最も近いスラーが選択されます。
@end table

@end enumerate

あるオブジェクトがこれらのプロパティすべてを持っているわけではありません。@c
内部リファレンスに行き、そのオブジェクトではどのプロパティが@c
利用可能なのかを調べる必要があります。

@multitable @columnfractions .5 .5
@headitem オブジェクト タイプ
  @tab オブジェクト名
@item アーティキュレーション (Articulation)
  @tab @code{Script}
@item 連桁 (Beam)
  @tab @code{Beam}
@item 強弱記号 (Dynamic) (垂直方向)
  @tab @code{DynamicLineSpanner}
@item 強弱記号 (Dynamic) (水平方向)
  @tab @code{DynamicText}
@item 運指法記号 (Fingering)
  @tab @code{Fingering}
@item リハーサル / テキスト記号 (Rehearsal / Text mark)
  @tab @code{RehearsalMark}
@item スラー (Slur)
  @tab @code{Slur}
@item テキスト -- つまり、@code{^"text"} (Text)
  @tab @code{TextScript}
@item タイ (Tie)
  @tab @code{Tie}
@item 連符 (Tuplet)
  @tab @code{TupletBracket}
@end multitable


@node 表記の重なりを修正する
@subsection 表記の重なりを修正する
@translationof Fixing overlapping notation

今度は、前のセクションで扱ったプロパティが記譜の重なりを解決する手助けを@c
どのようにできるかを見ていきましょう。

@subheading padding プロパティ

@cindex padding (パディング)
@cindex fixing overlapping notation (記譜要素の重なりを修正する)
@cindex overlapping notation (重なり合っている記譜要素)

@code{padding} プロパティに値をセットすることによって、音符とその上または下に@c
譜刻される記号との間の距離を増減することができます。

@cindex Script, example of overriding (Script をオーバライドする例)
@cindex padding property, example (padding プロパティの例)

@lilypond[quote,fragment,relative=1,verbatim]
c2\fermata
\override Script #'padding = #3
b2\fermata
@end lilypond

@cindex MetronomeMark, example of overriding (MetronomeMark をオーバライドする例)
@cindex padding property, example (padding プロパティの例)

@lilypond[quote,fragment,relative=1,verbatim]
% This will not work, see below:
\override MetronomeMark #'padding = #3
\tempo 4=120
c1
% This works:
\override Score.MetronomeMark #'padding = #3
\tempo 4=80
d1
@end lilypond

2 番目の例では、ある特定のオブジェクトを扱うのはどのコンテキストなのかを@c
突き止めることが重要であるということに注意してください。@c
@code{MetronomeMark} オブジェクトは @code{Score} コンテキストの中で@c
処理されるため、@code{Voice} コンテキストの中でのプロパティの変更は@c
無視されます。@c
更に詳細を知りたければ、@ruser{Modifying properties} を参照してください。

@code{outside-staff-priority} に従って配置されているオブジェクトの並びの中の@c
あるオブジェクトの @code{padding} プロパティが増やされた場合、@c
そのオブジェクトとそれよりも外側にあるすべてオブジェクトが移動させられます。


@subheading left-padding と right-padding

@cindex left-padding property (left-padding プロパティ)
@cindex right-padding property (right-padding プロパティ)

@code{right-padding} プロパティは臨時記号とそれが適用される音符との間の@c
スペースに影響を与えます。@c
このプロパティを変更することは必ずしも必要ではありませんが、@c
以下の例は変更を必要とする状況の 1 つを示しています。@c
B ナチュラルと B フラットの両方を保持する和音を譜刻したいとします。@c
あいまいさ (あるいは多義: ここでは B が B ナチュラルと B フラットの両方に@c
解釈できるということ) を避けるために、@c
音符の前にナチュラル記号とフラット記号の両方を置くことにします。@c
以下に、それを達成するための試みをいくつか挙げます:

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
<b bes>
<b! bes>
<b? bes>
@end lilypond

どれもうまくいっていません。@c
2 番目と 3 番目の (和) 音符では 2 つの記号が衝突しています。

これを達成するための方法の 1 つは、臨時記号のステンシルを、@c
ナチュラル記号とフラット記号を望んでいる並びで保持しているマークアップで@c
オーバライドすることです。@c
以下のように:

@cindex Accidental, example of overriding (Accidental をオーバライドする例)
@cindex text property, example (text プロパティの例)
@cindex stencil property, example (stencil プロパティの例)
@cindex AccidentalPlacement, example of overriding (AccidentalPlacement をオーバライドする例)
@cindex right-padding property, example (right-padding プロパティの例)

@lilypond[quote,ragged-right,verbatim]
naturalplusflat = \markup { \natural \flat }
\relative c'' {
  \once \override Accidental
    #'stencil = #ly:text-interface::print
  \once \override Accidental #'text = #naturalplusflat
  \once \override Score.AccidentalPlacement #'right-padding = #1.5
  <b bes>
}
@end lilypond

@noindent
これは必然的に臨時記号のステンシルをオーバライドすることになります。@c
このオーバライドについては後々までカバーされません。@c
ステンシル タイプは手続きでなければならず、ここでは @code{Accidental} の 
@code{text} プロパティの内容 -- フラット記号が後に続くナチュラル記号 -- 
を譜刻するように変更されています。@c
それらの記号は @code{right-padding} のオーバライドによって@c
符頭からさらに遠くへ移動させられています。

@noindent

@subheading staff-padding プロパティ

@cindex aligning objects on a baseline (オブジェクトをベースラインに揃える)
@cindex objects, aligning on a baseline (オブジェクトをベースラインに揃える)

@code{staff-padding} を使うことで、強弱記号などのオブジェクトを、@c
それらが取り付けられる音符の位置に依存した高さではなく、@c
譜表上のある固定した高さのベースラインに揃えることができます。@c
このプロパティは @code{DynamicText} のプロパティではなく、@c
@code{DynamicSpanner} のプロパティです。@c
この理由は、このベースラインは延長スパナを含む@strong{すべて}の強弱起動に@c
等しく適用されるべきだからです。@c
そのため、これは以前のセクションでの例の中にある強弱記号を@c
揃えるための方法になります:

@cindex DynamicText, example of overriding (DynamicText をオーバライドする例)
@cindex extra-spacing-width property, example (extra-spacing-width プロパティの例)
@cindex DynamicLineSpanner, example of overriding (DynamicLineSpanner をオーバライドする例)
@cindex staff-padding property, example (staff-padding プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=2]
\dynamicUp
% Extend width by 1 unit
\override DynamicText #'extra-spacing-width = #'(-0.5 . 0.5)
% Align dynamics to a base line 2 units above staff
\override DynamicLineSpanner #'staff-padding = #2
a4\f b\mf c\mp b\p
@end lilypond


@subheading self-alignment-X プロパティ

以下の例はこのプロパティが、運指法記号オブジェクトの右端を親の音符の@c
参照ポイントに揃えることによって、@c
弦楽器の運指法記号オブジェクトと音符の符幹とのこのプロパティが衝突を@c
解決している様子を示しています:

@cindex StringNumber, example of overriding (StringNumber をオーバライドする例)
@cindex self-alignment-X property, example (self-alignment-X プロパティの例)

@lilypond[quote,fragment,ragged-right,verbatim,relative=3]
\voiceOne
< a \2 >
\once \override StringNumber #'self-alignment-X = #RIGHT
< a \2 >
@end lilypond

@subheading staff-position プロパティ

@cindex object collision within a staff (譜内部でのオブジェクトの衝突)

あるボイスの中にある複数小節に亘る休符は他のボイスの中にある音符と@c
衝突する可能性があります。@c
このような休符は小節線と小節線の間の中央に譜刻されるため、@c
LilyPond がそれと衝突するかもしれない音符を突き止めるのは非常に困難です。@c
なぜなら、現在の音符間それに音符-休符間の衝突対応は、@c
同時に起こる音符と休符に対してのみ行われるからです。@c
以下に、このタイプの衝突の例を挙げます:

@lilypond[quote,verbatim,fragment,ragged-right, relative=1]
<< {c c c c} \\ {R1} >>
@end lilypond

ここでの最良の解決策は、複数小節に亘る休符を下へ移動させることです。@c
なぜなら、その休符はボイス 2 の中にあるからです。@c
@code{\voiceTwo} (すなわち、@code{<<@{...@} \\ @{...@}>>} 構造の 
2 番目のボイス) のデフォルト状態では、@c
@code{MultiMeasureRest} の @code{staff-position} は @code{-4} に@c
セットされています。@c
そのため、そのプロパティを、例えば半譜表スペース 4 つ分押し下げるには、@c
@code{-8} に変更する必要があります。

@cindex MultiMeasureRest, example of overriding (MultiMeasureRest をオーバライドする例)
@cindex staff-position property, example (staff-position プロパティの例)

@lilypond[quote,verbatim,fragment,ragged-right, relative=1]
<<
  {c c c c}
\\
  \override MultiMeasureRest #'staff-position = #-8
  {R1}
>>
@end lilypond

これは、例えば @code{extra-offset} を使うよりも良い解決方法です。@c
なぜなら、その休符の上に加線が自動的に挿入されるからです。

@subheading extra-offset プロパティ

@cindex positioning objects (オブジェクトの位置を決定する)
@cindex positioning grobs (グラフィカル オブジェクトの位置を決定する)
@cindex objects, positioning (オブジェクトの位置を決定する)
@cindex grobs, positioning (グラフィカル オブジェクトの位置を決定する)

@code{extra-offset} プロパティは、あるオブジェクトの水平方向と垂直方向の@c
配置を完全に制御します。

以下の例では、2 番目の運指法記号が少し左に、そして 1.8 譜表スペース下に@c
移動させられています:


@cindex Fingering, example of overriding (Fingering をオーバライドする例)
@cindex extra-offset property, example (extra-offset プロパティの例)

@lilypond[quote,fragment,relative=1,verbatim]
\stemUp
f-5
\once \override Fingering
    #'extra-offset = #'(-0.3 . -1.8)
f-5
@end lilypond


@subheading positions プロパティ

@cindex controlling tuplets, slurs, phrasing slurs, and beams manually (連符、スラー、フレージング スラーそれに連桁を手動で制御する)
@cindex manually controlling tuplets, slurs, phrasing slurs, and beams (連符、スラー、フレージング スラーそれに連桁を手動で制御する)
@cindex tuplet beams, controlling manually (連譜の連桁を手動で制御する)
@cindex slurs, controlling manually (スラーを手動で制御する)
@cindex phrasing slurs, controlling manually (フレージング スラーを手動で制御する)
@cindex beams, controlling manually (連桁を手動で制御する)

@code{positions} プロパティは連符、スラー、フレージング スラー、@c
連桁の位置と傾きを手動で制御することを可能にします。@c
ここで、装飾音符に付いたスラーを避けようとしているために@c
醜いフレージング スラーを持つ例を挙げます。

@lilypond[quote,verbatim,fragment,ragged-right,relative=1]
r4  \acciaccatura e8\( d8 c ~c d c d\)
@end lilypond

@noindent
フレージング スラーを音符の上へ移動させることで、より良い結果が得られます:

@lilypond[quote,verbatim,fragment,ragged-right,relative=1]
r4
\phrasingSlurUp
\acciaccatura e8\( d8 c ~c d c d\)
@end lilypond

@noindent
しかし、何らかの理由でそうすることができない場合、それに代わる解決策は、@c
@code{positions} プロパティを使ってフレージング スラーの左端を@c
少し下げることです。@c
この方法でも見栄えの悪さを解決できます。

@cindex PhrasingSlur, example of overriding (PhrasingSlur をオーバライドする例)
@cindex positions property, example (positions プロパティの例)

@lilypond[quote,verbatim,fragment,ragged-right,relative=1]
r4
\once \override PhrasingSlur #'positions = #'(-4 . -3)
\acciaccatura
e8\( d8 c ~c d c d\)
@end lilypond

さらに、Chopin の 前奏曲 Op 28 No. 2 の左手の譜の開始部分から取った@c
例を挙げます。@c
連桁が上部にある音符と衝突しています:

@lilypond[quote,verbatim,fragment,ragged-right]
{
\clef "bass"
<< {b,8 ais, b, g,} \\ {e, g e, g} >>
<< {b,8 ais, b, g,} \\ {e, g e, g} >>
}
@end lilypond

@noindent
これは、譜表の中央線から 2 譜表スペース上の位置にある連桁の両端を、例えば、3 
に手動で上げることによって解決することができます:

@cindex Beam, example of overriding (Beam をオーバライドする例)
@cindex positions property, example (positions プロパティの例)

@lilypond[quote,verbatim,fragment,ragged-right]
{
  \clef "bass"
  <<
    \override Beam #'positions = #'(3 . 3)
    {b,8 ais, b, g,}
  \\
    {e, g e, g}
  >>
  << {b,8 ais, b, g,} \\ {e, g e, g} >>
}
@end lilypond

@noindent
オーバライドの効果は継続して 2 番目のブロックのボイス 1 にも@c
適用されていますが、ボイス 2 の連桁にはまったく適用されていないということに@c
注意してください。

@subheading force-hshift プロパティ

@c FIXME: formatting stuff  (ie not important right now IMO)
@c @a nchor Chopin finally corrected TODOgp

今や、@ref{私はボイスを聴いている} の最後で挙げた Chopin の例に@c
どのように修正を加えるべきかを知っています。@c
この例は以下のような状態でした:

@lilypond[quote,verbatim,fragment,ragged-right]
\new Staff \relative c'' {
  \key aes \major
  <<
    { c2 aes4. bes8 } \\
    { aes2 f4 fes   } \\
    { \voiceFour
      <ees c>2
      des2
    }
  >> |
  <c ees aes c>1 |
}
@end lilypond

@noindent
最初の和音の下の方にある 2 つの音符 (つまり、3 番目のボイス (ボイス 4) の音符) 
を上の方にある 2 つの音符の音符列からずらすべきではありません。@c
これを修正するには、下の音符の @code{force-hshift} -- 
これは @code{NoteColumn} のプロパティです -- を 0 にセットします。@c
2 番目の和音の下の方の音符は、上の方の音符のすぐ右に置くのが最良です。@c
そうするには、この音符の @code{force-hshift} を 0.5 にセットします -- 
つまり、上の方の音符の音符列から符頭の幅の半分だけ右にずらします。

ここで、最終結果を挙げます:

@cindex NoteColumn, example of overriding (NoteColumn をオーバライドする例)
@cindex force-hshift property, example (force-hshift プロパティの例)

@lilypond[quote,verbatim,fragment,ragged-right]
\new Staff \relative c'' {
  \key aes \major
  <<
    { c2 aes4. bes8 } \\
    { aes2 f4 fes   } \\
    { \voiceFour
      \once \override NoteColumn #'force-hshift = #0 <ees c>2
      \once \override NoteColumn #'force-hshift = #0.5 des2
    }
  >> |
  <c ees aes c>1 |
}
@end lilypond


@node 実際の音楽からの例
@subsection 実際の音楽からの例
@translationof Real music example

調整についてのセクションを、望みの出力を作り出すためにいくつかの調整を@c
必要とするトリッキーな例を処理するときにとられるステップを示すことで@c
締めくくります。@c
この例は、記譜法についての普通ではない問題を解決するための記譜法リファレンスの@c
使い方を示すために慎重に選ばれたものです。@c
この例は一般的な譜刻プロセスを代表するものではありません。@c
ですから、この例の複雑さでやる気を失わないでください！@c
幸いなことに、このように複雑な問題は非常に稀です！

この例は Chopin の Première Ballade, Op. 23 の第 6 - 9 小節からとりました。@c
序盤の Lento から Moderato へと移調する部分です。@c
まず最初に望んでいる出力挙げますが、例があまりにも複雑になり過ぎないように@c
強弱記号、運指法記号、ペダル記号は省きました。

@c The following should appear as music without code
@c This example should not be indexed
@lilypond[quote,ragged-right]
rhMusic = \relative c'' {
  r2
  c4.\( g8 |
  \once \override Tie #'staff-position = #3.5
  bes1~ |
  \bar "||"
  \time 6/4
  \mergeDifferentlyHeadedOn
  \mergeDifferentlyDottedOn
  bes2.^\markup {\bold "Moderato"} r8
  <<
    {c,8[ d fis bes a] | }
  \\
    % Reposition the c2 to the right of the merged note
    {c,8~ \once \override NoteColumn #'force-hshift = #1.0
    % Move the c2 out of the main note column so the merge will work
    \shiftOnn c2}
  \\
    % Stem on the d2 must be down to permit merging
    {s8 \stemDown \once \override Stem #'transparent = ##t d2}
  \\
    {s4 fis4.}
  >>
  \mergeDifferentlyHeadedOff
  \mergeDifferentlyDottedOff
  g2.\)
}

lhMusic = \relative c' {
  r2 <c g ees>2( |
  <d g, d>1)\arpeggio |
  r2. d,,4 r4 r |
  r4
}

\score {
  \new PianoStaff <<
    \new Staff = "RH"  <<
      \key g \minor
      \rhMusic
    >>
    \new Staff = "LH" <<
      \key g \minor
      \clef "bass"
      \lhMusic
    >>
  >>
}
@end lilypond

まず、第 3 小節の右手パートには 4 つのボイスが必要であることに注目します。@c
それぞれのボイスは、連桁でつながれた 5 つの 8 分音符、タイで結ばれた C、@c
半音符の D -- これは 8 分音符の D とマージされています、@c
付点 4 分音符の F シャープ -- これも同じピッチの 8 分音符とマージされています 
-- です。@c
他の部分はすべて単一のボイスなので、最も容易な方法は 4 つのボイスを@c
必要になったときに一時的に導入する方法です。@c
一時的に多声にする方法を忘れてしまったのならば、@c
@ref{私はボイスを聴いている} を見てください。@c
音符を 2 つの変数として入力し、譜表構造を @code{Score} ブロックの中で@c
セットアップすることから始めて、それで LilyPond がデフォルトで@c
どのような出力を作り出すのか見てみましょう:

@lilypond[quote,verbatim,ragged-right]
rhMusic = \relative c'' {
  r2 c4. g8 |
  bes1~ |
  \time 6/4
  bes2. r8
  % Start polyphonic section of four voices
  <<
    {c,8 d fis bes a | }
  \\
    {c,8~ c2 | }
  \\
    {s8 d2 | }
  \\
    {s4 fis4. | }
  >>
  g2.
}

lhMusic = \relative c' {
  r2 <c g ees>2 |
  <d g, d>1 |
  r2. d,,4 r4 r |
  r4
}

\score {
  \new PianoStaff <<
    \new Staff = "RH"  <<
      \key g \minor
      \rhMusic
    >>
    \new Staff = "LH" <<
      \key g \minor
      \clef "bass"
      \lhMusic
    >>
  >>
}
@end lilypond

すべての音符は間違っていません。@c
しかしながら、見た目は満足とは程遠いものです。@c
タイは移調する拍子記号と衝突していて、第 3 小節の連桁の付け方は@c
間違っていて、音符はマージされておらず、いくつかの記譜要素は欠けています。@c
簡単なものから片付けていきましょう。@c
連桁の付け方は手動で連桁を挿入することで修正でき、左手パートのスラーと@c
右手パートのフレージング スラーは簡単に追加できます -- 
なぜなら、これらはすべてチュートリアルでカバーされているからです。@c
これらの修正を加えると、以下のようになります:

@lilypond[quote,verbatim,ragged-right]
rhMusic = \relative c'' {
  r2 c4.\( g8 |
  bes1~ |
  \time 6/4
  bes2. r8
  % Start polyphonic section of four voices
  <<
    {c,8[ d fis bes a] | }
  \\
    {c,8~ c2 | }
  \\
    {s8 d2 | }
  \\
    {s4 fis4. | }
  >>
  g2.\)
}

lhMusic = \relative c' {
  r2 <c g ees>2( |
  <d g, d>1) |
  r2. d,,4 r4 r |
  r4
}

\score {
  \new PianoStaff <<
    \new Staff = "RH"  <<
      \key g \minor
      \rhMusic
    >>
    \new Staff = "LH" <<
      \key g \minor
      \clef "bass"
      \lhMusic
    >>
  >>
}
@end lilypond

第 1 小節は正しくなりました。@c
第 2 小節にはアルペジオが含まれていて、2 重の小節線で終わります。@c
この学習マニュアルではこれらのことは言及されてこなかったのに、@c
どうやってやればいいのでしょうか？@c
ここで、記譜法リファレンスに移行する必要があります。@c
索引で @q{arpeggio} と @q{bar line} を探せばすぐに、アルペジオは 
@code{@bs{}arpeggio} を和音の後に付け加えることによって作り出され、@c
2 重小節線は @code{@bs{}bar "||"} コマンドによって作り出されることが@c
わかります。@c
それは簡単にできます。@c
次に、タイと拍子記号の衝突を修正する必要があります。@c
これはタイを上に移動させる方法が最善です。@c
オブジェクトの移動については以前に @ref{オブジェクトを移動させる} でカバーしました。@c
そこでは、譜表との相対位置で配置されるオブジェクトは、@c
そのオブジェクトの @code{staff-position} プロパティを@c
オーバライドすることによって、移動させることができると述べられています。@c
このプロパティは譜表スペースの半分を単位として、譜表の中央線からの距離で@c
指定されます。@c
ですから、以下の以下のオーバライドをタイで結ばれる最初の音符の前に置けば、@c
タイは中央線から 3.5 半譜表スペースだけ上の位置に移動させられます:

@code{\once \override Tie #'staff-position = #3.5}

これで第 2 小節の修正も完了で、以下のようになります:

@lilypond[quote,verbatim,ragged-right]
rhMusic = \relative c'' {
  r2 c4.\( g8 |
  \once \override Tie #'staff-position = #3.5
  bes1~ |
  \bar "||"
  \time 6/4
  bes2. r8
  % Start polyphonic section of four voices
  <<
    {c,8[ d fis bes a] | }
  \\
    {c,8~ c2 | }
  \\
    {s8 d2 | }
  \\
    {s4 fis4. | }
  >>
  g2.\)
}

lhMusic = \relative c' {
  r2 <c g ees>2( |
  <d g, d>1)\arpeggio |
  r2. d,,4 r4 r |
  r4
}

\score {
  \new PianoStaff <<
    \new Staff = "RH"  <<
      \key g \minor
      \rhMusic
    >>
    \new Staff = "LH" <<
      \key g \minor
      \clef "bass"
      \lhMusic
    >>
  >>
}
@end lilypond

第 3 小節 -- Moderato セクションの開始部分 -- に取り掛かります。@c
チュートリアルで @code{@bs{}markup} コマンドを使ってボールド体のテキストを@c
付け加える方法を示しましたので、@q{Moderato} をボールド体で付け加えることは@c
容易です。@c
しかし、異なるボイスの中にある音符をマージするにはどうするのでしょうか？@c
ここで、助けを求めて記譜法リファレンスに移行する必要があります。@c
記譜法リファレンスで @qq{merge} を探せばすぐに、@c
@ruser{Collision resolution} で符頭や付点の付き方が異なる音符を@c
マージするためのコマンドにたどり着きます。@c
今回の例では、多声部セクションで両方のタイプの音符をマージする 
(異なる符頭を持つ音符のマージと、付点の付き方が異なる音符のマージ) 
必要があるので、記譜法リファレンスで見つけた情報を使って、以下のコマンド:

@example
\mergeDifferentlyHeadedOn
\mergeDifferentlyDottedOn
@end example

@noindent
を多声部セクションの開始点に置き、以下のコマンド:

@example
\mergeDifferentlyHeadedOff
\mergeDifferentlyDottedOff
@end example

@noindent
をセクションの終了点に置きます。これで、例は以下のようになります:

@lilypond[quote,verbatim,ragged-right]
rhMusic = \relative c'' {
  r2 c4.\( g8 |
  \once \override Tie #'staff-position = #3.5
  bes1~ |
  \bar "||"
  \time 6/4
  bes2.^\markup {\bold "Moderato"} r8
  \mergeDifferentlyHeadedOn
  \mergeDifferentlyDottedOn
  % Start polyphonic section of four voices
  <<
    {c,8[ d fis bes a] | }
  \\
    {c,8~ c2 | }
  \\
    {s8 d2 | }
  \\
    {s4 fis4. | }
  >>
  \mergeDifferentlyHeadedOff
  \mergeDifferentlyDottedOff
  g2.\)
}

lhMusic = \relative c' {
  r2 <c g ees>2( |
  <d g, d>1)\arpeggio |
  r2. d,,4 r4 r |
  r4
}

\score {
  \new PianoStaff <<
    \new Staff = "RH"  <<
      \key g \minor
      \rhMusic
    >>
    \new Staff = "LH" <<
      \key g \minor
      \clef "bass"
      \lhMusic
    >>
  >>
}
@end lilypond

オーバライドは 2 つの F シャープの音符をマージしましたが、@c
2 つの D をマージしませんでした。@c
なぜマージしなかったのでしょうか？@c
その答えは記譜法リファレンスの同じセクションにあります -- 
マージされる音符は反対向きの符幹を持っていなくてはならず、@c
同じ音符列に 3 つ目の音符がある場合は 2 つの音符をマージさせることは@c
できません。@c
今回の例では、2 つの D は両方とも上向きの符幹を持っていて、@c
3 つ目の音符 -- C -- が存在します。@c
我々は @code{@bs{}stemDown} を用いて符幹の向きを変更する方法を知っていて、@c
記譜法リファレンスも C を移動させる方法について述べています -- 
@code{@bs{}shift} コマンドの 1 つを用いてシフトを行います。@c
しかし、どのシフトを行えばよいのでしょうか？@c
C はシフト off のボイス 2 の中にあり、2 つの D はボイス 1 とボイス 3 -- 
それぞれ、シフト off とシフト on -- の中にあります。@c
ですから、C が 2 つの D と衝突するのを避けるために、@c
@code{@bs{}shiftOnn} を用いて C を更にシフトさせる必要があります。@c
これらの変更を加えると、以下のようになります:

@cindex Tie, example of overriding
@cindex staff-position property, example

@lilypond[quote,verbatim,ragged-right]
rhMusic = \relative c'' {
  r2 c4.\( g8 |
  \once \override Tie #'staff-position = #3.5
  bes1~ |
  \bar "||"
  \time 6/4
  bes2.^\markup {\bold "Moderato"} r8
  \mergeDifferentlyHeadedOn
  \mergeDifferentlyDottedOn
  % Start polyphonic section of four voices
  <<
    {c,8[ d fis bes a] | }
  \\
    % Move the c2 out of the main note column so the merge will work
    {c,8~ \shiftOnn c2 | }
  \\
    % Stem on the d2 must be down to permit merging
    {s8 \stemDown d2 | }
  \\
    {s4 fis4. | }
  >>
  \mergeDifferentlyHeadedOff
  \mergeDifferentlyDottedOff
  g2.\)
}

lhMusic = \relative c' {
  r2 <c g ees>2( |
  <d g, d>1)\arpeggio |
  r2. d,,4 r4 r |
  r4
}

\score {
  \new PianoStaff <<
    \new Staff = "RH"  <<
      \key g \minor
      \rhMusic
    >>
    \new Staff = "LH" <<
      \key g \minor
      \clef "bass"
      \lhMusic
    >>
  >>
}
@end lilypond

もうちょっとです。@c
残っている問題は 2 つだけです: 
マージされた D の下向きの符幹はあるべきではなく、C は D の右側に配置した方が@c
良いということです。@c
以前に行った調整からこれらを行う方法を両方とも知っています: 
符幹を透明にして、@code{force-hshift} プロパティを用いて C を移動させます。@c
ここで、最終結果を示します:

@cindex NoteColumn, example of overriding
@cindex force-hshift property, example
@cindex Stem, example of overriding
@cindex transparent property, example

@lilypond[quote,verbatim,ragged-right]
rhMusic = \relative c'' {
  r2
  c4.\( g8 |
  \once \override Tie #'staff-position = #3.5
  bes1~ |
  \bar "||"
  \time 6/4
  bes2.^\markup {\bold "Moderato"} r8
  \mergeDifferentlyHeadedOn
  \mergeDifferentlyDottedOn
  <<
    {c,8[ d fis bes a] | }
  \\
    % Reposition the c2 to the right of the merged note
    {c,8~ \once \override NoteColumn #'force-hshift = #1.0
    % Move the c2 out of the main note column so the merge will work
    \shiftOnn c2}
  \\
    % Stem on the d2 must be down to permit merging
    {s8 \stemDown \once \override Stem #'transparent = ##t d2}
  \\
    {s4 fis4.}
  >>
  \mergeDifferentlyHeadedOff
  \mergeDifferentlyDottedOff
  g2.\)
}

lhMusic = \relative c' {
  r2 <c g ees>2( |
  <d g, d>1)\arpeggio |
  r2. d,,4 r4 r |
  r4
}

\score {
  \new PianoStaff <<
    \new Staff = "RH"  <<
      \key g \minor
      \rhMusic
    >>
    \new Staff = "LH" <<
      \key g \minor
      \clef "bass"
      \lhMusic
    >>
  >>
}
@end lilypond


@node 更なる調整
@section 更なる調整
@translationof Further tweaking


@menu
* 調整のその他の使用方法::
* 調整のために変数を使用する::
* スタイル シート::
* その他の情報源::
* 処理に時間のかかる調整を避ける::
* Scheme を用いた高度な調整::
@end menu

@node 調整のその他の使用方法
@subsection 調整のその他の使用方法
@translationof Other uses for tweaks

@cindex transparent property, use of (transparent プロパティの使用方法)
@cindex objects, making invisible (オブジェクトを不可視にする)
@cindex removing objects (オブジェクトを削除する)
@cindex objects, removing (オブジェクトを削除する)
@cindex hiding objects (オブジェクトを隠す)
@cindex objects, hiding (オブジェクトを隠す)
@cindex invisible objects (不可視のオブジェクト)
@cindex objects, invisible (不可視のオブジェクト)
@cindex tying notes across voices (異なるボイスの中にある音符をタイで結ぶ)

@subheading 異なるボイスの中にある音符をタイで結ぶ

以下の例は異なるボイスの中にある音符をタイで結ぶ方法を示しています。@c
通常、タイで結べるのは同じボイスの中にある 2 つ音符だけです。@c
2 つのボイスを使い、そのうちの 1 つにタイで結んだ音符を置きます:

@lilypond[quote,fragment,relative=2]
<< { b8~ b8\noBeam }
\\ { b[ g8] }
>>
@end lilypond

@noindent
そして、そのボイスの最初の上向き符幹を消します。@c
これで、タイはボイスをまたがっているように見えます:

@cindex Stem, example of overriding (Stem をオーバライドする例)
@cindex transparent property, example (transparent プロパティの例)

@lilypond[quote,fragment,relative=2,verbatim]
<<
  {
    \once \override Stem #'transparent = ##t
    b8~ b8\noBeam
  }
\\
  { b[ g8] }
>>
@end lilypond

符幹は表示されなくなっただけなので、タイの長さが十分ではありません。@c
符幹の @code{length} を @code{8} にセットすることで符幹を伸ばすことができます:

@lilypond[quote,fragment,relative=2,verbatim]
<<
  {
    \once \override Stem #'transparent = ##t
    \once \override Stem #'length = #8
    b8~ b8\noBeam
  }
\\
  { b[ g8] }
>>
@end lilypond

@subheading MIDI でフェルマータをシミュレートする

@cindex stencil property, use of (stencil プロパティの使用方法)
@cindex fermata, implementing in MIDI (MIDI でフェルマータ を実装する)

譜表外部オブジェクトを出力から削除しようとする場合、そのオブジェクトの 
@code{transparent} プロパティではなく @code{stencil} プロパティを@c
オーバライドする方が通常は望ましいです。@c
あるオブジェクトの @code{stencil} プロパティを 
@code{#f} にセットすると、@c
そのオブジェクトは出力から完全に削除されます。@c
このことは、削除されたオブジェクトがそのオブジェクトとの相対位置で@c
配置される他のオブジェクトの配置にまったく影響を及ぼさないということを@c
意味します。

例えば、MIDI 出力でフェルマータをシミュレートするためにメトロノーム設定を@c
変更したいとします。@c
その場合、メトロノーム記号を出力に表示させたくありません。@c
そして、それが 2 つのシステム (小節とその中にある表記) 間のスペースと、@c
譜表上にある隣接する注釈の位置に影響を与えることを望みません。@c
そのため、そのメトロノーム記号の @code{stencil} プロパティを 
@code{#f} にセットする方法が最良です。@c
ここで、2 つの手法の結果を示します:

@cindex MetronomeMark, example of overriding (MetronomeMark をオーバライドする例)
@cindex transparent property, example (transparent プロパティの例)

@lilypond[quote,verbatim,ragged-right]
\score {
  \relative c'' {
    % Visible tempo marking
    \tempo 4=120
    a4 a a
    \once \override Score.MetronomeMark #'transparent = ##t
    % Invisible tempo marking to lengthen fermata in MIDI
    \tempo 4=80
    a\fermata
    % New tempo for next section
    \tempo 4=100
    a a a a
  }
  \layout { }
  \midi { }
}
@end lilypond

@cindex MetronomeMark, example of overriding (MetronomeMark をオーバライドする例)
@cindex stencil property, example (stencil プロパティの例)

@lilypond[quote,verbatim,ragged-right]
\score {
  \relative c'' {
    % Visible tempo marking
    \tempo 4=120
    a4 a a
    \once \override Score.MetronomeMark #'stencil = ##f
    % Invisible tempo marking to lengthen fermata in MIDI
    \tempo 4=80
    a\fermata
    % New tempo for next section
    \tempo 4=100
    a a a a
  }
  \layout { }
  \midi { }
}
@end lilypond

@noindent
両方の手段とも、フェルマータ部分の演奏時間を伸ばすメトロノーム記号を@c
出力から削除していて、両方とも MIDI の演奏に必要な効果を与えています。@c
しかし、1 番目の例の透明なメトロノーム記号がそれに続く拍子指示を@c
上に押し上げているのに対して、2 番目のメトロノーム記号 (ステンシルが@c
削除されたもの) は押し上げていません。


@node 調整のために変数を使用する
@subsection 調整のために変数を使用する
@translationof Using variables for tweaks

@cindex variables, using for tweaks (調整のために変数を使用する)
@cindex using variables for tweaks (調整のために変数を使用する)
@cindex tweaks, using variables for (調整のために変数を使用する)

オーバライド コマンドはしばしば長く、入力するのが大変なものになります。@c
そして、それらは完全に正しく記述されなければなりません。@c
同じオーバライドが何度も使用される場合、それらを保持する変数を定義すると@c
非常に役に立ちます。

歌詞の中のある特定の単語をボールド イタリック体で譜刻することによって、@c
それらを強調したいと仮定します。@c
歌詞の中では、@code{@bs{}italic} と @code{@bs{}bold} は (書式を) 変更したい@c
単語や文と一緒に @code{@bs{}markup} ブロックの中に入れた場合にのみ@c
機能しますが、それを毎回入力するのは大変です。@c
埋め込む必要のある単語自体が、2 つのコマンドを簡単な変数を用いて使うことを@c
妨げます。@c
代替手段として、@code{@bs{}override} コマンドと @code{@bs{}revert} コマンドを@c
使うことはできないでしょうか？

@example
@code{\override Lyrics . LyricText #'font-shape = #'italic}
@code{\override Lyrics . LyricText #'font-series = #'bold}

@code{\revert Lyrics . LyricText #'font-shape}
@code{\revert Lyrics . LyricText #'font-series}
@end example

これらも、強調する必要のある単語がたくさんある場合、入力するのが@c
非常に大変です。@c
しかしながら、これらは 2 つの変数として定義することが@emph{でき}、@c
それらの変数で単語を囲むことによって使ってその単語を強調することが@c
@emph{できます}。@c
これらのオーバライドに変数を用いることのもう 1 つの利点は、@c
ドットの両側にスペースを置く必要が無いことです。@c
なぜなら、これらのオーバライドは @code{@bs{}lyricmode} の中で@c
直接解釈されるわけではないからです。@c
ここで変数を用いる例を挙げますが、実際には早く打ち込めるように@c
もっと短い変数名を使用します:

@cindex LyricText, example of overriding (LyricText をオーバライドする例)
@cindex font-shape property, example (font-shape プロパティの例)
@cindex font-series property, example (font-series プロパティの例)

@lilypond[quote,verbatim]
emphasize = {
  \override Lyrics.LyricText #'font-shape = #'italic
  \override Lyrics.LyricText #'font-series = #'bold
}
normal = {
  \revert Lyrics.LyricText #'font-shape
  \revert Lyrics.LyricText #'font-series
}

global = { \time 4/4 \partial 4 \key c \major}
SopranoMusic   = \relative c' { c4 | e4. e8 g4  g  | a a g }
AltoMusic  = \relative c' { c4 | c4. c8 e4  e  | f f e }
TenorMusic = \relative c  { e4 | g4. g8 c4. b8 | a8 b c d e4 }
BassMusic  = \relative c  { c4 | c4. c8 c4  c  | f8 g a b c4 }
VerseOne   = \lyrics { E -- | ter -- nal \emphasize Fa -- ther, \normal | strong to save, }
VerseTwo   = \lyricmode { O | \emphasize Christ, \normal whose voice the | wa -- ters heard, }
VerseThree = \lyricmode { O | \emphasize Ho -- ly Spi -- rit, \normal | who didst brood }
VerseFour  = \lyricmode { O | \emphasize Tri -- ni -- ty \normal of | love and pow'r }

\score {
  \new ChoirStaff <<
    \new Staff <<
      \clef "treble"
      \new Voice = "Soprano"  { \voiceOne \global \SopranoMusic }
      \new Voice = "Alto" { \voiceTwo \AltoMusic }
      \new Lyrics \lyricsto "Soprano" { \VerseOne   }
      \new Lyrics \lyricsto "Soprano" { \VerseTwo   }
      \new Lyrics \lyricsto "Soprano" { \VerseThree }
      \new Lyrics \lyricsto "Soprano" { \VerseFour  }
    >>
    \new Staff <<
      \clef "bass"
      \new Voice = "Tenor" { \voiceOne \TenorMusic }
      \new Voice = "Bass"  { \voiceTwo \BassMusic  }
    >>
  >>
}
@end lilypond


@node スタイル シート
@subsection スタイル シート
@translationof Style sheets

LilyPond が作り出す出力にはさまざまな変更を加えることができます 
(詳細は @ref{出力を調整する} を参照してください)。@c
しかしながら、調整を加えたい入力ファイルがたくさんあるとしたらどうでしょう？@c
また、単に調整を実際の音楽表記から分離したいとしたらどうでしょう？@c
これはとても簡単なことです。

以下の例を見てみましょう。@c
@code{#()} を持つ部分を理解できなくても心配しないでください。@c
@ref{Scheme を用いた高度な調整} で説明されています。

@lilypond[quote,verbatim,ragged-right]
mpdolce = #(make-dynamic-script (markup #:hspace 1 #:translate (cons 5 0)
  #:line(#:dynamic "mp" #:text #:italic "dolce" )))
tempoMark = #(define-music-function (parser location markp) (string?)
#{
  \once \override Score . RehearsalMark #'self-alignment-X = #left
  \once \override Score . RehearsalMark #'extra-spacing-width = #'(+inf.0 . -inf.0)
  \mark \markup { \bold $markp }
#})

\relative c'' {
  \tempo 4=50
  a4.\mpdolce d8 cis4--\glissando a | b4 bes a2
  \tempoMark "Poco piu mosso"
  cis4.\< d8 e4 fis | g8(\! fis)-. e( d)-. cis2
}
@end lilypond

この例には出力が重なり合うという問題がいくつかあり、@c
@ref{オブジェクトを移動させる} のテクニックを使ってそれらを修正しています。@c
そこで、さらに @code{mpdolce} 定義と @code{tempoMark} 定義に関して@c
何かしてみましょう。@c
それらは望みの出力を作り出していますが、@c
それらを別の楽曲で使いたいとします。@c
単純にそれらを各ファイルの先頭部分にカット＆ペーストすることもできますが、@c
わずらわしいです。@c
その方法では定義は依然として入力ファイルの中にあり、@c
私は個人的にすべての @code{#()} は何か醜いと感じます。@c
それらを他のファイルの中に隠すことにしましょう:

@example
%%% save this to a file called "definitions.ly"
%%% これを "definitions.ly" というファイル名で保存してください
mpdolce = #(make-dynamic-script (markup #:hspace 1 #:translate (cons 5 0)
  #:line(#:dynamic "mp" #:text #:italic "dolce" )))
tempoMark = #(define-music-function (parser location markp) (string?)
#@{
  \once \override Score . RehearsalMark #'self-alignment-X = #left
  \once \override Score . RehearsalMark #'extra-spacing-width = #'(+inf.0 . -inf.0)
  \mark \markup @{ \bold $markp @}
#@})
@end example

今度は音楽ファイルを変更しましょう 
(このファイルを @file{"music.ly"} として保存してください)。

@c  We have to do this awkward example/lilypond-non-verbatim
@c  because we can't do the \include stuff in the manual.

@example
\include "definitions.ly"

\relative c'' @{
  \tempo 4=50
  a4.\mpdolce d8 cis4--\glissando a | b4 bes a2
  \once \override Score.RehearsalMark #'padding = #2.0
  \tempoMark "Poco piu mosso"
  cis4.\< d8 e4 fis | g8(\! fis)-. e( d)-. cis2
@}
@end example

@lilypond[quote,ragged-right]
mpdolce = #(make-dynamic-script (markup #:hspace 1 #:translate (cons 5 0)
  #:line(#:dynamic "mp" #:text #:italic "dolce" )))
tempoMark = #(define-music-function (parser location markp) (string?)
#{
  \once \override Score . RehearsalMark #'self-alignment-X = #left
  \once \override Score . RehearsalMark #'extra-spacing-width = #'(+inf.0 . -inf.0)
  \mark \markup { \bold $markp }
#})

\relative c'' {
  \tempo 4=50
  a4.\mpdolce d8 cis4--\glissando a | b4 bes a2
  \once \override Score.RehearsalMark #'padding = #2.0
  \tempoMark "Poco piu mosso"
  cis4.\< d8 e4 fis | g8(\! fis)-. e( d)-. cis2
}
@end lilypond

これで前よりも良くなりましたが、いくつか変更を加えることにします。@c
グリッサンド (訳者: 第 1 小節の C シャープと A の間) は見え難いので、@c
もっと太く、符頭に近づけます。@c
メトロノーム記号を、最初の音符の上ではなく、@c
音部記号の上に持ってきます。@c
最後に、私の作曲の先生は @q{C} 拍子記号を嫌っているので、@c
@q{4/4} に変更した方が良さそうです。

@file{music.ly} には変更を加えないでください。@c
@file{definitions.ly} を以下のように書き換えます:

@example
%%%  definitions.ly
mpdolce = #(make-dynamic-script (markup #:hspace 1 #:translate (cons 5 0)
  #:line( #:dynamic "mp" #:text #:italic "dolce" )))
tempoMark = #(define-music-function (parser location markp) (string?)
#@{
  \once \override Score . RehearsalMark #'self-alignment-X = #left
  \once \override Score . RehearsalMark #'extra-spacing-width = #'(+inf.0 . -inf.0)
  \mark \markup @{ \bold $markp @}
#@})

\layout@{
  \context @{ \Score
    \override MetronomeMark #'extra-offset = #'(-9 . 0)
    \override MetronomeMark #'padding = #'3
  @}
  \context @{ \Staff
    \override TimeSignature #'style = #'numbered
  @}
  \context @{ \Voice
    \override Glissando #'thickness = #3
    \override Glissando #'gap = #0.1
  @}
@}
@end example

@lilypond[quote,ragged-right]
mpdolce = #(make-dynamic-script (markup #:hspace 1 #:translate (cons 5 0)
  #:line( #:dynamic "mp" #:text #:italic "dolce" )))
tempoMark = #(define-music-function (parser location markp) (string?)
#{
  \once \override Score . RehearsalMark #'self-alignment-X = #left
  \once \override Score . RehearsalMark #'extra-spacing-width = #'(+inf.0 . -inf.0)
  \mark \markup { \bold $markp }
#})

\layout{
  \context { \Score
    \override MetronomeMark #'extra-offset = #'(-9 . 0)
    \override MetronomeMark #'padding = #'3
  }
  \context { \Staff
    \override TimeSignature #'style = #'numbered
  }
  \context { \Voice
    \override Glissando #'thickness = #3
    \override Glissando #'gap = #0.1
  }
}

\relative c'' {
  \tempo 4=50
  a4.\mpdolce d8 cis4--\glissando a | b4 bes a2
  \once \override Score.RehearsalMark #'padding = #2.0
  \tempoMark "Poco piu mosso"
  cis4.\< d8 e4 fis | g8(\! fis)-. e( d)-. cis2
}
@end lilypond

もっと良くなりました！@c
今度はこれを公表したいとします。@c
私の作曲の先生は @q{C} 拍子記号を嫌っていますが、@c
私は幾分好きです。@c
現在の @code{definitions.ly} を @code{web-publish.ly} にコピーして、@c
それにを変更を加えてみましょう。@c
この音楽はスクリーンに表示される PDF を作り出すことを意図したものなので、@c
出力のフォントを全体に大きくすることにします。

@example
%%%  definitions.ly
mpdolce = #(make-dynamic-script (markup #:hspace 1 #:translate (cons 5 0)
  #:line( #:dynamic "mp" #:text #:italic "dolce" )))
tempoMark = #(define-music-function (parser location markp) (string?)
#@{
  \once \override Score . RehearsalMark #'self-alignment-X = #left
  \once \override Score . RehearsalMark #'extra-spacing-width = #'(+inf.0 . -inf.0)
  \mark \markup @{ \bold $markp @}
#@})

#(set-global-staff-size 23)
\layout@{
  \context @{ \Score
    \override MetronomeMark #'extra-offset = #'(-9 . 0)
    \override MetronomeMark #'padding = #'3
  @}
  \context @{ \Staff
  @}
  \context @{ \Voice
    \override Glissando #'thickness = #3
    \override Glissando #'gap = #0.1
  @}
@}
@end example

@lilypond[quote,ragged-right]
mpdolce = #(make-dynamic-script (markup #:hspace 1 #:translate (cons 5 0)
  #:line( #:dynamic "mp" #:text #:italic "dolce" )))
tempoMark = #(define-music-function (parser location markp) (string?)
#{
  \once \override Score . RehearsalMark #'self-alignment-X = #left
  \once \override Score . RehearsalMark #'extra-spacing-width = #'(+inf.0 . -inf.0)
  \mark \markup { \bold $markp }
#})

#(set-global-staff-size 23)
\layout{
  \context { \Score
    \override MetronomeMark #'extra-offset = #'(-9 . 0)
    \override MetronomeMark #'padding = #'3
  }
  \context { \Voice
    \override Glissando #'thickness = #3
    \override Glissando #'gap = #0.1
  }
}

\relative c'' {
  \tempo 4=50
  a4.\mpdolce d8 cis4--\glissando a | b4 bes a2
  \once \override Score.RehearsalMark #'padding = #2.0
  \tempoMark "Poco piu mosso"
  cis4.\< d8 e4 fis | g8(\! fis)-. e( d)-. cis2
}
@end lilypond

音楽ファイルの中では、単に @code{@bs{}include "definitions.ly"} を 
@code{@bs{}include "web-publish.ly"} に置き換えるだけです。@c
もちろん、これをもっと便利なようにすることができます。@c
@file{definitions.ly} ファイルには 
@code{mpdolce} と @code{tempoMark} の定義だけを持たせて、@c
@file{web-publish.ly} ファイルには@c
上で記述した @code{@bs{}layout} セクションだけを持たせ、@c
@file{university.ly} ファイルには@c
私の先生の好む出力を作り出すための調整だけを持たせます。@c
@file{music.ly} の先頭部分は以下のようになります:

@example
\include "definitions.ly"

%%%  Only uncomment one of these two lines!
\include "web-publish.ly"
%\include "university.ly"
@end example

このアプローチは、@c
あなたがパーツ一式を作っているだけだとしても役に立つ可能性があります。@c
私は自分のプロジェクトのために@c
半ダースの @q{スタイル シート} ファイルを使います。@c
私はそれぞれの音楽ファイルを 
@code{@bs{}include "../global.ly"} で始め、@c
@file{gloval.ly} には以下の内容を記述しています:

@example
%%%   global.ly
\version @w{"@version{}"}
#(ly:set-option 'point-and-click #f)
\include "../init/init-defs.ly"
\include "../init/init-layout.ly"
\include "../init/init-headers.ly"
\include "../init/init-paper.ly"
@end example


@node その他の情報源
@subsection その他の情報源
@translationof Other sources of information

内部リファレンスは LilyPond についての多くの情報を持っていますが、@c
LilyPond の内部ファイルを調べることによってさらに多くの情報を収集することが@c
できます。@c
内部ファイルを探究するには、まずあなたの使っているシステム特有のディレクトリを@c
見つけ出す必要があります。@c
このディレクトリの場所は、(a) あなたが lilypond.org からコンパイル済みの@c
バイナリをダウンロードすることによって LilyPond を手に入れたのか、@c
それとも、パッケージ マネージャから LilyPond をインストールした 
(つまり、Linux と一緒に配布されたか、fink や cygwin でインストールされた) 
のか、(b) LilyPond はどの OS 上で使用されているのか、に依存します:

@strong{lilypond.org からダウンロードした}

@itemize @bullet
@item Linux

@file{@var{INSTALLDIR}/lilypond/usr/share/lilypond/current/} に進んでください

@item MacOS X

@file{@var{INSTALLDIR}/LilyPond.app/Contents/Resources/share/lilypond/current/}
に進んでください。@c
ターミナルからこのディレクトリへ @code{cd} で移動するか、@c
LilyPond アプリケーション上でコントロール クリックして 
@q{Show Package Contents} を選択します。

@item Windows

@file{@var{INSTALLDIR}/LilyPond/usr/share/lilypond/current/} に@c
進んでください。Windows Explorer を使います。


@end itemize

@strong{パッケージ マネージャからインストールした、あるいは、@c
ソースからコンパイルした}

@file{@var{PREFIX}/share/lilypond/@var{X.Y.Z}/} に進んでください。@c
@var{PREFIX} はパッケージ マネージャか @code{configure} スクリプトによって@c
セットされるものであり、@var{X.Y.Z} は LilyPond のバージョン番号です。

@smallspace

このディレクトリの中に 2 つの興味深いサブディレクトリがあります:

@itemize
@item @file{ly/} - LilyPond フォーマットに関するファイルを保持しています
@item @file{scm/} -Scheme フォーマットに関するファイルを保持しています
@end itemize

@file{ly/} の中にあるファイルから見ていきましょう。@c
@file{ly/property-init.ly} をテキスト エディタで開いてください。@c
エディタはあなたが普段 @code{.ly} ファイルを編集するために使っているもので@c
結構です。@c
このファイルは標準の LilyPond 定義済みコマンド -- @code{@bs{}stemUp} や 
@code{@bs{}slurDotted} など -- のすべての定義を保持しています。@c
1 つまたは複数の @code{@bs{}override} コマンドを保持している@c
変数の定義以外のものはないということがわかるでしょう。@c
例えば、@code{@bs{}tieDotted} は以下のように定義されています:

@example
tieDotted = @{
  \override Tie #'dash-period = #0.75
  \override Tie #'dash-fraction = #0.1
@}
@end example

あなたがこれらのデフォルト値を好まない場合、これらの定義済みコマンドを@c
容易に再定義することができます -- 
他の変数と同様に、入力ファイルの先頭で定義します。

以下のファイルは @file{ly/} で見つかる有用なファイルです:

@multitable @columnfractions .4 .6
@headitem ファイル名
  @tab 内容
@item @file{ly/engraver-init.ly}
  @tab エングラーバ コンテキストの定義
@item @file{ly/paper-defaults-init.ly}
  @tab 紙面関係のデフォルトの仕様
@item @file{ly/performer-init.ly}
  @tab パフォーマ コンテキストの定義
@item @file{ly/property-init.ly}
  @tab すべての共通定義済みコマンドの定義
@item @file{ly/spanner-init.ly}
  @tab スパナ関係の定義済みコマンドの定義
@end multitable

他の設定 (マークアップ コマンドの定義など) は 
@code{.scm} (Scheme) ファイルとして保存されています。@c
Scheme プログラミング言語は、LilyPond 内部処理へのプログラム可能な@c
インタフェイスを提供するために使用されます。@c
これらのファイルについての詳しい説明は、Scheme 言語についての知識が@c
必要となるため、このマニュアルの範囲外です。@c
Scheme 言語とこれらのファイルを理解するには、十分な知識や時間が@c
必要であるということを知っておくべきです 
(@ref{Scheme チュートリアル} を参照してください)。

あなたがこの知識を持っているのなら、興味を持つかもしれない Scheme ファイルは@c
以下のものです:

@multitable @columnfractions .4 .6
@headitem ファイル名
  @tab 内容
@item @file{scm/auto-beam.scm}
  @tab サブ 連桁のデフォルト (訳者: 8 分音符には連桁だけが使用され、@c
16 分音符やそれよりも短い音符には連桁とサブ 連桁が使われるのだと思います)
@item @file{scm/define-grobs.scm}
  @tab Grob (グラフィカル オブジェクト) プロパティのデフォルト設定
@item @file{scm/define-markup-commands.scm}
  @tab すべてのマークアップ コマンドの仕様
@item @file{scm/midi.scm}
  @tab MIDI 出力のデフォルト設定
@item @file{scm/output-lib.scm}
  @tab フレット、色、臨時記号、小節線などの見た目に影響を与える設定
@item @file{scm/parser-clef.scm}
  @tab サポートされる音部記号の定義
@item @file{scm/script.scm}
  @tab アーティキュレーションのデフォルト設定
@end multitable


@node 処理に時間のかかる調整を避ける
@subsection 処理に時間のかかる調整を避ける
@translationof Avoiding tweaks with slower processing

LilyPond は入力ファイルの処理中に追加のチェックを行うことができます。@c
これらのチェックは実行時間を伸ばしますが、適切な結果を得るのに必要とされる@c
手動調整を減らすかもしれません。@c
テキストや歌詞の一部が余白まではみ出す場合、これらのチェックは@c
楽譜のその行を縮めてマージンの内側に収まるようにします。

すべての状況下で有効にするには、以下のように、音楽の中の行ではなく 
@code{Score} の @code{@bs{}with} ブロックの中に@c
これらのチェックのオーバライドを置くことによって、@c
動作可能な状態にする必要があります:

@example
\new Score \with @{
  % Makes sure text scripts and lyrics are within the paper margins
  \override PaperColumn #'keep-inside-line = ##t
  \override NonMusicalPaperColumn #'keep-inside-line = ##t
@} @{
   ..
@}
@end example


@node Scheme を用いた高度な調整
@subsection Scheme を用いた高度な調整
@translationof Advanced tweaks with Scheme

@code{@bs{}override} と @code{@bs{}tweak} コマンドを用いることで@c
多くのことが可能になりますが、LilyPond のアクションを変更するもっと強力な手段が 
LilyPond 内部処理へのプログラム可能なインタフェイスを通じて利用可能です。@c
Scheme プログラミング言語で書かれたコードは LilyPond の内部処理に@c
直接組み込むことができます。@c
もちろん、それを行うには Scheme プログラミングについての基礎知識が必要であり、@c
その手引きが @ref{Scheme チュートリアル} で提供されています。

多くの実現可能なことの 1 つの例としては、プロパティに定数をセットする代わりに 
Scheme プロシージャをセットすることができます。@c
このプロパティが LilyPond によってアクセスされたときに、@c
このプロシージャが呼び出されます。@c
このプロシージャが呼び出されたときに、このプロシージャによって決定された@c
値を動的にそのプロパティにセットすることができます。@c
以下の例では、符頭にその音符の譜表上での位置に従って色を付けています:

@cindex x11-color function, example of using (x11-color 関数の使用方法)
@cindex NoteHead, example of overriding (NoteHead をオーバライドする例)
@cindex color property, setting to Scheme procedure (Scheme プロシージャに color プロパティをセットする)

@lilypond[quote,verbatim,ragged-right]
#(define (color-notehead grob)
  "Color the notehead according to its position on the staff."
  (let ((mod-position (modulo (ly:grob-property grob 'staff-position) 7)))
    (case mod-position
      ;;   Return rainbow colors
      ((1) (x11-color 'red    ))  ; for C
      ((2) (x11-color 'orange ))  ; for D
      ((3) (x11-color 'yellow ))  ; for E
      ((4) (x11-color 'green  ))  ; for F
      ((5) (x11-color 'blue   ))  ; for G
      ((6) (x11-color 'purple ))  ; for A
      ((0) (x11-color 'violet ))  ; for B
    )
  )
)

\relative c' {
  % Arrange to obtain color from color-notehead procedure
  \override NoteHead #'color = #color-notehead
  c2 c' |
  b4 g8 a b4 c |
  c,2 a' |
  g1 |
}
\addlyrics {
  Some -- where o -- ver the Rain -- bow, way up high,
}
@end lilypond

@ref{Tweaking with Scheme} に、これらのプログラム可能なインタフェイスの@c
使い方を示している例がもっとあります。


